"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_rsc_lib_worker-startup_ts";
exports.ids = ["_rsc_lib_worker-startup_ts"];
exports.modules = {

/***/ "(rsc)/./lib/background-worker.ts":
/*!**********************************!*\
  !*** ./lib/background-worker.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BackgroundWorker: () => (/* binding */ BackgroundWorker),\n/* harmony export */   backgroundWorker: () => (/* binding */ backgroundWorker)\n/* harmony export */ });\n/* harmony import */ var _job_monitor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./job-monitor */ \"(rsc)/./lib/job-monitor.ts\");\n\n/**\n * Background Worker Service\n * \n * Manages all background services for the IndexNow Pro application:\n * - Job monitoring and processing\n * - Cleanup tasks\n * - Health checks\n */ class BackgroundWorker {\n    static getInstance() {\n        if (!BackgroundWorker.instance) {\n            BackgroundWorker.instance = new BackgroundWorker();\n        }\n        return BackgroundWorker.instance;\n    }\n    /**\n   * Start all background services\n   */ start() {\n        if (this.isStarted) {\n            console.log('Background worker is already started');\n            return;\n        }\n        console.log('ðŸš€ Starting IndexNow Pro background worker...');\n        try {\n            // Start job monitor\n            _job_monitor__WEBPACK_IMPORTED_MODULE_0__.jobMonitor.start();\n            this.isStarted = true;\n            console.log('âœ… Background worker started successfully');\n            // Log status every 5 minutes\n            setInterval(()=>{\n                this.logStatus();\n            }, 5 * 60 * 1000);\n        } catch (error) {\n            console.error('âŒ Failed to start background worker:', error);\n        }\n    }\n    /**\n   * Stop all background services\n   */ stop() {\n        if (!this.isStarted) {\n            console.log('Background worker is not running');\n            return;\n        }\n        console.log('ðŸ›‘ Stopping background worker...');\n        try {\n            // Stop job monitor\n            _job_monitor__WEBPACK_IMPORTED_MODULE_0__.jobMonitor.stop();\n            this.isStarted = false;\n            console.log('âœ… Background worker stopped successfully');\n        } catch (error) {\n            console.error('âŒ Error stopping background worker:', error);\n        }\n    }\n    /**\n   * Get worker status\n   */ getStatus() {\n        return {\n            isStarted: this.isStarted,\n            jobMonitor: _job_monitor__WEBPACK_IMPORTED_MODULE_0__.jobMonitor.getStatus(),\n            uptime: this.isStarted ? process.uptime() : undefined\n        };\n    }\n    /**\n   * Log current status\n   */ logStatus() {\n        const status = this.getStatus();\n        console.log('ðŸ“Š Background Worker Status:', {\n            isStarted: status.isStarted,\n            jobMonitor: status.jobMonitor.isRunning,\n            uptime: status.uptime ? `${Math.round(status.uptime / 60)} minutes` : 'N/A'\n        });\n    }\n    constructor(){\n        this.isStarted = false;\n    }\n}\n// Export singleton instance\nconst backgroundWorker = BackgroundWorker.getInstance();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvYmFja2dyb3VuZC13b3JrZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJDO0FBRTNDOzs7Ozs7O0NBT0MsR0FDTSxNQUFNQztJQUlYLE9BQU9DLGNBQWdDO1FBQ3JDLElBQUksQ0FBQ0QsaUJBQWlCRSxRQUFRLEVBQUU7WUFDOUJGLGlCQUFpQkUsUUFBUSxHQUFHLElBQUlGO1FBQ2xDO1FBQ0EsT0FBT0EsaUJBQWlCRSxRQUFRO0lBQ2xDO0lBRUE7O0dBRUMsR0FDREMsUUFBYztRQUNaLElBQUksSUFBSSxDQUFDQyxTQUFTLEVBQUU7WUFDbEJDLFFBQVFDLEdBQUcsQ0FBQztZQUNaO1FBQ0Y7UUFFQUQsUUFBUUMsR0FBRyxDQUFDO1FBRVosSUFBSTtZQUNGLG9CQUFvQjtZQUNwQlAsb0RBQVVBLENBQUNJLEtBQUs7WUFFaEIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7WUFDakJDLFFBQVFDLEdBQUcsQ0FBQztZQUVaLDZCQUE2QjtZQUM3QkMsWUFBWTtnQkFDVixJQUFJLENBQUNDLFNBQVM7WUFDaEIsR0FBRyxJQUFJLEtBQUs7UUFFZCxFQUFFLE9BQU9DLE9BQU87WUFDZEosUUFBUUksS0FBSyxDQUFDLHdDQUF3Q0E7UUFDeEQ7SUFDRjtJQUVBOztHQUVDLEdBQ0RDLE9BQWE7UUFDWCxJQUFJLENBQUMsSUFBSSxDQUFDTixTQUFTLEVBQUU7WUFDbkJDLFFBQVFDLEdBQUcsQ0FBQztZQUNaO1FBQ0Y7UUFFQUQsUUFBUUMsR0FBRyxDQUFDO1FBRVosSUFBSTtZQUNGLG1CQUFtQjtZQUNuQlAsb0RBQVVBLENBQUNXLElBQUk7WUFFZixJQUFJLENBQUNOLFNBQVMsR0FBRztZQUNqQkMsUUFBUUMsR0FBRyxDQUFDO1FBQ2QsRUFBRSxPQUFPRyxPQUFPO1lBQ2RKLFFBQVFJLEtBQUssQ0FBQyx1Q0FBdUNBO1FBQ3ZEO0lBQ0Y7SUFFQTs7R0FFQyxHQUNERSxZQUlFO1FBQ0EsT0FBTztZQUNMUCxXQUFXLElBQUksQ0FBQ0EsU0FBUztZQUN6QkwsWUFBWUEsb0RBQVVBLENBQUNZLFNBQVM7WUFDaENDLFFBQVEsSUFBSSxDQUFDUixTQUFTLEdBQUdTLFFBQVFELE1BQU0sS0FBS0U7UUFDOUM7SUFDRjtJQUVBOztHQUVDLEdBQ0QsWUFBMEI7UUFDeEIsTUFBTUMsU0FBUyxJQUFJLENBQUNKLFNBQVM7UUFDN0JOLFFBQVFDLEdBQUcsQ0FBQyxnQ0FBZ0M7WUFDMUNGLFdBQVdXLE9BQU9YLFNBQVM7WUFDM0JMLFlBQVlnQixPQUFPaEIsVUFBVSxDQUFDaUIsU0FBUztZQUN2Q0osUUFBUUcsT0FBT0gsTUFBTSxHQUFHLEdBQUdLLEtBQUtDLEtBQUssQ0FBQ0gsT0FBT0gsTUFBTSxHQUFHLElBQUksUUFBUSxDQUFDLEdBQUc7UUFDeEU7SUFDRjs7YUFwRlFSLFlBQVk7O0FBcUZ0QjtBQUVBLDRCQUE0QjtBQUNyQixNQUFNZSxtQkFBbUJuQixpQkFBaUJDLFdBQVcsR0FBRyIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9saWIvYmFja2dyb3VuZC13b3JrZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgam9iTW9uaXRvciB9IGZyb20gJy4vam9iLW1vbml0b3InO1xuXG4vKipcbiAqIEJhY2tncm91bmQgV29ya2VyIFNlcnZpY2VcbiAqIFxuICogTWFuYWdlcyBhbGwgYmFja2dyb3VuZCBzZXJ2aWNlcyBmb3IgdGhlIEluZGV4Tm93IFBybyBhcHBsaWNhdGlvbjpcbiAqIC0gSm9iIG1vbml0b3JpbmcgYW5kIHByb2Nlc3NpbmdcbiAqIC0gQ2xlYW51cCB0YXNrc1xuICogLSBIZWFsdGggY2hlY2tzXG4gKi9cbmV4cG9ydCBjbGFzcyBCYWNrZ3JvdW5kV29ya2VyIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IEJhY2tncm91bmRXb3JrZXI7XG4gIHByaXZhdGUgaXNTdGFydGVkID0gZmFsc2U7XG5cbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IEJhY2tncm91bmRXb3JrZXIge1xuICAgIGlmICghQmFja2dyb3VuZFdvcmtlci5pbnN0YW5jZSkge1xuICAgICAgQmFja2dyb3VuZFdvcmtlci5pbnN0YW5jZSA9IG5ldyBCYWNrZ3JvdW5kV29ya2VyKCk7XG4gICAgfVxuICAgIHJldHVybiBCYWNrZ3JvdW5kV29ya2VyLmluc3RhbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGFsbCBiYWNrZ3JvdW5kIHNlcnZpY2VzXG4gICAqL1xuICBzdGFydCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc1N0YXJ0ZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdCYWNrZ3JvdW5kIHdvcmtlciBpcyBhbHJlYWR5IHN0YXJ0ZWQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygn8J+agCBTdGFydGluZyBJbmRleE5vdyBQcm8gYmFja2dyb3VuZCB3b3JrZXIuLi4nKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gU3RhcnQgam9iIG1vbml0b3JcbiAgICAgIGpvYk1vbml0b3Iuc3RhcnQoKTtcbiAgICAgIFxuICAgICAgdGhpcy5pc1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5sb2coJ+KchSBCYWNrZ3JvdW5kIHdvcmtlciBzdGFydGVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgXG4gICAgICAvLyBMb2cgc3RhdHVzIGV2ZXJ5IDUgbWludXRlc1xuICAgICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICB0aGlzLmxvZ1N0YXR1cygpO1xuICAgICAgfSwgNSAqIDYwICogMTAwMCk7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBzdGFydCBiYWNrZ3JvdW5kIHdvcmtlcjonLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgYWxsIGJhY2tncm91bmQgc2VydmljZXNcbiAgICovXG4gIHN0b3AoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzU3RhcnRlZCkge1xuICAgICAgY29uc29sZS5sb2coJ0JhY2tncm91bmQgd29ya2VyIGlzIG5vdCBydW5uaW5nJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ/Cfm5EgU3RvcHBpbmcgYmFja2dyb3VuZCB3b3JrZXIuLi4nKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gU3RvcCBqb2IgbW9uaXRvclxuICAgICAgam9iTW9uaXRvci5zdG9wKCk7XG4gICAgICBcbiAgICAgIHRoaXMuaXNTdGFydGVkID0gZmFsc2U7XG4gICAgICBjb25zb2xlLmxvZygn4pyFIEJhY2tncm91bmQgd29ya2VyIHN0b3BwZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBzdG9wcGluZyBiYWNrZ3JvdW5kIHdvcmtlcjonLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB3b3JrZXIgc3RhdHVzXG4gICAqL1xuICBnZXRTdGF0dXMoKToge1xuICAgIGlzU3RhcnRlZDogYm9vbGVhbjtcbiAgICBqb2JNb25pdG9yOiBhbnk7XG4gICAgdXB0aW1lPzogbnVtYmVyO1xuICB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNTdGFydGVkOiB0aGlzLmlzU3RhcnRlZCxcbiAgICAgIGpvYk1vbml0b3I6IGpvYk1vbml0b3IuZ2V0U3RhdHVzKCksXG4gICAgICB1cHRpbWU6IHRoaXMuaXNTdGFydGVkID8gcHJvY2Vzcy51cHRpbWUoKSA6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogTG9nIGN1cnJlbnQgc3RhdHVzXG4gICAqL1xuICBwcml2YXRlIGxvZ1N0YXR1cygpOiB2b2lkIHtcbiAgICBjb25zdCBzdGF0dXMgPSB0aGlzLmdldFN0YXR1cygpO1xuICAgIGNvbnNvbGUubG9nKCfwn5OKIEJhY2tncm91bmQgV29ya2VyIFN0YXR1czonLCB7XG4gICAgICBpc1N0YXJ0ZWQ6IHN0YXR1cy5pc1N0YXJ0ZWQsXG4gICAgICBqb2JNb25pdG9yOiBzdGF0dXMuam9iTW9uaXRvci5pc1J1bm5pbmcsXG4gICAgICB1cHRpbWU6IHN0YXR1cy51cHRpbWUgPyBgJHtNYXRoLnJvdW5kKHN0YXR1cy51cHRpbWUgLyA2MCl9IG1pbnV0ZXNgIDogJ04vQSdcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3QgYmFja2dyb3VuZFdvcmtlciA9IEJhY2tncm91bmRXb3JrZXIuZ2V0SW5zdGFuY2UoKTsiXSwibmFtZXMiOlsiam9iTW9uaXRvciIsIkJhY2tncm91bmRXb3JrZXIiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwic3RhcnQiLCJpc1N0YXJ0ZWQiLCJjb25zb2xlIiwibG9nIiwic2V0SW50ZXJ2YWwiLCJsb2dTdGF0dXMiLCJlcnJvciIsInN0b3AiLCJnZXRTdGF0dXMiLCJ1cHRpbWUiLCJwcm9jZXNzIiwidW5kZWZpbmVkIiwic3RhdHVzIiwiaXNSdW5uaW5nIiwiTWF0aCIsInJvdW5kIiwiYmFja2dyb3VuZFdvcmtlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/background-worker.ts\n");

/***/ }),

/***/ "(rsc)/./lib/encryption.ts":
/*!***************************!*\
  !*** ./lib/encryption.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EncryptionService: () => (/* binding */ EncryptionService)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n/**\n * Simple encryption utility for securing sensitive data\n * Uses AES-256-CBC with proper IV handling\n */ class EncryptionService {\n    static{\n        this.ALGORITHM = 'aes-256-cbc';\n    }\n    static{\n        this.IV_LENGTH = 16;\n    }\n    static getEncryptionKey() {\n        const key = process.env.ENCRYPTION_KEY;\n        if (!key) {\n            throw new Error('ENCRYPTION_KEY environment variable is required');\n        }\n        if (key.length !== 32) {\n            throw new Error('ENCRYPTION_KEY must be exactly 32 characters long');\n        }\n        return Buffer.from(key, 'utf8');\n    }\n    /**\n   * Encrypt sensitive data\n   * Format: IV:EncryptedData\n   */ static encrypt(text) {\n        try {\n            const key = this.getEncryptionKey();\n            const iv = crypto__WEBPACK_IMPORTED_MODULE_0___default().randomBytes(this.IV_LENGTH);\n            const cipher = crypto__WEBPACK_IMPORTED_MODULE_0___default().createCipheriv(this.ALGORITHM, key, iv);\n            let encrypted = cipher.update(text, 'utf8', 'hex');\n            encrypted += cipher.final('hex');\n            return iv.toString('hex') + ':' + encrypted;\n        } catch (error) {\n            console.error('Encryption error:', error);\n            throw new Error('Failed to encrypt data');\n        }\n    }\n    /**\n   * Decrypt sensitive data\n   * Expects format: IV:EncryptedData\n   */ static decrypt(encryptedText) {\n        try {\n            const key = this.getEncryptionKey();\n            const parts = encryptedText.split(':');\n            if (parts.length !== 2) {\n                throw new Error('Invalid encrypted data format - expected IV:EncryptedData');\n            }\n            const iv = Buffer.from(parts[0], 'hex');\n            const encryptedData = parts[1];\n            const decipher = crypto__WEBPACK_IMPORTED_MODULE_0___default().createDecipheriv(this.ALGORITHM, key, iv);\n            let decrypted = decipher.update(encryptedData, 'hex', 'utf8');\n            decrypted += decipher.final('utf8');\n            return decrypted;\n        } catch (error) {\n            console.error('Decryption error:', error);\n            throw new Error('Failed to decrypt data');\n        }\n    }\n    /**\n   * Test if encrypted data can be decrypted with current key\n   */ static testDecryption(encryptedText) {\n        try {\n            this.decrypt(encryptedText);\n            return true;\n        } catch (error) {\n            return false;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvZW5jcnlwdGlvbi50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNEI7QUFFNUI7OztDQUdDLEdBQ00sTUFBTUM7O2FBQ2FDLFlBQVk7OzthQUNaQyxZQUFZOztJQUVwQyxPQUFlQyxtQkFBMkI7UUFDeEMsTUFBTUMsTUFBTUMsUUFBUUMsR0FBRyxDQUFDQyxjQUFjO1FBQ3RDLElBQUksQ0FBQ0gsS0FBSztZQUNSLE1BQU0sSUFBSUksTUFBTTtRQUNsQjtRQUNBLElBQUlKLElBQUlLLE1BQU0sS0FBSyxJQUFJO1lBQ3JCLE1BQU0sSUFBSUQsTUFBTTtRQUNsQjtRQUNBLE9BQU9FLE9BQU9DLElBQUksQ0FBQ1AsS0FBSztJQUMxQjtJQUVBOzs7R0FHQyxHQUNELE9BQU9RLFFBQVFDLElBQVksRUFBVTtRQUNuQyxJQUFJO1lBQ0YsTUFBTVQsTUFBTSxJQUFJLENBQUNELGdCQUFnQjtZQUNqQyxNQUFNVyxLQUFLZix5REFBa0IsQ0FBQyxJQUFJLENBQUNHLFNBQVM7WUFDNUMsTUFBTWMsU0FBU2pCLDREQUFxQixDQUFDLElBQUksQ0FBQ0UsU0FBUyxFQUFFRyxLQUFLVTtZQUUxRCxJQUFJSSxZQUFZRixPQUFPRyxNQUFNLENBQUNOLE1BQU0sUUFBUTtZQUM1Q0ssYUFBYUYsT0FBT0ksS0FBSyxDQUFDO1lBRTFCLE9BQU9OLEdBQUdPLFFBQVEsQ0FBQyxTQUFTLE1BQU1IO1FBQ3BDLEVBQUUsT0FBT0ksT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMscUJBQXFCQTtZQUNuQyxNQUFNLElBQUlkLE1BQU07UUFDbEI7SUFDRjtJQUVBOzs7R0FHQyxHQUNELE9BQU9nQixRQUFRQyxhQUFxQixFQUFVO1FBQzVDLElBQUk7WUFDRixNQUFNckIsTUFBTSxJQUFJLENBQUNELGdCQUFnQjtZQUNqQyxNQUFNdUIsUUFBUUQsY0FBY0UsS0FBSyxDQUFDO1lBRWxDLElBQUlELE1BQU1qQixNQUFNLEtBQUssR0FBRztnQkFDdEIsTUFBTSxJQUFJRCxNQUFNO1lBQ2xCO1lBRUEsTUFBTU0sS0FBS0osT0FBT0MsSUFBSSxDQUFDZSxLQUFLLENBQUMsRUFBRSxFQUFFO1lBQ2pDLE1BQU1FLGdCQUFnQkYsS0FBSyxDQUFDLEVBQUU7WUFFOUIsTUFBTUcsV0FBVzlCLDhEQUF1QixDQUFDLElBQUksQ0FBQ0UsU0FBUyxFQUFFRyxLQUFLVTtZQUM5RCxJQUFJaUIsWUFBWUYsU0FBU1YsTUFBTSxDQUFDUyxlQUFlLE9BQU87WUFDdERHLGFBQWFGLFNBQVNULEtBQUssQ0FBQztZQUU1QixPQUFPVztRQUNULEVBQUUsT0FBT1QsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMscUJBQXFCQTtZQUNuQyxNQUFNLElBQUlkLE1BQU07UUFDbEI7SUFDRjtJQUVBOztHQUVDLEdBQ0QsT0FBT3dCLGVBQWVQLGFBQXFCLEVBQVc7UUFDcEQsSUFBSTtZQUNGLElBQUksQ0FBQ0QsT0FBTyxDQUFDQztZQUNiLE9BQU87UUFDVCxFQUFFLE9BQU9ILE9BQU87WUFDZCxPQUFPO1FBQ1Q7SUFDRjtBQUNGIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL2xpYi9lbmNyeXB0aW9uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcblxuLyoqXG4gKiBTaW1wbGUgZW5jcnlwdGlvbiB1dGlsaXR5IGZvciBzZWN1cmluZyBzZW5zaXRpdmUgZGF0YVxuICogVXNlcyBBRVMtMjU2LUNCQyB3aXRoIHByb3BlciBJViBoYW5kbGluZ1xuICovXG5leHBvcnQgY2xhc3MgRW5jcnlwdGlvblNlcnZpY2Uge1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBBTEdPUklUSE0gPSAnYWVzLTI1Ni1jYmMnO1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBJVl9MRU5HVEggPSAxNjtcbiAgXG4gIHByaXZhdGUgc3RhdGljIGdldEVuY3J5cHRpb25LZXkoKTogQnVmZmVyIHtcbiAgICBjb25zdCBrZXkgPSBwcm9jZXNzLmVudi5FTkNSWVBUSU9OX0tFWTtcbiAgICBpZiAoIWtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFTkNSWVBUSU9OX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAoa2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRU5DUllQVElPTl9LRVkgbXVzdCBiZSBleGFjdGx5IDMyIGNoYXJhY3RlcnMgbG9uZycpO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oa2V5LCAndXRmOCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuY3J5cHQgc2Vuc2l0aXZlIGRhdGFcbiAgICogRm9ybWF0OiBJVjpFbmNyeXB0ZWREYXRhXG4gICAqL1xuICBzdGF0aWMgZW5jcnlwdCh0ZXh0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBrZXkgPSB0aGlzLmdldEVuY3J5cHRpb25LZXkoKTtcbiAgICAgIGNvbnN0IGl2ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKHRoaXMuSVZfTEVOR1RIKTtcbiAgICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdih0aGlzLkFMR09SSVRITSwga2V5LCBpdik7XG4gICAgICBcbiAgICAgIGxldCBlbmNyeXB0ZWQgPSBjaXBoZXIudXBkYXRlKHRleHQsICd1dGY4JywgJ2hleCcpO1xuICAgICAgZW5jcnlwdGVkICs9IGNpcGhlci5maW5hbCgnaGV4Jyk7XG4gICAgICBcbiAgICAgIHJldHVybiBpdi50b1N0cmluZygnaGV4JykgKyAnOicgKyBlbmNyeXB0ZWQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0VuY3J5cHRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZW5jcnlwdCBkYXRhJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlY3J5cHQgc2Vuc2l0aXZlIGRhdGFcbiAgICogRXhwZWN0cyBmb3JtYXQ6IElWOkVuY3J5cHRlZERhdGFcbiAgICovXG4gIHN0YXRpYyBkZWNyeXB0KGVuY3J5cHRlZFRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0RW5jcnlwdGlvbktleSgpO1xuICAgICAgY29uc3QgcGFydHMgPSBlbmNyeXB0ZWRUZXh0LnNwbGl0KCc6Jyk7XG4gICAgICBcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVuY3J5cHRlZCBkYXRhIGZvcm1hdCAtIGV4cGVjdGVkIElWOkVuY3J5cHRlZERhdGEnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgaXYgPSBCdWZmZXIuZnJvbShwYXJ0c1swXSwgJ2hleCcpO1xuICAgICAgY29uc3QgZW5jcnlwdGVkRGF0YSA9IHBhcnRzWzFdO1xuICAgICAgXG4gICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KHRoaXMuQUxHT1JJVEhNLCBrZXksIGl2KTtcbiAgICAgIGxldCBkZWNyeXB0ZWQgPSBkZWNpcGhlci51cGRhdGUoZW5jcnlwdGVkRGF0YSwgJ2hleCcsICd1dGY4Jyk7XG4gICAgICBkZWNyeXB0ZWQgKz0gZGVjaXBoZXIuZmluYWwoJ3V0ZjgnKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGRlY3J5cHRlZDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRGVjcnlwdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWNyeXB0IGRhdGEnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGVzdCBpZiBlbmNyeXB0ZWQgZGF0YSBjYW4gYmUgZGVjcnlwdGVkIHdpdGggY3VycmVudCBrZXlcbiAgICovXG4gIHN0YXRpYyB0ZXN0RGVjcnlwdGlvbihlbmNyeXB0ZWRUZXh0OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5kZWNyeXB0KGVuY3J5cHRlZFRleHQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0iXSwibmFtZXMiOlsiY3J5cHRvIiwiRW5jcnlwdGlvblNlcnZpY2UiLCJBTEdPUklUSE0iLCJJVl9MRU5HVEgiLCJnZXRFbmNyeXB0aW9uS2V5Iiwia2V5IiwicHJvY2VzcyIsImVudiIsIkVOQ1JZUFRJT05fS0VZIiwiRXJyb3IiLCJsZW5ndGgiLCJCdWZmZXIiLCJmcm9tIiwiZW5jcnlwdCIsInRleHQiLCJpdiIsInJhbmRvbUJ5dGVzIiwiY2lwaGVyIiwiY3JlYXRlQ2lwaGVyaXYiLCJlbmNyeXB0ZWQiLCJ1cGRhdGUiLCJmaW5hbCIsInRvU3RyaW5nIiwiZXJyb3IiLCJjb25zb2xlIiwiZGVjcnlwdCIsImVuY3J5cHRlZFRleHQiLCJwYXJ0cyIsInNwbGl0IiwiZW5jcnlwdGVkRGF0YSIsImRlY2lwaGVyIiwiY3JlYXRlRGVjaXBoZXJpdiIsImRlY3J5cHRlZCIsInRlc3REZWNyeXB0aW9uIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/encryption.ts\n");

/***/ }),

/***/ "(rsc)/./lib/google-auth-service.ts":
/*!************************************!*\
  !*** ./lib/google-auth-service.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GoogleAuthService: () => (/* binding */ GoogleAuthService)\n/* harmony export */ });\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase */ \"(rsc)/./lib/supabase.ts\");\n/* harmony import */ var _encryption__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./encryption */ \"(rsc)/./lib/encryption.ts\");\n/* harmony import */ var google_auth_library__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! google-auth-library */ \"(rsc)/./node_modules/google-auth-library/build/src/index.js\");\n\n\n\n/**\n * Google Authentication Service\n * \n * Handles the complete Google API authentication workflow:\n * 1. Decrypt service account credentials from database\n * 2. Generate JWT tokens using service account private key\n * 3. Exchange JWT for access tokens with Google's token endpoint\n * 4. Cache encrypted access tokens in database with expiration\n * 5. Manage token refresh and quota tracking\n */ class GoogleAuthService {\n    static{\n        this.INDEXING_SCOPE = 'https://www.googleapis.com/auth/indexing';\n    }\n    static{\n        this.TOKEN_EXPIRY_BUFFER = 5 * 60 * 1000; // 5 minutes buffer\n    }\n    static getInstance() {\n        if (!GoogleAuthService.instance) {\n            GoogleAuthService.instance = new GoogleAuthService();\n        }\n        return GoogleAuthService.instance;\n    }\n    /**\n   * Get a valid access token for Google API calls\n   * First checks cached token in database, then generates new one if needed\n   */ async getAccessToken(serviceAccountId) {\n        try {\n            console.log(`ðŸ”‘ Getting access token for service account: ${serviceAccountId}`);\n            // Get service account from database\n            const { data: serviceAccount, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_google_service_accounts').select('*').eq('id', serviceAccountId).single();\n            if (error || !serviceAccount) {\n                console.error('Service account not found:', error);\n                return null;\n            }\n            // Check if we have a valid cached token\n            const cachedToken = await this.getCachedAccessToken(serviceAccount);\n            if (cachedToken) {\n                console.log('âœ… Using cached access token');\n                return cachedToken;\n            }\n            // Generate new access token\n            console.log('ðŸ”„ Generating new access token');\n            const newToken = await this.generateNewAccessToken(serviceAccount);\n            if (newToken) {\n                // Cache the new token in database\n                await this.cacheAccessToken(serviceAccountId, newToken);\n                console.log('âœ… New access token generated and cached');\n                return newToken.access_token;\n            }\n            return null;\n        } catch (error) {\n            console.error('Error getting access token:', error);\n            return null;\n        }\n    }\n    /**\n   * Get available service account for a user\n   */ async getAvailableServiceAccount(userId) {\n        try {\n            const { data: accounts, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_google_service_accounts').select('*').eq('user_id', userId).eq('is_active', true).limit(1);\n            if (error || !accounts?.length) {\n                console.log('No active service accounts found for user:', userId);\n                return null;\n            }\n            return accounts[0];\n        } catch (error) {\n            console.error('Error getting service account:', error);\n            return null;\n        }\n    }\n    /**\n   * Check if we have a valid cached access token\n   */ async getCachedAccessToken(serviceAccount) {\n        try {\n            if (!serviceAccount.encrypted_access_token || !serviceAccount.access_token_expires_at) {\n                return null;\n            }\n            const expiresAt = new Date(serviceAccount.access_token_expires_at).getTime();\n            const now = Date.now();\n            // Check if token is still valid (with buffer)\n            if (expiresAt <= now + GoogleAuthService.TOKEN_EXPIRY_BUFFER) {\n                console.log('Cached token expired or expiring soon');\n                return null;\n            }\n            // Decrypt and return cached token\n            const accessToken = _encryption__WEBPACK_IMPORTED_MODULE_1__.EncryptionService.decrypt(serviceAccount.encrypted_access_token);\n            return accessToken;\n        } catch (error) {\n            console.error('Error checking cached token:', error);\n            return null;\n        }\n    }\n    /**\n   * Generate new access token using service account credentials\n   */ async generateNewAccessToken(serviceAccount) {\n        try {\n            // Decrypt service account credentials\n            const credentialsJson = _encryption__WEBPACK_IMPORTED_MODULE_1__.EncryptionService.decrypt(serviceAccount.encrypted_credentials);\n            const credentials = JSON.parse(credentialsJson);\n            console.log('ðŸ” Creating JWT with service account credentials');\n            // Create JWT client\n            const jwtClient = new google_auth_library__WEBPACK_IMPORTED_MODULE_2__.JWT({\n                email: credentials.client_email,\n                key: credentials.private_key,\n                scopes: [\n                    GoogleAuthService.INDEXING_SCOPE\n                ]\n            });\n            // Get access token\n            const tokenResponse = await jwtClient.authorize();\n            if (!tokenResponse.access_token) {\n                throw new Error('No access token received from Google');\n            }\n            console.log('âœ… Successfully obtained access token from Google');\n            return {\n                access_token: tokenResponse.access_token,\n                expires_in: 3600 // Google tokens typically expire in 1 hour\n            };\n        } catch (error) {\n            console.error('Error generating access token:', error);\n            return null;\n        }\n    }\n    /**\n   * Cache encrypted access token in database\n   */ async cacheAccessToken(serviceAccountId, tokenData) {\n        try {\n            // Encrypt access token\n            const encryptedToken = _encryption__WEBPACK_IMPORTED_MODULE_1__.EncryptionService.encrypt(tokenData.access_token);\n            // Calculate expiration time (with some buffer)\n            const expiresAt = new Date(Date.now() + tokenData.expires_in * 1000 - GoogleAuthService.TOKEN_EXPIRY_BUFFER);\n            // Update service account with cached token\n            const { error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_google_service_accounts').update({\n                encrypted_access_token: encryptedToken,\n                access_token_expires_at: expiresAt.toISOString(),\n                updated_at: new Date().toISOString()\n            }).eq('id', serviceAccountId);\n            if (error) {\n                console.error('Error caching access token:', error);\n            } else {\n                console.log('âœ… Access token cached in database');\n            }\n        } catch (error) {\n            console.error('Error caching access token:', error);\n        }\n    }\n    /**\n   * Validate service account credentials format\n   */ static validateServiceAccountCredentials(credentialsJson) {\n        try {\n            const credentials = JSON.parse(credentialsJson);\n            const requiredFields = [\n                'type',\n                'project_id',\n                'private_key_id',\n                'private_key',\n                'client_email',\n                'client_id',\n                'auth_uri',\n                'token_uri'\n            ];\n            return requiredFields.every((field)=>credentials[field]);\n        } catch (error) {\n            return false;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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R0FBRyxPQUFRakQsa0JBQWtCRSxtQkFBbUI7WUFFN0csMkNBQTJDO1lBQzNDLE1BQU0sRUFBRVMsS0FBSyxFQUFFLEdBQUcsTUFBTWQsb0RBQWFBLENBQ2xDZSxJQUFJLENBQUMsZ0NBQ0x5QyxNQUFNLENBQUM7Z0JBQ04xQix3QkFBd0J3QjtnQkFDeEJ2Qix5QkFBeUJDLFVBQVV5QixXQUFXO2dCQUM5Q0MsWUFBWSxJQUFJekIsT0FBT3dCLFdBQVc7WUFDcEMsR0FDQ3hDLEVBQUUsQ0FBQyxNQUFNUjtZQUVaLElBQUlLLE9BQU87Z0JBQ1RKLFFBQVFJLEtBQUssQ0FBQywrQkFBK0JBO1lBQy9DLE9BQU87Z0JBQ0xKLFFBQVFDLEdBQUcsQ0FBQztZQUNkO1FBQ0YsRUFBRSxPQUFPRyxPQUFPO1lBQ2RKLFFBQVFJLEtBQUssQ0FBQywrQkFBK0JBO1FBQy9DO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELE9BQU82QyxrQ0FBa0NyQixlQUF1QixFQUFXO1FBQ3pFLElBQUk7WUFDRixNQUFNRSxjQUFjQyxLQUFLQyxLQUFLLENBQUNKO1lBQy9CLE1BQU1zQixpQkFBaUI7Z0JBQ3JCO2dCQUFRO2dCQUFjO2dCQUFrQjtnQkFDeEM7Z0JBQWdCO2dCQUFhO2dCQUFZO2FBQzFDO1lBRUQsT0FBT0EsZUFBZUMsS0FBSyxDQUFDQyxDQUFBQSxRQUFTdEIsV0FBVyxDQUFDc0IsTUFBTTtRQUN6RCxFQUFFLE9BQU9oRCxPQUFPO1lBQ2QsT0FBTztRQUNUO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9saWIvZ29vZ2xlLWF1dGgtc2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdXBhYmFzZUFkbWluIH0gZnJvbSAnLi9zdXBhYmFzZSc7XG5pbXBvcnQgeyBFbmNyeXB0aW9uU2VydmljZSB9IGZyb20gJy4vZW5jcnlwdGlvbic7XG5pbXBvcnQgeyBKV1QgfSBmcm9tICdnb29nbGUtYXV0aC1saWJyYXJ5JztcblxuZXhwb3J0IGludGVyZmFjZSBTZXJ2aWNlQWNjb3VudCB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgZW1haWw6IHN0cmluZztcbiAgZW5jcnlwdGVkX2NyZWRlbnRpYWxzOiBzdHJpbmc7XG4gIGRhaWx5X3F1b3RhX2xpbWl0OiBudW1iZXI7XG4gIG1pbnV0ZV9xdW90YV9saW1pdDogbnVtYmVyO1xuICBlbmNyeXB0ZWRfYWNjZXNzX3Rva2VuPzogc3RyaW5nO1xuICBhY2Nlc3NfdG9rZW5fZXhwaXJlc19hdD86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFNlcnZpY2VBY2NvdW50Q3JlZGVudGlhbHMge1xuICB0eXBlOiBzdHJpbmc7XG4gIHByb2plY3RfaWQ6IHN0cmluZztcbiAgcHJpdmF0ZV9rZXlfaWQ6IHN0cmluZztcbiAgcHJpdmF0ZV9rZXk6IHN0cmluZztcbiAgY2xpZW50X2VtYWlsOiBzdHJpbmc7XG4gIGNsaWVudF9pZDogc3RyaW5nO1xuICBhdXRoX3VyaTogc3RyaW5nO1xuICB0b2tlbl91cmk6IHN0cmluZztcbiAgYXV0aF9wcm92aWRlcl94NTA5X2NlcnRfdXJsOiBzdHJpbmc7XG4gIGNsaWVudF94NTA5X2NlcnRfdXJsOiBzdHJpbmc7XG59XG5cbi8qKlxuICogR29vZ2xlIEF1dGhlbnRpY2F0aW9uIFNlcnZpY2VcbiAqIFxuICogSGFuZGxlcyB0aGUgY29tcGxldGUgR29vZ2xlIEFQSSBhdXRoZW50aWNhdGlvbiB3b3JrZmxvdzpcbiAqIDEuIERlY3J5cHQgc2VydmljZSBhY2NvdW50IGNyZWRlbnRpYWxzIGZyb20gZGF0YWJhc2VcbiAqIDIuIEdlbmVyYXRlIEpXVCB0b2tlbnMgdXNpbmcgc2VydmljZSBhY2NvdW50IHByaXZhdGUga2V5XG4gKiAzLiBFeGNoYW5nZSBKV1QgZm9yIGFjY2VzcyB0b2tlbnMgd2l0aCBHb29nbGUncyB0b2tlbiBlbmRwb2ludFxuICogNC4gQ2FjaGUgZW5jcnlwdGVkIGFjY2VzcyB0b2tlbnMgaW4gZGF0YWJhc2Ugd2l0aCBleHBpcmF0aW9uXG4gKiA1LiBNYW5hZ2UgdG9rZW4gcmVmcmVzaCBhbmQgcXVvdGEgdHJhY2tpbmdcbiAqL1xuZXhwb3J0IGNsYXNzIEdvb2dsZUF1dGhTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IEdvb2dsZUF1dGhTZXJ2aWNlO1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBJTkRFWElOR19TQ09QRSA9ICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2luZGV4aW5nJztcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgVE9LRU5fRVhQSVJZX0JVRkZFUiA9IDUgKiA2MCAqIDEwMDA7IC8vIDUgbWludXRlcyBidWZmZXJcblxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogR29vZ2xlQXV0aFNlcnZpY2Uge1xuICAgIGlmICghR29vZ2xlQXV0aFNlcnZpY2UuaW5zdGFuY2UpIHtcbiAgICAgIEdvb2dsZUF1dGhTZXJ2aWNlLmluc3RhbmNlID0gbmV3IEdvb2dsZUF1dGhTZXJ2aWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBHb29nbGVBdXRoU2VydmljZS5pbnN0YW5jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB2YWxpZCBhY2Nlc3MgdG9rZW4gZm9yIEdvb2dsZSBBUEkgY2FsbHNcbiAgICogRmlyc3QgY2hlY2tzIGNhY2hlZCB0b2tlbiBpbiBkYXRhYmFzZSwgdGhlbiBnZW5lcmF0ZXMgbmV3IG9uZSBpZiBuZWVkZWRcbiAgICovXG4gIGFzeW5jIGdldEFjY2Vzc1Rva2VuKHNlcnZpY2VBY2NvdW50SWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+UkSBHZXR0aW5nIGFjY2VzcyB0b2tlbiBmb3Igc2VydmljZSBhY2NvdW50OiAke3NlcnZpY2VBY2NvdW50SWR9YCk7XG4gICAgICBcbiAgICAgIC8vIEdldCBzZXJ2aWNlIGFjY291bnQgZnJvbSBkYXRhYmFzZVxuICAgICAgY29uc3QgeyBkYXRhOiBzZXJ2aWNlQWNjb3VudCwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlQWRtaW5cbiAgICAgICAgLmZyb20oJ2luZGJfZ29vZ2xlX3NlcnZpY2VfYWNjb3VudHMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCdpZCcsIHNlcnZpY2VBY2NvdW50SWQpXG4gICAgICAgIC5zaW5nbGUoKTtcblxuICAgICAgaWYgKGVycm9yIHx8ICFzZXJ2aWNlQWNjb3VudCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTZXJ2aWNlIGFjY291bnQgbm90IGZvdW5kOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgYSB2YWxpZCBjYWNoZWQgdG9rZW5cbiAgICAgIGNvbnN0IGNhY2hlZFRva2VuID0gYXdhaXQgdGhpcy5nZXRDYWNoZWRBY2Nlc3NUb2tlbihzZXJ2aWNlQWNjb3VudCk7XG4gICAgICBpZiAoY2FjaGVkVG9rZW4pIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBVc2luZyBjYWNoZWQgYWNjZXNzIHRva2VuJyk7XG4gICAgICAgIHJldHVybiBjYWNoZWRUb2tlbjtcbiAgICAgIH1cblxuICAgICAgLy8gR2VuZXJhdGUgbmV3IGFjY2VzcyB0b2tlblxuICAgICAgY29uc29sZS5sb2coJ/CflIQgR2VuZXJhdGluZyBuZXcgYWNjZXNzIHRva2VuJyk7XG4gICAgICBjb25zdCBuZXdUb2tlbiA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVOZXdBY2Nlc3NUb2tlbihzZXJ2aWNlQWNjb3VudCk7XG4gICAgICBcbiAgICAgIGlmIChuZXdUb2tlbikge1xuICAgICAgICAvLyBDYWNoZSB0aGUgbmV3IHRva2VuIGluIGRhdGFiYXNlXG4gICAgICAgIGF3YWl0IHRoaXMuY2FjaGVBY2Nlc3NUb2tlbihzZXJ2aWNlQWNjb3VudElkLCBuZXdUb2tlbik7XG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgTmV3IGFjY2VzcyB0b2tlbiBnZW5lcmF0ZWQgYW5kIGNhY2hlZCcpO1xuICAgICAgICByZXR1cm4gbmV3VG9rZW4uYWNjZXNzX3Rva2VuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBhY2Nlc3MgdG9rZW46JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhdmFpbGFibGUgc2VydmljZSBhY2NvdW50IGZvciBhIHVzZXJcbiAgICovXG4gIGFzeW5jIGdldEF2YWlsYWJsZVNlcnZpY2VBY2NvdW50KHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxTZXJ2aWNlQWNjb3VudCB8IG51bGw+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhOiBhY2NvdW50cywgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlQWRtaW5cbiAgICAgICAgLmZyb20oJ2luZGJfZ29vZ2xlX3NlcnZpY2VfYWNjb3VudHMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuICAgICAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpXG4gICAgICAgIC5saW1pdCgxKTtcblxuICAgICAgaWYgKGVycm9yIHx8ICFhY2NvdW50cz8ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdObyBhY3RpdmUgc2VydmljZSBhY2NvdW50cyBmb3VuZCBmb3IgdXNlcjonLCB1c2VySWQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjY291bnRzWzBdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHNlcnZpY2UgYWNjb3VudDonLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgd2UgaGF2ZSBhIHZhbGlkIGNhY2hlZCBhY2Nlc3MgdG9rZW5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZ2V0Q2FjaGVkQWNjZXNzVG9rZW4oc2VydmljZUFjY291bnQ6IFNlcnZpY2VBY2NvdW50KTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghc2VydmljZUFjY291bnQuZW5jcnlwdGVkX2FjY2Vzc190b2tlbiB8fCAhc2VydmljZUFjY291bnQuYWNjZXNzX3Rva2VuX2V4cGlyZXNfYXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV4cGlyZXNBdCA9IG5ldyBEYXRlKHNlcnZpY2VBY2NvdW50LmFjY2Vzc190b2tlbl9leHBpcmVzX2F0KS5nZXRUaW1lKCk7XG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0b2tlbiBpcyBzdGlsbCB2YWxpZCAod2l0aCBidWZmZXIpXG4gICAgICBpZiAoZXhwaXJlc0F0IDw9IG5vdyArIEdvb2dsZUF1dGhTZXJ2aWNlLlRPS0VOX0VYUElSWV9CVUZGRVIpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0NhY2hlZCB0b2tlbiBleHBpcmVkIG9yIGV4cGlyaW5nIHNvb24nKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIERlY3J5cHQgYW5kIHJldHVybiBjYWNoZWQgdG9rZW5cbiAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gRW5jcnlwdGlvblNlcnZpY2UuZGVjcnlwdChzZXJ2aWNlQWNjb3VudC5lbmNyeXB0ZWRfYWNjZXNzX3Rva2VuKTtcbiAgICAgIHJldHVybiBhY2Nlc3NUb2tlbjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgY2FjaGVkIHRva2VuOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBuZXcgYWNjZXNzIHRva2VuIHVzaW5nIHNlcnZpY2UgYWNjb3VudCBjcmVkZW50aWFsc1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBnZW5lcmF0ZU5ld0FjY2Vzc1Rva2VuKHNlcnZpY2VBY2NvdW50OiBTZXJ2aWNlQWNjb3VudCk6IFByb21pc2U8eyBhY2Nlc3NfdG9rZW46IHN0cmluZzsgZXhwaXJlc19pbjogbnVtYmVyIH0gfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIERlY3J5cHQgc2VydmljZSBhY2NvdW50IGNyZWRlbnRpYWxzXG4gICAgICBjb25zdCBjcmVkZW50aWFsc0pzb24gPSBFbmNyeXB0aW9uU2VydmljZS5kZWNyeXB0KHNlcnZpY2VBY2NvdW50LmVuY3J5cHRlZF9jcmVkZW50aWFscyk7XG4gICAgICBjb25zdCBjcmVkZW50aWFsczogU2VydmljZUFjY291bnRDcmVkZW50aWFscyA9IEpTT04ucGFyc2UoY3JlZGVudGlhbHNKc29uKTtcblxuICAgICAgY29uc29sZS5sb2coJ/CflJAgQ3JlYXRpbmcgSldUIHdpdGggc2VydmljZSBhY2NvdW50IGNyZWRlbnRpYWxzJyk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBKV1QgY2xpZW50XG4gICAgICBjb25zdCBqd3RDbGllbnQgPSBuZXcgSldUKHtcbiAgICAgICAgZW1haWw6IGNyZWRlbnRpYWxzLmNsaWVudF9lbWFpbCxcbiAgICAgICAga2V5OiBjcmVkZW50aWFscy5wcml2YXRlX2tleSxcbiAgICAgICAgc2NvcGVzOiBbR29vZ2xlQXV0aFNlcnZpY2UuSU5ERVhJTkdfU0NPUEVdXG4gICAgICB9KTtcblxuICAgICAgLy8gR2V0IGFjY2VzcyB0b2tlblxuICAgICAgY29uc3QgdG9rZW5SZXNwb25zZSA9IGF3YWl0IGp3dENsaWVudC5hdXRob3JpemUoKTtcbiAgICAgIFxuICAgICAgaWYgKCF0b2tlblJlc3BvbnNlLmFjY2Vzc190b2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY2VzcyB0b2tlbiByZWNlaXZlZCBmcm9tIEdvb2dsZScpO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFN1Y2Nlc3NmdWxseSBvYnRhaW5lZCBhY2Nlc3MgdG9rZW4gZnJvbSBHb29nbGUnKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWNjZXNzX3Rva2VuOiB0b2tlblJlc3BvbnNlLmFjY2Vzc190b2tlbixcbiAgICAgICAgZXhwaXJlc19pbjogMzYwMCAvLyBHb29nbGUgdG9rZW5zIHR5cGljYWxseSBleHBpcmUgaW4gMSBob3VyXG4gICAgICB9O1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdlbmVyYXRpbmcgYWNjZXNzIHRva2VuOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWNoZSBlbmNyeXB0ZWQgYWNjZXNzIHRva2VuIGluIGRhdGFiYXNlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGNhY2hlQWNjZXNzVG9rZW4oc2VydmljZUFjY291bnRJZDogc3RyaW5nLCB0b2tlbkRhdGE6IHsgYWNjZXNzX3Rva2VuOiBzdHJpbmc7IGV4cGlyZXNfaW46IG51bWJlciB9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEVuY3J5cHQgYWNjZXNzIHRva2VuXG4gICAgICBjb25zdCBlbmNyeXB0ZWRUb2tlbiA9IEVuY3J5cHRpb25TZXJ2aWNlLmVuY3J5cHQodG9rZW5EYXRhLmFjY2Vzc190b2tlbik7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBleHBpcmF0aW9uIHRpbWUgKHdpdGggc29tZSBidWZmZXIpXG4gICAgICBjb25zdCBleHBpcmVzQXQgPSBuZXcgRGF0ZShEYXRlLm5vdygpICsgKHRva2VuRGF0YS5leHBpcmVzX2luICogMTAwMCkgLSBHb29nbGVBdXRoU2VydmljZS5UT0tFTl9FWFBJUllfQlVGRkVSKTtcblxuICAgICAgLy8gVXBkYXRlIHNlcnZpY2UgYWNjb3VudCB3aXRoIGNhY2hlZCB0b2tlblxuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VBZG1pblxuICAgICAgICAuZnJvbSgnaW5kYl9nb29nbGVfc2VydmljZV9hY2NvdW50cycpXG4gICAgICAgIC51cGRhdGUoe1xuICAgICAgICAgIGVuY3J5cHRlZF9hY2Nlc3NfdG9rZW46IGVuY3J5cHRlZFRva2VuLFxuICAgICAgICAgIGFjY2Vzc190b2tlbl9leHBpcmVzX2F0OiBleHBpcmVzQXQudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfSlcbiAgICAgICAgLmVxKCdpZCcsIHNlcnZpY2VBY2NvdW50SWQpO1xuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2FjaGluZyBhY2Nlc3MgdG9rZW46JywgZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBBY2Nlc3MgdG9rZW4gY2FjaGVkIGluIGRhdGFiYXNlJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNhY2hpbmcgYWNjZXNzIHRva2VuOicsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgc2VydmljZSBhY2NvdW50IGNyZWRlbnRpYWxzIGZvcm1hdFxuICAgKi9cbiAgc3RhdGljIHZhbGlkYXRlU2VydmljZUFjY291bnRDcmVkZW50aWFscyhjcmVkZW50aWFsc0pzb246IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjcmVkZW50aWFscyA9IEpTT04ucGFyc2UoY3JlZGVudGlhbHNKc29uKTtcbiAgICAgIGNvbnN0IHJlcXVpcmVkRmllbGRzID0gW1xuICAgICAgICAndHlwZScsICdwcm9qZWN0X2lkJywgJ3ByaXZhdGVfa2V5X2lkJywgJ3ByaXZhdGVfa2V5JyxcbiAgICAgICAgJ2NsaWVudF9lbWFpbCcsICdjbGllbnRfaWQnLCAnYXV0aF91cmknLCAndG9rZW5fdXJpJ1xuICAgICAgXTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlcXVpcmVkRmllbGRzLmV2ZXJ5KGZpZWxkID0+IGNyZWRlbnRpYWxzW2ZpZWxkXSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0iXSwibmFtZXMiOlsic3VwYWJhc2VBZG1pbiIsIkVuY3J5cHRpb25TZXJ2aWNlIiwiSldUIiwiR29vZ2xlQXV0aFNlcnZpY2UiLCJJTkRFWElOR19TQ09QRSIsIlRPS0VOX0VYUElSWV9CVUZGRVIiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwiZ2V0QWNjZXNzVG9rZW4iLCJzZXJ2aWNlQWNjb3VudElkIiwiY29uc29sZSIsImxvZyIsImRhdGEiLCJzZXJ2aWNlQWNjb3VudCIsImVycm9yIiwiZnJvbSIsInNlbGVjdCIsImVxIiwic2luZ2xlIiwiY2FjaGVkVG9rZW4iLCJnZXRDYWNoZWRBY2Nlc3NUb2tlbiIsIm5ld1Rva2VuIiwiZ2VuZXJhdGVOZXdBY2Nlc3NUb2tlbiIsImNhY2hlQWNjZXNzVG9rZW4iLCJhY2Nlc3NfdG9rZW4iLCJnZXRBdmFpbGFibGVTZXJ2aWNlQWNjb3VudCIsInVzZXJJZCIsImFjY291bnRzIiwibGltaXQiLCJsZW5ndGgiLCJlbmNyeXB0ZWRfYWNjZXNzX3Rva2VuIiwiYWNjZXNzX3Rva2VuX2V4cGlyZXNfYXQiLCJleHBpcmVzQXQiLCJEYXRlIiwiZ2V0VGltZSIsIm5vdyIsImFjY2Vzc1Rva2VuIiwiZGVjcnlwdCIsImNyZWRlbnRpYWxzSnNvbiIsImVuY3J5cHRlZF9jcmVkZW50aWFscyIsImNyZWRlbnRpYWxzIiwiSlNPTiIsInBhcnNlIiwiand0Q2xpZW50IiwiZW1haWwiLCJjbGllbnRfZW1haWwiLCJrZXkiLCJwcml2YXRlX2tleSIsInNjb3BlcyIsInRva2VuUmVzcG9uc2UiLCJhdXRob3JpemUiLCJFcnJvciIsImV4cGlyZXNfaW4iLCJ0b2tlbkRhdGEiLCJlbmNyeXB0ZWRUb2tlbiIsImVuY3J5cHQiLCJ1cGRhdGUiLCJ0b0lTT1N0cmluZyIsInVwZGF0ZWRfYXQiLCJ2YWxpZGF0ZVNlcnZpY2VBY2NvdW50Q3JlZGVudGlhbHMiLCJyZXF1aXJlZEZpZWxkcyIsImV2ZXJ5IiwiZmllbGQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/google-auth-service.ts\n");

/***/ }),

/***/ "(rsc)/./lib/google-indexing-processor.ts":
/*!******************************************!*\
  !*** ./lib/google-indexing-processor.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GoogleIndexingProcessor: () => (/* binding */ GoogleIndexingProcessor)\n/* harmony export */ });\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase */ \"(rsc)/./lib/supabase.ts\");\n/* harmony import */ var _google_auth_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./google-auth-service */ \"(rsc)/./lib/google-auth-service.ts\");\n\n\n/**\n * Google Indexing Processor\n * \n * Professional-grade URL indexing system that integrates with Google's Indexing API\n * to automatically submit URLs for indexing with proper error handling, retry logic,\n * and quota management across multiple service accounts.\n */ class GoogleIndexingProcessor {\n    constructor(){\n        this.processingJobs = new Set();\n        this.googleAuth = _google_auth_service__WEBPACK_IMPORTED_MODULE_1__.GoogleAuthService.getInstance();\n    }\n    static getInstance() {\n        if (!GoogleIndexingProcessor.instance) {\n            GoogleIndexingProcessor.instance = new GoogleIndexingProcessor();\n        }\n        return GoogleIndexingProcessor.instance;\n    }\n    /**\n   * Process a complete indexing job\n   * Extracts URLs, creates submissions, and processes each URL through Google's API\n   */ async processIndexingJob(jobId) {\n        if (this.processingJobs.has(jobId)) {\n            return {\n                success: false,\n                error: 'Job is already being processed'\n            };\n        }\n        try {\n            // Lock the job to prevent concurrent processing\n            const lockResult = await this.lockJobForProcessing(jobId);\n            if (!lockResult) {\n                return {\n                    success: false,\n                    error: 'Failed to lock job - may already be processing'\n                };\n            }\n            this.processingJobs.add(jobId);\n            console.log(`ðŸš€ Starting indexing job ${jobId}`);\n            // Get job details\n            const job = await this.getJobDetails(jobId);\n            if (!job) {\n                return {\n                    success: false,\n                    error: 'Job not found'\n                };\n            }\n            // Update job status to running\n            await this.updateJobStatus(jobId, 'running', {\n                started_at: new Date().toISOString(),\n                processed_urls: 0,\n                successful_urls: 0,\n                failed_urls: 0,\n                progress_percentage: 0\n            });\n            // Extract URLs from job source data\n            const urls = await this.extractUrlsFromJobSource(job);\n            if (urls.length === 0) {\n                throw new Error('No URLs found to process in job source data');\n            }\n            console.log(`ðŸ“‹ Found ${urls.length} URLs to process`);\n            // Create URL submissions for tracking\n            await this.createUrlSubmissionsForJob(jobId, urls);\n            // Process all URLs through Google's Indexing API\n            await this.processUrlSubmissionsWithGoogleAPI(job);\n            // Mark job as completed\n            await this.updateJobStatus(jobId, 'completed', {\n                completed_at: new Date().toISOString(),\n                locked_at: null,\n                locked_by: null\n            });\n            console.log(`âœ… Indexing job ${jobId} completed successfully`);\n            return {\n                success: true\n            };\n        } catch (error) {\n            console.error(`âŒ Indexing job ${jobId} failed:`, error);\n            // Mark job as failed\n            await this.updateJobStatus(jobId, 'failed', {\n                error_message: error instanceof Error ? error.message : 'Unknown error',\n                locked_at: null,\n                locked_by: null\n            });\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error'\n            };\n        } finally{\n            this.processingJobs.delete(jobId);\n        }\n    }\n    /**\n   * Extract URLs from job source data based on job type\n   */ async extractUrlsFromJobSource(job) {\n        try {\n            if (job.type === 'manual') {\n                // For manual jobs, URLs are stored in source_data.urls\n                const urls = job.source_data?.urls || [];\n                console.log(`ðŸ“ Manual job: extracted ${urls.length} URLs`);\n                return urls;\n            } else if (job.type === 'sitemap') {\n                // For sitemap jobs, parse the sitemap URL\n                const sitemapUrl = job.source_data?.sitemapUrl;\n                if (!sitemapUrl) {\n                    throw new Error('No sitemap URL found in job source data');\n                }\n                console.log(`ðŸ—ºï¸ Sitemap job: parsing ${sitemapUrl}`);\n                return await this.parseSitemapUrls(sitemapUrl);\n            }\n            return [];\n        } catch (error) {\n            console.error('Error extracting URLs from job source:', error);\n            throw error;\n        }\n    }\n    /**\n   * Parse sitemap XML to extract all URLs\n   */ async parseSitemapUrls(sitemapUrl) {\n        try {\n            console.log(`ðŸ” Fetching sitemap: ${sitemapUrl}`);\n            const response = await fetch(sitemapUrl);\n            if (!response.ok) {\n                throw new Error(`Failed to fetch sitemap: ${response.status} ${response.statusText}`);\n            }\n            const xmlContent = await response.text();\n            const xml2js = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/xmlbuilder\"), __webpack_require__.e(\"vendor-chunks/xml2js\"), __webpack_require__.e(\"vendor-chunks/sax\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! xml2js */ \"(rsc)/./node_modules/xml2js/lib/xml2js.js\", 23));\n            const parser = new xml2js.Parser();\n            const parsedXml = await parser.parseStringPromise(xmlContent);\n            const urls = [];\n            // Handle regular sitemap with URL entries\n            if (parsedXml.urlset?.url) {\n                parsedXml.urlset.url.forEach((urlEntry)=>{\n                    if (urlEntry.loc?.[0]) {\n                        urls.push(urlEntry.loc[0]);\n                    }\n                });\n            }\n            // Handle sitemap index with nested sitemaps\n            if (parsedXml.sitemapindex?.sitemap) {\n                for (const sitemapEntry of parsedXml.sitemapindex.sitemap){\n                    if (sitemapEntry.loc?.[0]) {\n                        const nestedUrls = await this.parseSitemapUrls(sitemapEntry.loc[0]);\n                        urls.push(...nestedUrls);\n                    }\n                }\n            }\n            console.log(`âœ… Extracted ${urls.length} URLs from sitemap`);\n            return urls;\n        } catch (error) {\n            console.error('Error parsing sitemap:', error);\n            throw new Error(`Sitemap parsing failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n    }\n    /**\n   * Create URL submission records for tracking individual URL processing\n   */ async createUrlSubmissionsForJob(jobId, urls) {\n        try {\n            console.log(`ðŸ“Š Creating ${urls.length} URL submission records`);\n            const submissions = urls.map((url)=>({\n                    job_id: jobId,\n                    url: url,\n                    status: 'pending',\n                    retry_count: 0,\n                    created_at: new Date().toISOString(),\n                    updated_at: new Date().toISOString()\n                }));\n            // Insert submissions in batches to avoid database limits\n            const batchSize = 100;\n            for(let i = 0; i < submissions.length; i += batchSize){\n                const batch = submissions.slice(i, i + batchSize);\n                const { error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_indexing_url_submissions').insert(batch);\n                if (error) {\n                    throw new Error(`Failed to create URL submissions: ${error.message}`);\n                }\n            }\n            // Update job with total URL count\n            await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_indexing_jobs').update({\n                total_urls: urls.length,\n                updated_at: new Date().toISOString()\n            }).eq('id', jobId);\n            console.log(`âœ… Created ${urls.length} URL submission records`);\n        } catch (error) {\n            console.error('Error creating URL submissions:', error);\n            throw error;\n        }\n    }\n    /**\n   * Process all URL submissions through Google's Indexing API\n   */ async processUrlSubmissionsWithGoogleAPI(job) {\n        try {\n            console.log(`ðŸ”„ Processing URL submissions for job ${job.id}`);\n            // Get active service accounts for load balancing\n            const { data: serviceAccounts, error: saError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_google_service_accounts').select('*').eq('user_id', job.user_id).eq('is_active', true);\n            if (saError || !serviceAccounts || serviceAccounts.length === 0) {\n                throw new Error('No active Google service accounts found for user');\n            }\n            console.log(`ðŸ“ˆ Using ${serviceAccounts.length} service accounts for load balancing`);\n            // Get pending submissions for this job\n            const { data: submissions, error: subError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_indexing_url_submissions').select('*').eq('job_id', job.id).eq('status', 'pending').order('created_at');\n            if (subError) {\n                throw new Error(`Error fetching URL submissions: ${subError.message}`);\n            }\n            if (!submissions || submissions.length === 0) {\n                console.log('âš ï¸ No pending submissions found for processing');\n                return;\n            }\n            console.log(`ðŸŽ¯ Processing ${submissions.length} URL submissions`);\n            let processed = 0;\n            let successful = 0;\n            let failed = 0;\n            // Process each URL submission\n            for (const submission of submissions){\n                try {\n                    // Round-robin service account selection for load balancing\n                    const serviceAccount = serviceAccounts[processed % serviceAccounts.length];\n                    // Get access token for Google API\n                    const accessToken = await this.googleAuth.getAccessToken(serviceAccount.id);\n                    if (!accessToken) {\n                        throw new Error('Failed to obtain Google API access token');\n                    }\n                    // Submit URL to Google's Indexing API\n                    await this.submitUrlToGoogleIndexingAPI(submission.url, accessToken);\n                    // Update submission as successful\n                    await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_indexing_url_submissions').update({\n                        status: 'submitted',\n                        submitted_at: new Date().toISOString(),\n                        service_account_id: serviceAccount.id,\n                        updated_at: new Date().toISOString()\n                    }).eq('id', submission.id);\n                    successful++;\n                    console.log(`âœ… Successfully indexed: ${submission.url}`);\n                } catch (error) {\n                    console.error(`âŒ Failed to index ${submission.url}:`, error);\n                    // Update submission as failed\n                    await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_indexing_url_submissions').update({\n                        status: 'failed',\n                        error_message: error instanceof Error ? error.message : 'Indexing failed',\n                        retry_count: submission.retry_count + 1,\n                        updated_at: new Date().toISOString()\n                    }).eq('id', submission.id);\n                    failed++;\n                }\n                processed++;\n                // Update job progress in real-time\n                const progressPercentage = Math.round(processed / submissions.length * 100);\n                await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_indexing_jobs').update({\n                    processed_urls: processed,\n                    successful_urls: successful,\n                    failed_urls: failed,\n                    progress_percentage: progressPercentage,\n                    updated_at: new Date().toISOString()\n                }).eq('id', job.id);\n                // Respect Google API rate limits\n                await new Promise((resolve)=>setTimeout(resolve, 100));\n            }\n            console.log(`ðŸ“Š Job processing complete: ${successful} successful, ${failed} failed out of ${processed} total`);\n        } catch (error) {\n            console.error('Error processing URL submissions:', error);\n            throw error;\n        }\n    }\n    /**\n   * Submit individual URL to Google's Indexing API\n   */ async submitUrlToGoogleIndexingAPI(url, accessToken) {\n        const apiUrl = 'https://indexing.googleapis.com/v3/urlNotifications:publish';\n        const response = await fetch(apiUrl, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${accessToken}`\n            },\n            body: JSON.stringify({\n                url: url,\n                type: 'URL_UPDATED'\n            })\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            const errorMessage = errorData.error?.message || `HTTP ${response.status}: ${response.statusText}`;\n            throw new Error(`Google Indexing API error: ${errorMessage}`);\n        }\n        // Log successful response for debugging\n        const responseData = await response.json();\n        console.log(`ðŸŽ¯ Google API response for ${url}:`, responseData);\n    }\n    /**\n   * Lock job to prevent concurrent processing\n   */ async lockJobForProcessing(jobId) {\n        try {\n            const lockTime = new Date().toISOString();\n            const lockId = `processor-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n            const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_indexing_jobs').update({\n                locked_at: lockTime,\n                locked_by: lockId,\n                status: 'running'\n            }).eq('id', jobId).eq('status', 'pending').is('locked_at', null).select();\n            if (error) {\n                console.error('Error locking job:', error);\n                return false;\n            }\n            const success = data && data.length > 0;\n            if (!success) {\n                console.log(`Job ${jobId} is already locked or not in pending status`);\n            }\n            return success;\n        } catch (error) {\n            console.error('Error locking job:', error);\n            return false;\n        }\n    }\n    /**\n   * Get job details from database\n   */ async getJobDetails(jobId) {\n        try {\n            const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_indexing_jobs').select('*').eq('id', jobId).single();\n            return error ? null : data;\n        } catch (error) {\n            console.error('Error getting job details:', error);\n            return null;\n        }\n    }\n    /**\n   * Update job status and additional fields\n   */ async updateJobStatus(jobId, status, extraFields = {}) {\n        try {\n            await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_indexing_jobs').update({\n                status,\n                updated_at: new Date().toISOString(),\n                ...extraFields\n            }).eq('id', jobId);\n        } catch (error) {\n            console.error('Error updating job status:', error);\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFjTyxjQUFjVixLQUFhLEVBQStCO1FBQ3RFLElBQUk7WUFDRixNQUFNLEVBQUV5RSxJQUFJLEVBQUV0RSxLQUFLLEVBQUUsR0FBRyxNQUFNWixvREFBYUEsQ0FDeEM0RSxJQUFJLENBQUMsc0JBQ0xTLE1BQU0sQ0FBQyxLQUNQTCxFQUFFLENBQUMsTUFBTXZFLE9BQ1RrSCxNQUFNO1lBRVQsT0FBTy9HLFFBQVEsT0FBT3NFO1FBQ3hCLEVBQUUsT0FBT3RFLE9BQU87WUFDZEksUUFBUUosS0FBSyxDQUFDLDhCQUE4QkE7WUFDNUMsT0FBTztRQUNUO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELE1BQWNRLGdCQUFnQlgsS0FBYSxFQUFFc0MsTUFBYyxFQUFFNkUsY0FBbUMsQ0FBQyxDQUFDLEVBQWlCO1FBQ2pILElBQUk7WUFDRixNQUFNNUgsb0RBQWFBLENBQ2hCNEUsSUFBSSxDQUFDLHNCQUNMRSxNQUFNLENBQUM7Z0JBQ04vQjtnQkFDQXdCLFlBQVksSUFBSWpELE9BQU9DLFdBQVc7Z0JBQ2xDLEdBQUdxRyxXQUFXO1lBQ2hCLEdBQ0M1QyxFQUFFLENBQUMsTUFBTXZFO1FBQ2QsRUFBRSxPQUFPRyxPQUFPO1lBQ2RJLFFBQVFKLEtBQUssQ0FBQyw4QkFBOEJBO1FBQzlDO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9saWIvZ29vZ2xlLWluZGV4aW5nLXByb2Nlc3Nvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdXBhYmFzZUFkbWluIH0gZnJvbSAnLi9zdXBhYmFzZSc7XG5pbXBvcnQgeyBHb29nbGVBdXRoU2VydmljZSB9IGZyb20gJy4vZ29vZ2xlLWF1dGgtc2VydmljZSc7XG5cbmludGVyZmFjZSBJbmRleGluZ0pvYiB7XG4gIGlkOiBzdHJpbmc7XG4gIHVzZXJfaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICB0eXBlOiAnbWFudWFsJyB8ICdzaXRlbWFwJztcbiAgc3RhdHVzOiBzdHJpbmc7XG4gIHNvdXJjZV9kYXRhOiBhbnk7XG4gIHRvdGFsX3VybHM6IG51bWJlcjtcbiAgcHJvY2Vzc2VkX3VybHM6IG51bWJlcjtcbiAgc3VjY2Vzc2Z1bF91cmxzOiBudW1iZXI7XG4gIGZhaWxlZF91cmxzOiBudW1iZXI7XG4gIHByb2dyZXNzX3BlcmNlbnRhZ2U6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFVybFN1Ym1pc3Npb24ge1xuICBpZDogc3RyaW5nO1xuICBqb2JfaWQ6IHN0cmluZztcbiAgdXJsOiBzdHJpbmc7XG4gIHN0YXR1czogc3RyaW5nO1xuICByZXRyeV9jb3VudDogbnVtYmVyO1xuICBzZXJ2aWNlX2FjY291bnRfaWQ/OiBzdHJpbmc7XG4gIGVycm9yX21lc3NhZ2U/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogR29vZ2xlIEluZGV4aW5nIFByb2Nlc3NvclxuICogXG4gKiBQcm9mZXNzaW9uYWwtZ3JhZGUgVVJMIGluZGV4aW5nIHN5c3RlbSB0aGF0IGludGVncmF0ZXMgd2l0aCBHb29nbGUncyBJbmRleGluZyBBUElcbiAqIHRvIGF1dG9tYXRpY2FsbHkgc3VibWl0IFVSTHMgZm9yIGluZGV4aW5nIHdpdGggcHJvcGVyIGVycm9yIGhhbmRsaW5nLCByZXRyeSBsb2dpYyxcbiAqIGFuZCBxdW90YSBtYW5hZ2VtZW50IGFjcm9zcyBtdWx0aXBsZSBzZXJ2aWNlIGFjY291bnRzLlxuICovXG5leHBvcnQgY2xhc3MgR29vZ2xlSW5kZXhpbmdQcm9jZXNzb3Ige1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogR29vZ2xlSW5kZXhpbmdQcm9jZXNzb3I7XG4gIHByaXZhdGUgZ29vZ2xlQXV0aDogR29vZ2xlQXV0aFNlcnZpY2U7XG4gIHByaXZhdGUgcHJvY2Vzc2luZ0pvYnMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmdvb2dsZUF1dGggPSBHb29nbGVBdXRoU2VydmljZS5nZXRJbnN0YW5jZSgpO1xuICB9XG5cbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IEdvb2dsZUluZGV4aW5nUHJvY2Vzc29yIHtcbiAgICBpZiAoIUdvb2dsZUluZGV4aW5nUHJvY2Vzc29yLmluc3RhbmNlKSB7XG4gICAgICBHb29nbGVJbmRleGluZ1Byb2Nlc3Nvci5pbnN0YW5jZSA9IG5ldyBHb29nbGVJbmRleGluZ1Byb2Nlc3NvcigpO1xuICAgIH1cbiAgICByZXR1cm4gR29vZ2xlSW5kZXhpbmdQcm9jZXNzb3IuaW5zdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyBhIGNvbXBsZXRlIGluZGV4aW5nIGpvYlxuICAgKiBFeHRyYWN0cyBVUkxzLCBjcmVhdGVzIHN1Ym1pc3Npb25zLCBhbmQgcHJvY2Vzc2VzIGVhY2ggVVJMIHRocm91Z2ggR29vZ2xlJ3MgQVBJXG4gICAqL1xuICBhc3luYyBwcm9jZXNzSW5kZXhpbmdKb2Ioam9iSWQ6IHN0cmluZyk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PiB7XG4gICAgaWYgKHRoaXMucHJvY2Vzc2luZ0pvYnMuaGFzKGpvYklkKSkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnSm9iIGlzIGFscmVhZHkgYmVpbmcgcHJvY2Vzc2VkJyB9O1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBMb2NrIHRoZSBqb2IgdG8gcHJldmVudCBjb25jdXJyZW50IHByb2Nlc3NpbmdcbiAgICAgIGNvbnN0IGxvY2tSZXN1bHQgPSBhd2FpdCB0aGlzLmxvY2tKb2JGb3JQcm9jZXNzaW5nKGpvYklkKTtcbiAgICAgIGlmICghbG9ja1Jlc3VsdCkge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdGYWlsZWQgdG8gbG9jayBqb2IgLSBtYXkgYWxyZWFkeSBiZSBwcm9jZXNzaW5nJyB9O1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByb2Nlc3NpbmdKb2JzLmFkZChqb2JJZCk7XG4gICAgICBjb25zb2xlLmxvZyhg8J+agCBTdGFydGluZyBpbmRleGluZyBqb2IgJHtqb2JJZH1gKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IGpvYiBkZXRhaWxzXG4gICAgICBjb25zdCBqb2IgPSBhd2FpdCB0aGlzLmdldEpvYkRldGFpbHMoam9iSWQpO1xuICAgICAgaWYgKCFqb2IpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnSm9iIG5vdCBmb3VuZCcgfTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGpvYiBzdGF0dXMgdG8gcnVubmluZ1xuICAgICAgYXdhaXQgdGhpcy51cGRhdGVKb2JTdGF0dXMoam9iSWQsICdydW5uaW5nJywgeyBcbiAgICAgICAgc3RhcnRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBwcm9jZXNzZWRfdXJsczogMCxcbiAgICAgICAgc3VjY2Vzc2Z1bF91cmxzOiAwLFxuICAgICAgICBmYWlsZWRfdXJsczogMCxcbiAgICAgICAgcHJvZ3Jlc3NfcGVyY2VudGFnZTogMFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEV4dHJhY3QgVVJMcyBmcm9tIGpvYiBzb3VyY2UgZGF0YVxuICAgICAgY29uc3QgdXJscyA9IGF3YWl0IHRoaXMuZXh0cmFjdFVybHNGcm9tSm9iU291cmNlKGpvYik7XG4gICAgICBpZiAodXJscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBVUkxzIGZvdW5kIHRvIHByb2Nlc3MgaW4gam9iIHNvdXJjZSBkYXRhJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKGDwn5OLIEZvdW5kICR7dXJscy5sZW5ndGh9IFVSTHMgdG8gcHJvY2Vzc2ApO1xuXG4gICAgICAvLyBDcmVhdGUgVVJMIHN1Ym1pc3Npb25zIGZvciB0cmFja2luZ1xuICAgICAgYXdhaXQgdGhpcy5jcmVhdGVVcmxTdWJtaXNzaW9uc0ZvckpvYihqb2JJZCwgdXJscyk7XG5cbiAgICAgIC8vIFByb2Nlc3MgYWxsIFVSTHMgdGhyb3VnaCBHb29nbGUncyBJbmRleGluZyBBUElcbiAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc1VybFN1Ym1pc3Npb25zV2l0aEdvb2dsZUFQSShqb2IpO1xuXG4gICAgICAvLyBNYXJrIGpvYiBhcyBjb21wbGV0ZWRcbiAgICAgIGF3YWl0IHRoaXMudXBkYXRlSm9iU3RhdHVzKGpvYklkLCAnY29tcGxldGVkJywgeyBcbiAgICAgICAgY29tcGxldGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGxvY2tlZF9hdDogbnVsbCxcbiAgICAgICAgbG9ja2VkX2J5OiBudWxsXG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coYOKchSBJbmRleGluZyBqb2IgJHtqb2JJZH0gY29tcGxldGVkIHN1Y2Nlc3NmdWxseWApO1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBJbmRleGluZyBqb2IgJHtqb2JJZH0gZmFpbGVkOmAsIGVycm9yKTtcbiAgICAgIFxuICAgICAgLy8gTWFyayBqb2IgYXMgZmFpbGVkXG4gICAgICBhd2FpdCB0aGlzLnVwZGF0ZUpvYlN0YXR1cyhqb2JJZCwgJ2ZhaWxlZCcsIHsgXG4gICAgICAgIGVycm9yX21lc3NhZ2U6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InLFxuICAgICAgICBsb2NrZWRfYXQ6IG51bGwsXG4gICAgICAgIGxvY2tlZF9ieTogbnVsbFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5wcm9jZXNzaW5nSm9icy5kZWxldGUoam9iSWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IFVSTHMgZnJvbSBqb2Igc291cmNlIGRhdGEgYmFzZWQgb24gam9iIHR5cGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZXh0cmFjdFVybHNGcm9tSm9iU291cmNlKGpvYjogSW5kZXhpbmdKb2IpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChqb2IudHlwZSA9PT0gJ21hbnVhbCcpIHtcbiAgICAgICAgLy8gRm9yIG1hbnVhbCBqb2JzLCBVUkxzIGFyZSBzdG9yZWQgaW4gc291cmNlX2RhdGEudXJsc1xuICAgICAgICBjb25zdCB1cmxzID0gam9iLnNvdXJjZV9kYXRhPy51cmxzIHx8IFtdO1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+TnSBNYW51YWwgam9iOiBleHRyYWN0ZWQgJHt1cmxzLmxlbmd0aH0gVVJMc2ApO1xuICAgICAgICByZXR1cm4gdXJscztcbiAgICAgIH0gZWxzZSBpZiAoam9iLnR5cGUgPT09ICdzaXRlbWFwJykge1xuICAgICAgICAvLyBGb3Igc2l0ZW1hcCBqb2JzLCBwYXJzZSB0aGUgc2l0ZW1hcCBVUkxcbiAgICAgICAgY29uc3Qgc2l0ZW1hcFVybCA9IGpvYi5zb3VyY2VfZGF0YT8uc2l0ZW1hcFVybDtcbiAgICAgICAgaWYgKCFzaXRlbWFwVXJsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzaXRlbWFwIFVSTCBmb3VuZCBpbiBqb2Igc291cmNlIGRhdGEnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhg8J+Xuu+4jyBTaXRlbWFwIGpvYjogcGFyc2luZyAke3NpdGVtYXBVcmx9YCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBhcnNlU2l0ZW1hcFVybHMoc2l0ZW1hcFVybCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGV4dHJhY3RpbmcgVVJMcyBmcm9tIGpvYiBzb3VyY2U6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIHNpdGVtYXAgWE1MIHRvIGV4dHJhY3QgYWxsIFVSTHNcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcGFyc2VTaXRlbWFwVXJscyhzaXRlbWFwVXJsOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIEZldGNoaW5nIHNpdGVtYXA6ICR7c2l0ZW1hcFVybH1gKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goc2l0ZW1hcFVybCk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIHNpdGVtYXA6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHhtbENvbnRlbnQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICBjb25zdCB4bWwyanMgPSBhd2FpdCBpbXBvcnQoJ3htbDJqcycpO1xuICAgICAgY29uc3QgcGFyc2VyID0gbmV3IHhtbDJqcy5QYXJzZXIoKTtcbiAgICAgIGNvbnN0IHBhcnNlZFhtbCA9IGF3YWl0IHBhcnNlci5wYXJzZVN0cmluZ1Byb21pc2UoeG1sQ29udGVudCk7XG5cbiAgICAgIGNvbnN0IHVybHM6IHN0cmluZ1tdID0gW107XG4gICAgICBcbiAgICAgIC8vIEhhbmRsZSByZWd1bGFyIHNpdGVtYXAgd2l0aCBVUkwgZW50cmllc1xuICAgICAgaWYgKHBhcnNlZFhtbC51cmxzZXQ/LnVybCkge1xuICAgICAgICBwYXJzZWRYbWwudXJsc2V0LnVybC5mb3JFYWNoKCh1cmxFbnRyeTogYW55KSA9PiB7XG4gICAgICAgICAgaWYgKHVybEVudHJ5LmxvYz8uWzBdKSB7XG4gICAgICAgICAgICB1cmxzLnB1c2godXJsRW50cnkubG9jWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBIYW5kbGUgc2l0ZW1hcCBpbmRleCB3aXRoIG5lc3RlZCBzaXRlbWFwc1xuICAgICAgaWYgKHBhcnNlZFhtbC5zaXRlbWFwaW5kZXg/LnNpdGVtYXApIHtcbiAgICAgICAgZm9yIChjb25zdCBzaXRlbWFwRW50cnkgb2YgcGFyc2VkWG1sLnNpdGVtYXBpbmRleC5zaXRlbWFwKSB7XG4gICAgICAgICAgaWYgKHNpdGVtYXBFbnRyeS5sb2M/LlswXSkge1xuICAgICAgICAgICAgY29uc3QgbmVzdGVkVXJscyA9IGF3YWl0IHRoaXMucGFyc2VTaXRlbWFwVXJscyhzaXRlbWFwRW50cnkubG9jWzBdKTtcbiAgICAgICAgICAgIHVybHMucHVzaCguLi5uZXN0ZWRVcmxzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYOKchSBFeHRyYWN0ZWQgJHt1cmxzLmxlbmd0aH0gVVJMcyBmcm9tIHNpdGVtYXBgKTtcbiAgICAgIHJldHVybiB1cmxzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIHNpdGVtYXA6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaXRlbWFwIHBhcnNpbmcgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgVVJMIHN1Ym1pc3Npb24gcmVjb3JkcyBmb3IgdHJhY2tpbmcgaW5kaXZpZHVhbCBVUkwgcHJvY2Vzc2luZ1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjcmVhdGVVcmxTdWJtaXNzaW9uc0ZvckpvYihqb2JJZDogc3RyaW5nLCB1cmxzOiBzdHJpbmdbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+TiiBDcmVhdGluZyAke3VybHMubGVuZ3RofSBVUkwgc3VibWlzc2lvbiByZWNvcmRzYCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHN1Ym1pc3Npb25zID0gdXJscy5tYXAodXJsID0+ICh7XG4gICAgICAgIGpvYl9pZDogam9iSWQsXG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgICAgcmV0cnlfY291bnQ6IDAsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9KSk7XG5cbiAgICAgIC8vIEluc2VydCBzdWJtaXNzaW9ucyBpbiBiYXRjaGVzIHRvIGF2b2lkIGRhdGFiYXNlIGxpbWl0c1xuICAgICAgY29uc3QgYmF0Y2hTaXplID0gMTAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJtaXNzaW9ucy5sZW5ndGg7IGkgKz0gYmF0Y2hTaXplKSB7XG4gICAgICAgIGNvbnN0IGJhdGNoID0gc3VibWlzc2lvbnMuc2xpY2UoaSwgaSArIGJhdGNoU2l6ZSk7XG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlQWRtaW5cbiAgICAgICAgICAuZnJvbSgnaW5kYl9pbmRleGluZ191cmxfc3VibWlzc2lvbnMnKVxuICAgICAgICAgIC5pbnNlcnQoYmF0Y2gpO1xuXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBVUkwgc3VibWlzc2lvbnM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgam9iIHdpdGggdG90YWwgVVJMIGNvdW50XG4gICAgICBhd2FpdCBzdXBhYmFzZUFkbWluXG4gICAgICAgIC5mcm9tKCdpbmRiX2luZGV4aW5nX2pvYnMnKVxuICAgICAgICAudXBkYXRlKHsgXG4gICAgICAgICAgdG90YWxfdXJsczogdXJscy5sZW5ndGgsXG4gICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH0pXG4gICAgICAgIC5lcSgnaWQnLCBqb2JJZCk7XG5cbiAgICAgIGNvbnNvbGUubG9nKGDinIUgQ3JlYXRlZCAke3VybHMubGVuZ3RofSBVUkwgc3VibWlzc2lvbiByZWNvcmRzYCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIFVSTCBzdWJtaXNzaW9uczonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyBhbGwgVVJMIHN1Ym1pc3Npb25zIHRocm91Z2ggR29vZ2xlJ3MgSW5kZXhpbmcgQVBJXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHByb2Nlc3NVcmxTdWJtaXNzaW9uc1dpdGhHb29nbGVBUEkoam9iOiBJbmRleGluZ0pvYik6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+UhCBQcm9jZXNzaW5nIFVSTCBzdWJtaXNzaW9ucyBmb3Igam9iICR7am9iLmlkfWApO1xuICAgICAgXG4gICAgICAvLyBHZXQgYWN0aXZlIHNlcnZpY2UgYWNjb3VudHMgZm9yIGxvYWQgYmFsYW5jaW5nXG4gICAgICBjb25zdCB7IGRhdGE6IHNlcnZpY2VBY2NvdW50cywgZXJyb3I6IHNhRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlQWRtaW5cbiAgICAgICAgLmZyb20oJ2luZGJfZ29vZ2xlX3NlcnZpY2VfYWNjb3VudHMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgam9iLnVzZXJfaWQpXG4gICAgICAgIC5lcSgnaXNfYWN0aXZlJywgdHJ1ZSk7XG5cbiAgICAgIGlmIChzYUVycm9yIHx8ICFzZXJ2aWNlQWNjb3VudHMgfHwgc2VydmljZUFjY291bnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjdGl2ZSBHb29nbGUgc2VydmljZSBhY2NvdW50cyBmb3VuZCBmb3IgdXNlcicpO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiCBVc2luZyAke3NlcnZpY2VBY2NvdW50cy5sZW5ndGh9IHNlcnZpY2UgYWNjb3VudHMgZm9yIGxvYWQgYmFsYW5jaW5nYCk7XG5cbiAgICAgIC8vIEdldCBwZW5kaW5nIHN1Ym1pc3Npb25zIGZvciB0aGlzIGpvYlxuICAgICAgY29uc3QgeyBkYXRhOiBzdWJtaXNzaW9ucywgZXJyb3I6IHN1YkVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZUFkbWluXG4gICAgICAgIC5mcm9tKCdpbmRiX2luZGV4aW5nX3VybF9zdWJtaXNzaW9ucycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAuZXEoJ2pvYl9pZCcsIGpvYi5pZClcbiAgICAgICAgLmVxKCdzdGF0dXMnLCAncGVuZGluZycpXG4gICAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcpO1xuXG4gICAgICBpZiAoc3ViRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBmZXRjaGluZyBVUkwgc3VibWlzc2lvbnM6ICR7c3ViRXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzdWJtaXNzaW9ucyB8fCBzdWJtaXNzaW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KaoO+4jyBObyBwZW5kaW5nIHN1Ym1pc3Npb25zIGZvdW5kIGZvciBwcm9jZXNzaW5nJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYPCfjq8gUHJvY2Vzc2luZyAke3N1Ym1pc3Npb25zLmxlbmd0aH0gVVJMIHN1Ym1pc3Npb25zYCk7XG5cbiAgICAgIGxldCBwcm9jZXNzZWQgPSAwO1xuICAgICAgbGV0IHN1Y2Nlc3NmdWwgPSAwO1xuICAgICAgbGV0IGZhaWxlZCA9IDA7XG5cbiAgICAgIC8vIFByb2Nlc3MgZWFjaCBVUkwgc3VibWlzc2lvblxuICAgICAgZm9yIChjb25zdCBzdWJtaXNzaW9uIG9mIHN1Ym1pc3Npb25zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gUm91bmQtcm9iaW4gc2VydmljZSBhY2NvdW50IHNlbGVjdGlvbiBmb3IgbG9hZCBiYWxhbmNpbmdcbiAgICAgICAgICBjb25zdCBzZXJ2aWNlQWNjb3VudCA9IHNlcnZpY2VBY2NvdW50c1twcm9jZXNzZWQgJSBzZXJ2aWNlQWNjb3VudHMubGVuZ3RoXTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBHZXQgYWNjZXNzIHRva2VuIGZvciBHb29nbGUgQVBJXG4gICAgICAgICAgY29uc3QgYWNjZXNzVG9rZW4gPSBhd2FpdCB0aGlzLmdvb2dsZUF1dGguZ2V0QWNjZXNzVG9rZW4oc2VydmljZUFjY291bnQuaWQpO1xuICAgICAgICAgIGlmICghYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIG9idGFpbiBHb29nbGUgQVBJIGFjY2VzcyB0b2tlbicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFN1Ym1pdCBVUkwgdG8gR29vZ2xlJ3MgSW5kZXhpbmcgQVBJXG4gICAgICAgICAgYXdhaXQgdGhpcy5zdWJtaXRVcmxUb0dvb2dsZUluZGV4aW5nQVBJKHN1Ym1pc3Npb24udXJsLCBhY2Nlc3NUb2tlbik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXBkYXRlIHN1Ym1pc3Npb24gYXMgc3VjY2Vzc2Z1bFxuICAgICAgICAgIGF3YWl0IHN1cGFiYXNlQWRtaW5cbiAgICAgICAgICAgIC5mcm9tKCdpbmRiX2luZGV4aW5nX3VybF9zdWJtaXNzaW9ucycpXG4gICAgICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICAgICAgc3RhdHVzOiAnc3VibWl0dGVkJyxcbiAgICAgICAgICAgICAgc3VibWl0dGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgIHNlcnZpY2VfYWNjb3VudF9pZDogc2VydmljZUFjY291bnQuaWQsXG4gICAgICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5lcSgnaWQnLCBzdWJtaXNzaW9uLmlkKTtcblxuICAgICAgICAgIHN1Y2Nlc3NmdWwrKztcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFN1Y2Nlc3NmdWxseSBpbmRleGVkOiAke3N1Ym1pc3Npb24udXJsfWApO1xuXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihg4p2MIEZhaWxlZCB0byBpbmRleCAke3N1Ym1pc3Npb24udXJsfTpgLCBlcnJvcik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXBkYXRlIHN1Ym1pc3Npb24gYXMgZmFpbGVkXG4gICAgICAgICAgYXdhaXQgc3VwYWJhc2VBZG1pblxuICAgICAgICAgICAgLmZyb20oJ2luZGJfaW5kZXhpbmdfdXJsX3N1Ym1pc3Npb25zJylcbiAgICAgICAgICAgIC51cGRhdGUoe1xuICAgICAgICAgICAgICBzdGF0dXM6ICdmYWlsZWQnLFxuICAgICAgICAgICAgICBlcnJvcl9tZXNzYWdlOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdJbmRleGluZyBmYWlsZWQnLFxuICAgICAgICAgICAgICByZXRyeV9jb3VudDogc3VibWlzc2lvbi5yZXRyeV9jb3VudCArIDEsXG4gICAgICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5lcSgnaWQnLCBzdWJtaXNzaW9uLmlkKTtcblxuICAgICAgICAgIGZhaWxlZCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvY2Vzc2VkKys7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgam9iIHByb2dyZXNzIGluIHJlYWwtdGltZVxuICAgICAgICBjb25zdCBwcm9ncmVzc1BlcmNlbnRhZ2UgPSBNYXRoLnJvdW5kKChwcm9jZXNzZWQgLyBzdWJtaXNzaW9ucy5sZW5ndGgpICogMTAwKTtcbiAgICAgICAgYXdhaXQgc3VwYWJhc2VBZG1pblxuICAgICAgICAgIC5mcm9tKCdpbmRiX2luZGV4aW5nX2pvYnMnKVxuICAgICAgICAgIC51cGRhdGUoe1xuICAgICAgICAgICAgcHJvY2Vzc2VkX3VybHM6IHByb2Nlc3NlZCxcbiAgICAgICAgICAgIHN1Y2Nlc3NmdWxfdXJsczogc3VjY2Vzc2Z1bCxcbiAgICAgICAgICAgIGZhaWxlZF91cmxzOiBmYWlsZWQsXG4gICAgICAgICAgICBwcm9ncmVzc19wZXJjZW50YWdlOiBwcm9ncmVzc1BlcmNlbnRhZ2UsXG4gICAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5lcSgnaWQnLCBqb2IuaWQpO1xuXG4gICAgICAgIC8vIFJlc3BlY3QgR29vZ2xlIEFQSSByYXRlIGxpbWl0c1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKGDwn5OKIEpvYiBwcm9jZXNzaW5nIGNvbXBsZXRlOiAke3N1Y2Nlc3NmdWx9IHN1Y2Nlc3NmdWwsICR7ZmFpbGVkfSBmYWlsZWQgb3V0IG9mICR7cHJvY2Vzc2VkfSB0b3RhbGApO1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHByb2Nlc3NpbmcgVVJMIHN1Ym1pc3Npb25zOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJtaXQgaW5kaXZpZHVhbCBVUkwgdG8gR29vZ2xlJ3MgSW5kZXhpbmcgQVBJXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHN1Ym1pdFVybFRvR29vZ2xlSW5kZXhpbmdBUEkodXJsOiBzdHJpbmcsIGFjY2Vzc1Rva2VuOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBhcGlVcmwgPSAnaHR0cHM6Ly9pbmRleGluZy5nb29nbGVhcGlzLmNvbS92My91cmxOb3RpZmljYXRpb25zOnB1Ymxpc2gnO1xuICAgIFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYXBpVXJsLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIHR5cGU6ICdVUkxfVVBEQVRFRCdcbiAgICAgIH0pXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvckRhdGEuZXJyb3I/Lm1lc3NhZ2UgfHwgYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgR29vZ2xlIEluZGV4aW5nIEFQSSBlcnJvcjogJHtlcnJvck1lc3NhZ2V9YCk7XG4gICAgfVxuXG4gICAgLy8gTG9nIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgZm9yIGRlYnVnZ2luZ1xuICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBjb25zb2xlLmxvZyhg8J+OryBHb29nbGUgQVBJIHJlc3BvbnNlIGZvciAke3VybH06YCwgcmVzcG9uc2VEYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2NrIGpvYiB0byBwcmV2ZW50IGNvbmN1cnJlbnQgcHJvY2Vzc2luZ1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBsb2NrSm9iRm9yUHJvY2Vzc2luZyhqb2JJZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGxvY2tUaW1lID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgY29uc3QgbG9ja0lkID0gYHByb2Nlc3Nvci0ke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWA7XG5cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlQWRtaW5cbiAgICAgICAgLmZyb20oJ2luZGJfaW5kZXhpbmdfam9icycpXG4gICAgICAgIC51cGRhdGUoe1xuICAgICAgICAgIGxvY2tlZF9hdDogbG9ja1RpbWUsXG4gICAgICAgICAgbG9ja2VkX2J5OiBsb2NrSWQsXG4gICAgICAgICAgc3RhdHVzOiAncnVubmluZydcbiAgICAgICAgfSlcbiAgICAgICAgLmVxKCdpZCcsIGpvYklkKVxuICAgICAgICAuZXEoJ3N0YXR1cycsICdwZW5kaW5nJylcbiAgICAgICAgLmlzKCdsb2NrZWRfYXQnLCBudWxsKVxuICAgICAgICAuc2VsZWN0KCk7XG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2NraW5nIGpvYjonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3VjY2VzcyA9IGRhdGEgJiYgZGF0YS5sZW5ndGggPiAwO1xuICAgICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBKb2IgJHtqb2JJZH0gaXMgYWxyZWFkeSBsb2NrZWQgb3Igbm90IGluIHBlbmRpbmcgc3RhdHVzYCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2NraW5nIGpvYjonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBqb2IgZGV0YWlscyBmcm9tIGRhdGFiYXNlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGdldEpvYkRldGFpbHMoam9iSWQ6IHN0cmluZyk6IFByb21pc2U8SW5kZXhpbmdKb2IgfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlQWRtaW5cbiAgICAgICAgLmZyb20oJ2luZGJfaW5kZXhpbmdfam9icycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAuZXEoJ2lkJywgam9iSWQpXG4gICAgICAgIC5zaW5nbGUoKTtcblxuICAgICAgcmV0dXJuIGVycm9yID8gbnVsbCA6IGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgam9iIGRldGFpbHM6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBqb2Igc3RhdHVzIGFuZCBhZGRpdGlvbmFsIGZpZWxkc1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyB1cGRhdGVKb2JTdGF0dXMoam9iSWQ6IHN0cmluZywgc3RhdHVzOiBzdHJpbmcsIGV4dHJhRmllbGRzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge30pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgc3VwYWJhc2VBZG1pblxuICAgICAgICAuZnJvbSgnaW5kYl9pbmRleGluZ19qb2JzJylcbiAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAuLi5leHRyYUZpZWxkc1xuICAgICAgICB9KVxuICAgICAgICAuZXEoJ2lkJywgam9iSWQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBqb2Igc3RhdHVzOicsIGVycm9yKTtcbiAgICB9XG4gIH1cbn0iXSwibmFtZXMiOlsic3VwYWJhc2VBZG1pbiIsIkdvb2dsZUF1dGhTZXJ2aWNlIiwiR29vZ2xlSW5kZXhpbmdQcm9jZXNzb3IiLCJwcm9jZXNzaW5nSm9icyIsIlNldCIsImdvb2dsZUF1dGgiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwicHJvY2Vzc0luZGV4aW5nSm9iIiwiam9iSWQiLCJoYXMiLCJzdWNjZXNzIiwiZXJyb3IiLCJsb2NrUmVzdWx0IiwibG9ja0pvYkZvclByb2Nlc3NpbmciLCJhZGQiLCJjb25zb2xlIiwibG9nIiwiam9iIiwiZ2V0Sm9iRGV0YWlscyIsInVwZGF0ZUpvYlN0YXR1cyIsInN0YXJ0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJwcm9jZXNzZWRfdXJscyIsInN1Y2Nlc3NmdWxfdXJscyIsImZhaWxlZF91cmxzIiwicHJvZ3Jlc3NfcGVyY2VudGFnZSIsInVybHMiLCJleHRyYWN0VXJsc0Zyb21Kb2JTb3VyY2UiLCJsZW5ndGgiLCJFcnJvciIsImNyZWF0ZVVybFN1Ym1pc3Npb25zRm9ySm9iIiwicHJvY2Vzc1VybFN1Ym1pc3Npb25zV2l0aEdvb2dsZUFQSSIsImNvbXBsZXRlZF9hdCIsImxvY2tlZF9hdCIsImxvY2tlZF9ieSIsImVycm9yX21lc3NhZ2UiLCJtZXNzYWdlIiwiZGVsZXRlIiwidHlwZSIsInNvdXJjZV9kYXRhIiwic2l0ZW1hcFVybCIsInBhcnNlU2l0ZW1hcFVybHMiLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwieG1sQ29udGVudCIsInRleHQiLCJ4bWwyanMiLCJwYXJzZXIiLCJQYXJzZXIiLCJwYXJzZWRYbWwiLCJwYXJzZVN0cmluZ1Byb21pc2UiLCJ1cmxzZXQiLCJ1cmwiLCJmb3JFYWNoIiwidXJsRW50cnkiLCJsb2MiLCJwdXNoIiwic2l0ZW1hcGluZGV4Iiwic2l0ZW1hcCIsInNpdGVtYXBFbnRyeSIsIm5lc3RlZFVybHMiLCJzdWJtaXNzaW9ucyIsIm1hcCIsImpvYl9pZCIsInJldHJ5X2NvdW50IiwiY3JlYXRlZF9hdCIsInVwZGF0ZWRfYXQiLCJiYXRjaFNpemUiLCJpIiwiYmF0Y2giLCJzbGljZSIsImZyb20iLCJpbnNlcnQiLCJ1cGRhdGUiLCJ0b3RhbF91cmxzIiwiZXEiLCJpZCIsImRhdGEiLCJzZXJ2aWNlQWNjb3VudHMiLCJzYUVycm9yIiwic2VsZWN0IiwidXNlcl9pZCIsInN1YkVycm9yIiwib3JkZXIiLCJwcm9jZXNzZWQiLCJzdWNjZXNzZnVsIiwiZmFpbGVkIiwic3VibWlzc2lvbiIsInNlcnZpY2VBY2NvdW50IiwiYWNjZXNzVG9rZW4iLCJnZXRBY2Nlc3NUb2tlbiIsInN1Ym1pdFVybFRvR29vZ2xlSW5kZXhpbmdBUEkiLCJzdWJtaXR0ZWRfYXQiLCJzZXJ2aWNlX2FjY291bnRfaWQiLCJwcm9ncmVzc1BlcmNlbnRhZ2UiLCJNYXRoIiwicm91bmQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJhcGlVcmwiLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJlcnJvckRhdGEiLCJqc29uIiwiY2F0Y2giLCJlcnJvck1lc3NhZ2UiLCJyZXNwb25zZURhdGEiLCJsb2NrVGltZSIsImxvY2tJZCIsIm5vdyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwiaXMiLCJzaW5nbGUiLCJleHRyYUZpZWxkcyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/google-indexing-processor.ts\n");

/***/ }),

/***/ "(rsc)/./lib/job-monitor.ts":
/*!****************************!*\
  !*** ./lib/job-monitor.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JobMonitor: () => (/* binding */ JobMonitor),\n/* harmony export */   jobMonitor: () => (/* binding */ jobMonitor)\n/* harmony export */ });\n/* harmony import */ var node_cron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node-cron */ \"node-cron\");\n/* harmony import */ var node_cron__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_cron__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./supabase */ \"(rsc)/./lib/supabase.ts\");\n/* harmony import */ var _google_indexing_processor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./google-indexing-processor */ \"(rsc)/./lib/google-indexing-processor.ts\");\n\n\n\n/**\n * Job Monitor Service\n * \n * This service runs as a background worker that:\n * 1. Monitors for pending jobs every minute\n * 2. Automatically triggers processing for pending jobs\n * 3. Handles scheduled jobs based on their next_run_at time\n * 4. Ensures only one instance processes jobs to prevent conflicts\n */ class JobMonitor {\n    constructor(){\n        this.isRunning = false;\n        this.cronJob = null;\n        this.processor = _google_indexing_processor__WEBPACK_IMPORTED_MODULE_2__.GoogleIndexingProcessor.getInstance();\n    }\n    static getInstance() {\n        if (!JobMonitor.instance) {\n            JobMonitor.instance = new JobMonitor();\n        }\n        return JobMonitor.instance;\n    }\n    /**\n   * Start the job monitor\n   * Runs every minute to check for pending jobs\n   */ start() {\n        if (this.isRunning) {\n            console.log('Job monitor is already running');\n            return;\n        }\n        console.log('Starting job monitor...');\n        this.isRunning = true;\n        // Run every minute to check for pending jobs\n        this.cronJob = node_cron__WEBPACK_IMPORTED_MODULE_0__.schedule('* * * * *', async ()=>{\n            await this.checkAndProcessJobs();\n        }, {\n            timezone: 'UTC'\n        });\n        console.log('Job monitor started - checking for jobs every minute');\n    }\n    /**\n   * Stop the job monitor\n   */ stop() {\n        if (!this.isRunning) {\n            console.log('Job monitor is not running');\n            return;\n        }\n        console.log('Stopping job monitor...');\n        this.isRunning = false;\n        if (this.cronJob) {\n            this.cronJob.destroy();\n            this.cronJob = null;\n        }\n        console.log('Job monitor stopped');\n    }\n    /**\n   * Check for pending jobs and process them\n   */ async checkAndProcessJobs() {\n        try {\n            // Find pending jobs that are ready to run\n            const { data: pendingJobs, error } = await _supabase__WEBPACK_IMPORTED_MODULE_1__.supabaseAdmin.from('indb_indexing_jobs').select('id, name, user_id, next_run_at, schedule_type').eq('status', 'pending').is('locked_at', null).or('next_run_at.is.null,next_run_at.lte.' + new Date().toISOString()).limit(5); // Process max 5 jobs per minute to prevent overload\n            if (error) {\n                console.error('Error fetching pending jobs:', error);\n                return;\n            }\n            if (!pendingJobs || pendingJobs.length === 0) {\n                // No pending jobs found - this is normal\n                return;\n            }\n            console.log(`Found ${pendingJobs.length} pending jobs to process`);\n            // Process each job\n            for (const job of pendingJobs){\n                try {\n                    console.log(`Processing job ${job.id} (${job.name})`);\n                    const result = await this.processor.processIndexingJob(job.id);\n                    if (result.success) {\n                        console.log(`âœ… Job ${job.id} completed successfully`);\n                        // Update next run time for recurring jobs\n                        if (job.schedule_type && job.schedule_type !== 'one-time') {\n                            await this.scheduleNextRun(job.id, job.schedule_type);\n                        }\n                    } else {\n                        console.log(`âŒ Job ${job.id} failed: ${result.error}`);\n                    }\n                } catch (error) {\n                    console.error(`Error processing job ${job.id}:`, error);\n                }\n            }\n        } catch (error) {\n            console.error('Error in job monitor:', error);\n        }\n    }\n    /**\n   * Schedule the next run for recurring jobs\n   */ async scheduleNextRun(jobId, scheduleType) {\n        try {\n            const now = new Date();\n            let nextRun;\n            switch(scheduleType){\n                case 'hourly':\n                    nextRun = new Date(now.getTime() + 60 * 60 * 1000); // +1 hour\n                    break;\n                case 'daily':\n                    nextRun = new Date(now.getTime() + 24 * 60 * 60 * 1000); // +1 day\n                    break;\n                case 'weekly':\n                    nextRun = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000); // +1 week\n                    break;\n                case 'monthly':\n                    nextRun = new Date(now);\n                    nextRun.setMonth(nextRun.getMonth() + 1); // +1 month\n                    break;\n                default:\n                    return; // one-time jobs don't get rescheduled\n            }\n            await _supabase__WEBPACK_IMPORTED_MODULE_1__.supabaseAdmin.from('indb_indexing_jobs').update({\n                status: 'pending',\n                next_run_at: nextRun.toISOString(),\n                updated_at: new Date().toISOString()\n            }).eq('id', jobId);\n            console.log(`ðŸ“… Job ${jobId} scheduled for next run at ${nextRun.toISOString()}`);\n        } catch (error) {\n            console.error(`Error scheduling next run for job ${jobId}:`, error);\n        }\n    }\n    /**\n   * Get monitor status\n   */ getStatus() {\n        return {\n            isRunning: this.isRunning,\n            nextCheck: this.cronJob ? 'Every minute' : undefined\n        };\n    }\n    /**\n   * Manually trigger job processing (for testing)\n   */ async triggerNow() {\n        console.log('Manually triggering job processing...');\n        await this.checkAndProcessJobs();\n    }\n}\n// Export singleton instance\nconst jobMonitor = JobMonitor.getInstance();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUFBRTBCLE1BQU0sMkJBQTJCLEVBQUVHLFFBQVFkLFdBQVcsSUFBSTtRQUNsRixFQUFFLE9BQU9QLE9BQU87WUFDZFQsUUFBUVMsS0FBSyxDQUFDLENBQUMsa0NBQWtDLEVBQUVrQixNQUFNLENBQUMsQ0FBQyxFQUFFbEI7UUFDL0Q7SUFDRjtJQUVBOztHQUVDLEdBQ0Q2QixZQUF3RDtRQUN0RCxPQUFPO1lBQ0w1QyxXQUFXLElBQUksQ0FBQ0EsU0FBUztZQUN6QjZDLFdBQVcsSUFBSSxDQUFDNUMsT0FBTyxHQUFHLGlCQUFpQjZDO1FBQzdDO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELE1BQU1DLGFBQTRCO1FBQ2hDekMsUUFBUUMsR0FBRyxDQUFDO1FBQ1osTUFBTSxJQUFJLENBQUNFLG1CQUFtQjtJQUNoQztBQUNGO0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU11QyxhQUFhakQsV0FBV0ksV0FBVyxHQUFHIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL2xpYi9qb2ItbW9uaXRvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjcm9uIGZyb20gJ25vZGUtY3Jvbic7XG5pbXBvcnQgeyBzdXBhYmFzZUFkbWluIH0gZnJvbSAnLi9zdXBhYmFzZSc7XG5pbXBvcnQgeyBHb29nbGVJbmRleGluZ1Byb2Nlc3NvciB9IGZyb20gJy4vZ29vZ2xlLWluZGV4aW5nLXByb2Nlc3Nvcic7XG5cbi8qKlxuICogSm9iIE1vbml0b3IgU2VydmljZVxuICogXG4gKiBUaGlzIHNlcnZpY2UgcnVucyBhcyBhIGJhY2tncm91bmQgd29ya2VyIHRoYXQ6XG4gKiAxLiBNb25pdG9ycyBmb3IgcGVuZGluZyBqb2JzIGV2ZXJ5IG1pbnV0ZVxuICogMi4gQXV0b21hdGljYWxseSB0cmlnZ2VycyBwcm9jZXNzaW5nIGZvciBwZW5kaW5nIGpvYnNcbiAqIDMuIEhhbmRsZXMgc2NoZWR1bGVkIGpvYnMgYmFzZWQgb24gdGhlaXIgbmV4dF9ydW5fYXQgdGltZVxuICogNC4gRW5zdXJlcyBvbmx5IG9uZSBpbnN0YW5jZSBwcm9jZXNzZXMgam9icyB0byBwcmV2ZW50IGNvbmZsaWN0c1xuICovXG5leHBvcnQgY2xhc3MgSm9iTW9uaXRvciB7XG4gIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBKb2JNb25pdG9yO1xuICBwcml2YXRlIGlzUnVubmluZyA9IGZhbHNlO1xuICBwcml2YXRlIHByb2Nlc3NvcjogR29vZ2xlSW5kZXhpbmdQcm9jZXNzb3I7XG4gIHByaXZhdGUgY3JvbkpvYjogY3Jvbi5TY2hlZHVsZWRUYXNrIHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5wcm9jZXNzb3IgPSBHb29nbGVJbmRleGluZ1Byb2Nlc3Nvci5nZXRJbnN0YW5jZSgpO1xuICB9XG5cbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IEpvYk1vbml0b3Ige1xuICAgIGlmICghSm9iTW9uaXRvci5pbnN0YW5jZSkge1xuICAgICAgSm9iTW9uaXRvci5pbnN0YW5jZSA9IG5ldyBKb2JNb25pdG9yKCk7XG4gICAgfVxuICAgIHJldHVybiBKb2JNb25pdG9yLmluc3RhbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHRoZSBqb2IgbW9uaXRvclxuICAgKiBSdW5zIGV2ZXJ5IG1pbnV0ZSB0byBjaGVjayBmb3IgcGVuZGluZyBqb2JzXG4gICAqL1xuICBzdGFydCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdKb2IgbW9uaXRvciBpcyBhbHJlYWR5IHJ1bm5pbmcnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgam9iIG1vbml0b3IuLi4nKTtcbiAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG5cbiAgICAvLyBSdW4gZXZlcnkgbWludXRlIHRvIGNoZWNrIGZvciBwZW5kaW5nIGpvYnNcbiAgICB0aGlzLmNyb25Kb2IgPSBjcm9uLnNjaGVkdWxlKCcqICogKiAqIConLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLmNoZWNrQW5kUHJvY2Vzc0pvYnMoKTtcbiAgICB9LCB7XG4gICAgICB0aW1lem9uZTogJ1VUQydcbiAgICB9KTtcblxuICAgIGNvbnNvbGUubG9nKCdKb2IgbW9uaXRvciBzdGFydGVkIC0gY2hlY2tpbmcgZm9yIGpvYnMgZXZlcnkgbWludXRlJyk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCB0aGUgam9iIG1vbml0b3JcbiAgICovXG4gIHN0b3AoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzUnVubmluZykge1xuICAgICAgY29uc29sZS5sb2coJ0pvYiBtb25pdG9yIGlzIG5vdCBydW5uaW5nJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1N0b3BwaW5nIGpvYiBtb25pdG9yLi4uJyk7XG4gICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLmNyb25Kb2IpIHtcbiAgICAgIHRoaXMuY3JvbkpvYi5kZXN0cm95KCk7XG4gICAgICB0aGlzLmNyb25Kb2IgPSBudWxsO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdKb2IgbW9uaXRvciBzdG9wcGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgZm9yIHBlbmRpbmcgam9icyBhbmQgcHJvY2VzcyB0aGVtXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGNoZWNrQW5kUHJvY2Vzc0pvYnMoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpbmQgcGVuZGluZyBqb2JzIHRoYXQgYXJlIHJlYWR5IHRvIHJ1blxuICAgICAgY29uc3QgeyBkYXRhOiBwZW5kaW5nSm9icywgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlQWRtaW5cbiAgICAgICAgLmZyb20oJ2luZGJfaW5kZXhpbmdfam9icycpXG4gICAgICAgIC5zZWxlY3QoJ2lkLCBuYW1lLCB1c2VyX2lkLCBuZXh0X3J1bl9hdCwgc2NoZWR1bGVfdHlwZScpXG4gICAgICAgIC5lcSgnc3RhdHVzJywgJ3BlbmRpbmcnKVxuICAgICAgICAuaXMoJ2xvY2tlZF9hdCcsIG51bGwpXG4gICAgICAgIC5vcignbmV4dF9ydW5fYXQuaXMubnVsbCxuZXh0X3J1bl9hdC5sdGUuJyArIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSlcbiAgICAgICAgLmxpbWl0KDUpOyAvLyBQcm9jZXNzIG1heCA1IGpvYnMgcGVyIG1pbnV0ZSB0byBwcmV2ZW50IG92ZXJsb2FkXG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwZW5kaW5nIGpvYnM6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghcGVuZGluZ0pvYnMgfHwgcGVuZGluZ0pvYnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIE5vIHBlbmRpbmcgam9icyBmb3VuZCAtIHRoaXMgaXMgbm9ybWFsXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7cGVuZGluZ0pvYnMubGVuZ3RofSBwZW5kaW5nIGpvYnMgdG8gcHJvY2Vzc2ApO1xuXG4gICAgICAvLyBQcm9jZXNzIGVhY2ggam9iXG4gICAgICBmb3IgKGNvbnN0IGpvYiBvZiBwZW5kaW5nSm9icykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBQcm9jZXNzaW5nIGpvYiAke2pvYi5pZH0gKCR7am9iLm5hbWV9KWApO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJvY2Vzc29yLnByb2Nlc3NJbmRleGluZ0pvYihqb2IuaWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBKb2IgJHtqb2IuaWR9IGNvbXBsZXRlZCBzdWNjZXNzZnVsbHlgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVXBkYXRlIG5leHQgcnVuIHRpbWUgZm9yIHJlY3VycmluZyBqb2JzXG4gICAgICAgICAgICBpZiAoam9iLnNjaGVkdWxlX3R5cGUgJiYgam9iLnNjaGVkdWxlX3R5cGUgIT09ICdvbmUtdGltZScpIHtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zY2hlZHVsZU5leHRSdW4oam9iLmlkLCBqb2Iuc2NoZWR1bGVfdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinYwgSm9iICR7am9iLmlkfSBmYWlsZWQ6ICR7cmVzdWx0LmVycm9yfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwcm9jZXNzaW5nIGpvYiAke2pvYi5pZH06YCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGpvYiBtb25pdG9yOicsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2NoZWR1bGUgdGhlIG5leHQgcnVuIGZvciByZWN1cnJpbmcgam9ic1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBzY2hlZHVsZU5leHRSdW4oam9iSWQ6IHN0cmluZywgc2NoZWR1bGVUeXBlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgIGxldCBuZXh0UnVuOiBEYXRlO1xuXG4gICAgICBzd2l0Y2ggKHNjaGVkdWxlVHlwZSkge1xuICAgICAgICBjYXNlICdob3VybHknOlxuICAgICAgICAgIG5leHRSdW4gPSBuZXcgRGF0ZShub3cuZ2V0VGltZSgpICsgNjAgKiA2MCAqIDEwMDApOyAvLyArMSBob3VyXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RhaWx5JzpcbiAgICAgICAgICBuZXh0UnVuID0gbmV3IERhdGUobm93LmdldFRpbWUoKSArIDI0ICogNjAgKiA2MCAqIDEwMDApOyAvLyArMSBkYXlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnd2Vla2x5JzpcbiAgICAgICAgICBuZXh0UnVuID0gbmV3IERhdGUobm93LmdldFRpbWUoKSArIDcgKiAyNCAqIDYwICogNjAgKiAxMDAwKTsgLy8gKzEgd2Vla1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtb250aGx5JzpcbiAgICAgICAgICBuZXh0UnVuID0gbmV3IERhdGUobm93KTtcbiAgICAgICAgICBuZXh0UnVuLnNldE1vbnRoKG5leHRSdW4uZ2V0TW9udGgoKSArIDEpOyAvLyArMSBtb250aFxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybjsgLy8gb25lLXRpbWUgam9icyBkb24ndCBnZXQgcmVzY2hlZHVsZWRcbiAgICAgIH1cblxuICAgICAgYXdhaXQgc3VwYWJhc2VBZG1pblxuICAgICAgICAuZnJvbSgnaW5kYl9pbmRleGluZ19qb2JzJylcbiAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgc3RhdHVzOiAncGVuZGluZycsXG4gICAgICAgICAgbmV4dF9ydW5fYXQ6IG5leHRSdW4udG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfSlcbiAgICAgICAgLmVxKCdpZCcsIGpvYklkKTtcblxuICAgICAgY29uc29sZS5sb2coYPCfk4UgSm9iICR7am9iSWR9IHNjaGVkdWxlZCBmb3IgbmV4dCBydW4gYXQgJHtuZXh0UnVuLnRvSVNPU3RyaW5nKCl9YCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHNjaGVkdWxpbmcgbmV4dCBydW4gZm9yIGpvYiAke2pvYklkfTpgLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBtb25pdG9yIHN0YXR1c1xuICAgKi9cbiAgZ2V0U3RhdHVzKCk6IHsgaXNSdW5uaW5nOiBib29sZWFuOyBuZXh0Q2hlY2s/OiBzdHJpbmcgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzUnVubmluZzogdGhpcy5pc1J1bm5pbmcsXG4gICAgICBuZXh0Q2hlY2s6IHRoaXMuY3JvbkpvYiA/ICdFdmVyeSBtaW51dGUnIDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYW51YWxseSB0cmlnZ2VyIGpvYiBwcm9jZXNzaW5nIChmb3IgdGVzdGluZylcbiAgICovXG4gIGFzeW5jIHRyaWdnZXJOb3coKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc29sZS5sb2coJ01hbnVhbGx5IHRyaWdnZXJpbmcgam9iIHByb2Nlc3NpbmcuLi4nKTtcbiAgICBhd2FpdCB0aGlzLmNoZWNrQW5kUHJvY2Vzc0pvYnMoKTtcbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3Qgam9iTW9uaXRvciA9IEpvYk1vbml0b3IuZ2V0SW5zdGFuY2UoKTsiXSwibmFtZXMiOlsiY3JvbiIsInN1cGFiYXNlQWRtaW4iLCJHb29nbGVJbmRleGluZ1Byb2Nlc3NvciIsIkpvYk1vbml0b3IiLCJpc1J1bm5pbmciLCJjcm9uSm9iIiwicHJvY2Vzc29yIiwiZ2V0SW5zdGFuY2UiLCJpbnN0YW5jZSIsInN0YXJ0IiwiY29uc29sZSIsImxvZyIsInNjaGVkdWxlIiwiY2hlY2tBbmRQcm9jZXNzSm9icyIsInRpbWV6b25lIiwic3RvcCIsImRlc3Ryb3kiLCJkYXRhIiwicGVuZGluZ0pvYnMiLCJlcnJvciIsImZyb20iLCJzZWxlY3QiLCJlcSIsImlzIiwib3IiLCJEYXRlIiwidG9JU09TdHJpbmciLCJsaW1pdCIsImxlbmd0aCIsImpvYiIsImlkIiwibmFtZSIsInJlc3VsdCIsInByb2Nlc3NJbmRleGluZ0pvYiIsInN1Y2Nlc3MiLCJzY2hlZHVsZV90eXBlIiwic2NoZWR1bGVOZXh0UnVuIiwiam9iSWQiLCJzY2hlZHVsZVR5cGUiLCJub3ciLCJuZXh0UnVuIiwiZ2V0VGltZSIsInNldE1vbnRoIiwiZ2V0TW9udGgiLCJ1cGRhdGUiLCJzdGF0dXMiLCJuZXh0X3J1bl9hdCIsInVwZGF0ZWRfYXQiLCJnZXRTdGF0dXMiLCJuZXh0Q2hlY2siLCJ1bmRlZmluZWQiLCJ0cmlnZ2VyTm93Iiwiam9iTW9uaXRvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/job-monitor.ts\n");

/***/ }),

/***/ "(rsc)/./lib/supabase.ts":
/*!*************************!*\
  !*** ./lib/supabase.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   supabase: () => (/* binding */ supabase),\n/* harmony export */   supabaseAdmin: () => (/* binding */ supabaseAdmin)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n\nconst supabaseUrl = \"https://base.indexnow.studio\";\nconst supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYW5vbiIsImlzcyI6InN1cGFiYXNlIiwiaWF0IjoxNzUzMDMwODAwLCJleHAiOjE5MTA3OTcyMDB9.druA2hNMG5tlToENwA6diLetpMm9GdJgaSRwi75iTW0\";\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n    auth: {\n        autoRefreshToken: true,\n        persistSession: true,\n        detectSessionInUrl: true\n    }\n});\n// Server-side client with service role key (for admin operations)\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\nconst supabaseAdmin = supabaseServiceKey ? (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseServiceKey, {\n    auth: {\n        autoRefreshToken: false,\n        persistSession: false\n    }\n}) : (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey) // Fallback to anon key\n;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (supabase);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvc3VwYWJhc2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFvRDtBQUVwRCxNQUFNQyxjQUFjQyw4QkFBb0M7QUFDeEQsTUFBTUcsa0JBQWtCSCwyS0FBeUM7QUFFMUQsTUFBTUssV0FBV1AsbUVBQVlBLENBQUNDLGFBQWFJLGlCQUFpQjtJQUNqRUcsTUFBTTtRQUNKQyxrQkFBa0I7UUFDbEJDLGdCQUFnQjtRQUNoQkMsb0JBQW9CO0lBQ3RCO0FBQ0YsR0FBRTtBQUVGLGtFQUFrRTtBQUNsRSxNQUFNQyxxQkFBcUJWLFFBQVFDLEdBQUcsQ0FBQ1UseUJBQXlCO0FBQ3pELE1BQU1DLGdCQUFnQkYscUJBQ3pCWixtRUFBWUEsQ0FBQ0MsYUFBYVcsb0JBQW9CO0lBQzVDSixNQUFNO1FBQ0pDLGtCQUFrQjtRQUNsQkMsZ0JBQWdCO0lBQ2xCO0FBQ0YsS0FDQVYsbUVBQVlBLENBQUNDLGFBQWFJLGlCQUFpQix1QkFBdUI7Q0FBeEI7QUFFOUMsaUVBQWVFLFFBQVFBLEVBQUEiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2UvbGliL3N1cGFiYXNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcydcblxuY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwhXG5jb25zdCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSFcblxuZXhwb3J0IGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXksIHtcbiAgYXV0aDoge1xuICAgIGF1dG9SZWZyZXNoVG9rZW46IHRydWUsXG4gICAgcGVyc2lzdFNlc3Npb246IHRydWUsXG4gICAgZGV0ZWN0U2Vzc2lvbkluVXJsOiB0cnVlXG4gIH1cbn0pXG5cbi8vIFNlcnZlci1zaWRlIGNsaWVudCB3aXRoIHNlcnZpY2Ugcm9sZSBrZXkgKGZvciBhZG1pbiBvcGVyYXRpb25zKVxuY29uc3Qgc3VwYWJhc2VTZXJ2aWNlS2V5ID0gcHJvY2Vzcy5lbnYuU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWVxuZXhwb3J0IGNvbnN0IHN1cGFiYXNlQWRtaW4gPSBzdXBhYmFzZVNlcnZpY2VLZXlcbiAgPyBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlU2VydmljZUtleSwge1xuICAgICAgYXV0aDoge1xuICAgICAgICBhdXRvUmVmcmVzaFRva2VuOiBmYWxzZSxcbiAgICAgICAgcGVyc2lzdFNlc3Npb246IGZhbHNlXG4gICAgICB9XG4gICAgfSlcbiAgOiBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSkgLy8gRmFsbGJhY2sgdG8gYW5vbiBrZXlcblxuZXhwb3J0IGRlZmF1bHQgc3VwYWJhc2UiXSwibmFtZXMiOlsiY3JlYXRlQ2xpZW50Iiwic3VwYWJhc2VVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwic3VwYWJhc2VBbm9uS2V5IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJzdXBhYmFzZSIsImF1dGgiLCJhdXRvUmVmcmVzaFRva2VuIiwicGVyc2lzdFNlc3Npb24iLCJkZXRlY3RTZXNzaW9uSW5VcmwiLCJzdXBhYmFzZVNlcnZpY2VLZXkiLCJTVVBBQkFTRV9TRVJWSUNFX1JPTEVfS0VZIiwic3VwYWJhc2VBZG1pbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/supabase.ts\n");

/***/ }),

/***/ "(rsc)/./lib/worker-startup.ts":
/*!*******************************!*\
  !*** ./lib/worker-startup.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBackgroundServicesStatus: () => (/* binding */ getBackgroundServicesStatus),\n/* harmony export */   startBackgroundServices: () => (/* binding */ startBackgroundServices),\n/* harmony export */   stopBackgroundServices: () => (/* binding */ stopBackgroundServices)\n/* harmony export */ });\n/* harmony import */ var _background_worker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./background-worker */ \"(rsc)/./lib/background-worker.ts\");\n\n/**\n * Worker Startup Module\n * \n * Initializes background services when the application starts.\n * This should be imported and called once during app initialization.\n */ let isStarted = false;\nfunction startBackgroundServices() {\n    if (isStarted) {\n        console.log('Background services already started');\n        return;\n    }\n    console.log('ðŸš€ Initializing IndexNow Pro background services...');\n    try {\n        // Start the background worker\n        _background_worker__WEBPACK_IMPORTED_MODULE_0__.backgroundWorker.start();\n        isStarted = true;\n        console.log('âœ… Background services started successfully');\n    } catch (error) {\n        console.error('âŒ Failed to start background services:', error);\n    }\n}\nfunction stopBackgroundServices() {\n    if (!isStarted) {\n        console.log('Background services are not running');\n        return;\n    }\n    console.log('ðŸ›‘ Stopping IndexNow Pro background services...');\n    try {\n        _background_worker__WEBPACK_IMPORTED_MODULE_0__.backgroundWorker.stop();\n        isStarted = false;\n        console.log('âœ… Background services stopped successfully');\n    } catch (error) {\n        console.error('âŒ Failed to stop background services:', error);\n    }\n}\nfunction getBackgroundServicesStatus() {\n    return {\n        isStarted,\n        worker: _background_worker__WEBPACK_IMPORTED_MODULE_0__.backgroundWorker.getStatus()\n    };\n}\n// Auto-start in production or development\nif (true) {\n    // Use process.nextTick to ensure modules are loaded and avoid multiple instances\n    process.nextTick(()=>{\n        if (!global.backgroundServicesStarted) {\n            global.backgroundServicesStarted = true;\n            startBackgroundServices();\n        }\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvd29ya2VyLXN0YXJ0dXAudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF1RDtBQUV2RDs7Ozs7Q0FLQyxHQUVELElBQUlDLFlBQVk7QUFFVCxTQUFTQztJQUNkLElBQUlELFdBQVc7UUFDYkUsUUFBUUMsR0FBRyxDQUFDO1FBQ1o7SUFDRjtJQUVBRCxRQUFRQyxHQUFHLENBQUM7SUFFWixJQUFJO1FBQ0YsOEJBQThCO1FBQzlCSixnRUFBZ0JBLENBQUNLLEtBQUs7UUFDdEJKLFlBQVk7UUFFWkUsUUFBUUMsR0FBRyxDQUFDO0lBQ2QsRUFBRSxPQUFPRSxPQUFPO1FBQ2RILFFBQVFHLEtBQUssQ0FBQywwQ0FBMENBO0lBQzFEO0FBQ0Y7QUFFTyxTQUFTQztJQUNkLElBQUksQ0FBQ04sV0FBVztRQUNkRSxRQUFRQyxHQUFHLENBQUM7UUFDWjtJQUNGO0lBRUFELFFBQVFDLEdBQUcsQ0FBQztJQUVaLElBQUk7UUFDRkosZ0VBQWdCQSxDQUFDUSxJQUFJO1FBQ3JCUCxZQUFZO1FBRVpFLFFBQVFDLEdBQUcsQ0FBQztJQUNkLEVBQUUsT0FBT0UsT0FBTztRQUNkSCxRQUFRRyxLQUFLLENBQUMseUNBQXlDQTtJQUN6RDtBQUNGO0FBRU8sU0FBU0c7SUFDZCxPQUFPO1FBQ0xSO1FBQ0FTLFFBQVFWLGdFQUFnQkEsQ0FBQ1csU0FBUztJQUNwQztBQUNGO0FBRUEsMENBQTBDO0FBQzFDLElBQUksSUFBNkIsRUFBRTtJQUNqQyxpRkFBaUY7SUFDakZDLFFBQVFDLFFBQVEsQ0FBQztRQUNmLElBQUksQ0FBQyxPQUFnQkUseUJBQXlCLEVBQUU7WUFDN0NELE9BQWVDLHlCQUF5QixHQUFHO1lBQzVDYjtRQUNGO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9saWIvd29ya2VyLXN0YXJ0dXAudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYmFja2dyb3VuZFdvcmtlciB9IGZyb20gJy4vYmFja2dyb3VuZC13b3JrZXInO1xuXG4vKipcbiAqIFdvcmtlciBTdGFydHVwIE1vZHVsZVxuICogXG4gKiBJbml0aWFsaXplcyBiYWNrZ3JvdW5kIHNlcnZpY2VzIHdoZW4gdGhlIGFwcGxpY2F0aW9uIHN0YXJ0cy5cbiAqIFRoaXMgc2hvdWxkIGJlIGltcG9ydGVkIGFuZCBjYWxsZWQgb25jZSBkdXJpbmcgYXBwIGluaXRpYWxpemF0aW9uLlxuICovXG5cbmxldCBpc1N0YXJ0ZWQgPSBmYWxzZTtcblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0QmFja2dyb3VuZFNlcnZpY2VzKCk6IHZvaWQge1xuICBpZiAoaXNTdGFydGVkKSB7XG4gICAgY29uc29sZS5sb2coJ0JhY2tncm91bmQgc2VydmljZXMgYWxyZWFkeSBzdGFydGVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc29sZS5sb2coJ/CfmoAgSW5pdGlhbGl6aW5nIEluZGV4Tm93IFBybyBiYWNrZ3JvdW5kIHNlcnZpY2VzLi4uJyk7XG4gIFxuICB0cnkge1xuICAgIC8vIFN0YXJ0IHRoZSBiYWNrZ3JvdW5kIHdvcmtlclxuICAgIGJhY2tncm91bmRXb3JrZXIuc3RhcnQoKTtcbiAgICBpc1N0YXJ0ZWQgPSB0cnVlO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCfinIUgQmFja2dyb3VuZCBzZXJ2aWNlcyBzdGFydGVkIHN1Y2Nlc3NmdWxseScpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gc3RhcnQgYmFja2dyb3VuZCBzZXJ2aWNlczonLCBlcnJvcik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0b3BCYWNrZ3JvdW5kU2VydmljZXMoKTogdm9pZCB7XG4gIGlmICghaXNTdGFydGVkKSB7XG4gICAgY29uc29sZS5sb2coJ0JhY2tncm91bmQgc2VydmljZXMgYXJlIG5vdCBydW5uaW5nJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc29sZS5sb2coJ/Cfm5EgU3RvcHBpbmcgSW5kZXhOb3cgUHJvIGJhY2tncm91bmQgc2VydmljZXMuLi4nKTtcbiAgXG4gIHRyeSB7XG4gICAgYmFja2dyb3VuZFdvcmtlci5zdG9wKCk7XG4gICAgaXNTdGFydGVkID0gZmFsc2U7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ+KchSBCYWNrZ3JvdW5kIHNlcnZpY2VzIHN0b3BwZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBzdG9wIGJhY2tncm91bmQgc2VydmljZXM6JywgZXJyb3IpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRCYWNrZ3JvdW5kU2VydmljZXNTdGF0dXMoKTogYW55IHtcbiAgcmV0dXJuIHtcbiAgICBpc1N0YXJ0ZWQsXG4gICAgd29ya2VyOiBiYWNrZ3JvdW5kV29ya2VyLmdldFN0YXR1cygpXG4gIH07XG59XG5cbi8vIEF1dG8tc3RhcnQgaW4gcHJvZHVjdGlvbiBvciBkZXZlbG9wbWVudFxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7IC8vIFNlcnZlci1zaWRlIG9ubHlcbiAgLy8gVXNlIHByb2Nlc3MubmV4dFRpY2sgdG8gZW5zdXJlIG1vZHVsZXMgYXJlIGxvYWRlZCBhbmQgYXZvaWQgbXVsdGlwbGUgaW5zdGFuY2VzXG4gIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgIGlmICghKGdsb2JhbCBhcyBhbnkpLmJhY2tncm91bmRTZXJ2aWNlc1N0YXJ0ZWQpIHtcbiAgICAgIChnbG9iYWwgYXMgYW55KS5iYWNrZ3JvdW5kU2VydmljZXNTdGFydGVkID0gdHJ1ZTtcbiAgICAgIHN0YXJ0QmFja2dyb3VuZFNlcnZpY2VzKCk7XG4gICAgfVxuICB9KTtcbn0iXSwibmFtZXMiOlsiYmFja2dyb3VuZFdvcmtlciIsImlzU3RhcnRlZCIsInN0YXJ0QmFja2dyb3VuZFNlcnZpY2VzIiwiY29uc29sZSIsImxvZyIsInN0YXJ0IiwiZXJyb3IiLCJzdG9wQmFja2dyb3VuZFNlcnZpY2VzIiwic3RvcCIsImdldEJhY2tncm91bmRTZXJ2aWNlc1N0YXR1cyIsIndvcmtlciIsImdldFN0YXR1cyIsInByb2Nlc3MiLCJuZXh0VGljayIsImdsb2JhbCIsImJhY2tncm91bmRTZXJ2aWNlc1N0YXJ0ZWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/worker-startup.ts\n");

/***/ })

};
;