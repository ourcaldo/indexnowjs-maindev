"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_rsc_lib_worker-startup_ts";
exports.ids = ["_rsc_lib_worker-startup_ts"];
exports.modules = {

/***/ "(rsc)/./lib/background-worker.ts":
/*!**********************************!*\
  !*** ./lib/background-worker.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BackgroundWorker: () => (/* binding */ BackgroundWorker),\n/* harmony export */   backgroundWorker: () => (/* binding */ backgroundWorker)\n/* harmony export */ });\n/* harmony import */ var _job_monitor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./job-monitor */ \"(rsc)/./lib/job-monitor.ts\");\n\n/**\n * Background Worker Service\n * \n * Manages all background services for the IndexNow Pro application:\n * - Job monitoring and processing\n * - Cleanup tasks\n * - Health checks\n */ class BackgroundWorker {\n    static getInstance() {\n        if (!BackgroundWorker.instance) {\n            BackgroundWorker.instance = new BackgroundWorker();\n        }\n        return BackgroundWorker.instance;\n    }\n    /**\n   * Start all background services\n   */ start() {\n        if (this.isStarted) {\n            console.log('Background worker is already started');\n            return;\n        }\n        console.log('🚀 Starting IndexNow Pro background worker...');\n        try {\n            // Start job monitor\n            _job_monitor__WEBPACK_IMPORTED_MODULE_0__.jobMonitor.start();\n            this.isStarted = true;\n            console.log('✅ Background worker started successfully');\n            // Log status every 5 minutes\n            setInterval(()=>{\n                this.logStatus();\n            }, 5 * 60 * 1000);\n        } catch (error) {\n            console.error('❌ Failed to start background worker:', error);\n        }\n    }\n    /**\n   * Stop all background services\n   */ stop() {\n        if (!this.isStarted) {\n            console.log('Background worker is not running');\n            return;\n        }\n        console.log('🛑 Stopping background worker...');\n        try {\n            // Stop job monitor\n            _job_monitor__WEBPACK_IMPORTED_MODULE_0__.jobMonitor.stop();\n            this.isStarted = false;\n            console.log('✅ Background worker stopped successfully');\n        } catch (error) {\n            console.error('❌ Error stopping background worker:', error);\n        }\n    }\n    /**\n   * Get worker status\n   */ getStatus() {\n        return {\n            isStarted: this.isStarted,\n            jobMonitor: _job_monitor__WEBPACK_IMPORTED_MODULE_0__.jobMonitor.getStatus(),\n            uptime: this.isStarted ? process.uptime() : undefined\n        };\n    }\n    /**\n   * Log current status\n   */ logStatus() {\n        const status = this.getStatus();\n        console.log('📊 Background Worker Status:', {\n            isStarted: status.isStarted,\n            jobMonitor: status.jobMonitor.isRunning,\n            uptime: status.uptime ? `${Math.round(status.uptime / 60)} minutes` : 'N/A'\n        });\n    }\n    constructor(){\n        this.isStarted = false;\n    }\n}\n// Export singleton instance\nconst backgroundWorker = BackgroundWorker.getInstance();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvYmFja2dyb3VuZC13b3JrZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJDO0FBRTNDOzs7Ozs7O0NBT0MsR0FDTSxNQUFNQztJQUlYLE9BQU9DLGNBQWdDO1FBQ3JDLElBQUksQ0FBQ0QsaUJBQWlCRSxRQUFRLEVBQUU7WUFDOUJGLGlCQUFpQkUsUUFBUSxHQUFHLElBQUlGO1FBQ2xDO1FBQ0EsT0FBT0EsaUJBQWlCRSxRQUFRO0lBQ2xDO0lBRUE7O0dBRUMsR0FDREMsUUFBYztRQUNaLElBQUksSUFBSSxDQUFDQyxTQUFTLEVBQUU7WUFDbEJDLFFBQVFDLEdBQUcsQ0FBQztZQUNaO1FBQ0Y7UUFFQUQsUUFBUUMsR0FBRyxDQUFDO1FBRVosSUFBSTtZQUNGLG9CQUFvQjtZQUNwQlAsb0RBQVVBLENBQUNJLEtBQUs7WUFFaEIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7WUFDakJDLFFBQVFDLEdBQUcsQ0FBQztZQUVaLDZCQUE2QjtZQUM3QkMsWUFBWTtnQkFDVixJQUFJLENBQUNDLFNBQVM7WUFDaEIsR0FBRyxJQUFJLEtBQUs7UUFFZCxFQUFFLE9BQU9DLE9BQU87WUFDZEosUUFBUUksS0FBSyxDQUFDLHdDQUF3Q0E7UUFDeEQ7SUFDRjtJQUVBOztHQUVDLEdBQ0RDLE9BQWE7UUFDWCxJQUFJLENBQUMsSUFBSSxDQUFDTixTQUFTLEVBQUU7WUFDbkJDLFFBQVFDLEdBQUcsQ0FBQztZQUNaO1FBQ0Y7UUFFQUQsUUFBUUMsR0FBRyxDQUFDO1FBRVosSUFBSTtZQUNGLG1CQUFtQjtZQUNuQlAsb0RBQVVBLENBQUNXLElBQUk7WUFFZixJQUFJLENBQUNOLFNBQVMsR0FBRztZQUNqQkMsUUFBUUMsR0FBRyxDQUFDO1FBQ2QsRUFBRSxPQUFPRyxPQUFPO1lBQ2RKLFFBQVFJLEtBQUssQ0FBQyx1Q0FBdUNBO1FBQ3ZEO0lBQ0Y7SUFFQTs7R0FFQyxHQUNERSxZQUlFO1FBQ0EsT0FBTztZQUNMUCxXQUFXLElBQUksQ0FBQ0EsU0FBUztZQUN6QkwsWUFBWUEsb0RBQVVBLENBQUNZLFNBQVM7WUFDaENDLFFBQVEsSUFBSSxDQUFDUixTQUFTLEdBQUdTLFFBQVFELE1BQU0sS0FBS0U7UUFDOUM7SUFDRjtJQUVBOztHQUVDLEdBQ0QsWUFBMEI7UUFDeEIsTUFBTUMsU0FBUyxJQUFJLENBQUNKLFNBQVM7UUFDN0JOLFFBQVFDLEdBQUcsQ0FBQyxnQ0FBZ0M7WUFDMUNGLFdBQVdXLE9BQU9YLFNBQVM7WUFDM0JMLFlBQVlnQixPQUFPaEIsVUFBVSxDQUFDaUIsU0FBUztZQUN2Q0osUUFBUUcsT0FBT0gsTUFBTSxHQUFHLEdBQUdLLEtBQUtDLEtBQUssQ0FBQ0gsT0FBT0gsTUFBTSxHQUFHLElBQUksUUFBUSxDQUFDLEdBQUc7UUFDeEU7SUFDRjs7YUFwRlFSLFlBQVk7O0FBcUZ0QjtBQUVBLDRCQUE0QjtBQUNyQixNQUFNZSxtQkFBbUJuQixpQkFBaUJDLFdBQVcsR0FBRyIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9saWIvYmFja2dyb3VuZC13b3JrZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgam9iTW9uaXRvciB9IGZyb20gJy4vam9iLW1vbml0b3InO1xuXG4vKipcbiAqIEJhY2tncm91bmQgV29ya2VyIFNlcnZpY2VcbiAqIFxuICogTWFuYWdlcyBhbGwgYmFja2dyb3VuZCBzZXJ2aWNlcyBmb3IgdGhlIEluZGV4Tm93IFBybyBhcHBsaWNhdGlvbjpcbiAqIC0gSm9iIG1vbml0b3JpbmcgYW5kIHByb2Nlc3NpbmdcbiAqIC0gQ2xlYW51cCB0YXNrc1xuICogLSBIZWFsdGggY2hlY2tzXG4gKi9cbmV4cG9ydCBjbGFzcyBCYWNrZ3JvdW5kV29ya2VyIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IEJhY2tncm91bmRXb3JrZXI7XG4gIHByaXZhdGUgaXNTdGFydGVkID0gZmFsc2U7XG5cbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IEJhY2tncm91bmRXb3JrZXIge1xuICAgIGlmICghQmFja2dyb3VuZFdvcmtlci5pbnN0YW5jZSkge1xuICAgICAgQmFja2dyb3VuZFdvcmtlci5pbnN0YW5jZSA9IG5ldyBCYWNrZ3JvdW5kV29ya2VyKCk7XG4gICAgfVxuICAgIHJldHVybiBCYWNrZ3JvdW5kV29ya2VyLmluc3RhbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGFsbCBiYWNrZ3JvdW5kIHNlcnZpY2VzXG4gICAqL1xuICBzdGFydCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc1N0YXJ0ZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdCYWNrZ3JvdW5kIHdvcmtlciBpcyBhbHJlYWR5IHN0YXJ0ZWQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygn8J+agCBTdGFydGluZyBJbmRleE5vdyBQcm8gYmFja2dyb3VuZCB3b3JrZXIuLi4nKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gU3RhcnQgam9iIG1vbml0b3JcbiAgICAgIGpvYk1vbml0b3Iuc3RhcnQoKTtcbiAgICAgIFxuICAgICAgdGhpcy5pc1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5sb2coJ+KchSBCYWNrZ3JvdW5kIHdvcmtlciBzdGFydGVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgXG4gICAgICAvLyBMb2cgc3RhdHVzIGV2ZXJ5IDUgbWludXRlc1xuICAgICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICB0aGlzLmxvZ1N0YXR1cygpO1xuICAgICAgfSwgNSAqIDYwICogMTAwMCk7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBzdGFydCBiYWNrZ3JvdW5kIHdvcmtlcjonLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgYWxsIGJhY2tncm91bmQgc2VydmljZXNcbiAgICovXG4gIHN0b3AoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzU3RhcnRlZCkge1xuICAgICAgY29uc29sZS5sb2coJ0JhY2tncm91bmQgd29ya2VyIGlzIG5vdCBydW5uaW5nJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ/Cfm5EgU3RvcHBpbmcgYmFja2dyb3VuZCB3b3JrZXIuLi4nKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gU3RvcCBqb2IgbW9uaXRvclxuICAgICAgam9iTW9uaXRvci5zdG9wKCk7XG4gICAgICBcbiAgICAgIHRoaXMuaXNTdGFydGVkID0gZmFsc2U7XG4gICAgICBjb25zb2xlLmxvZygn4pyFIEJhY2tncm91bmQgd29ya2VyIHN0b3BwZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBzdG9wcGluZyBiYWNrZ3JvdW5kIHdvcmtlcjonLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB3b3JrZXIgc3RhdHVzXG4gICAqL1xuICBnZXRTdGF0dXMoKToge1xuICAgIGlzU3RhcnRlZDogYm9vbGVhbjtcbiAgICBqb2JNb25pdG9yOiBhbnk7XG4gICAgdXB0aW1lPzogbnVtYmVyO1xuICB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNTdGFydGVkOiB0aGlzLmlzU3RhcnRlZCxcbiAgICAgIGpvYk1vbml0b3I6IGpvYk1vbml0b3IuZ2V0U3RhdHVzKCksXG4gICAgICB1cHRpbWU6IHRoaXMuaXNTdGFydGVkID8gcHJvY2Vzcy51cHRpbWUoKSA6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogTG9nIGN1cnJlbnQgc3RhdHVzXG4gICAqL1xuICBwcml2YXRlIGxvZ1N0YXR1cygpOiB2b2lkIHtcbiAgICBjb25zdCBzdGF0dXMgPSB0aGlzLmdldFN0YXR1cygpO1xuICAgIGNvbnNvbGUubG9nKCfwn5OKIEJhY2tncm91bmQgV29ya2VyIFN0YXR1czonLCB7XG4gICAgICBpc1N0YXJ0ZWQ6IHN0YXR1cy5pc1N0YXJ0ZWQsXG4gICAgICBqb2JNb25pdG9yOiBzdGF0dXMuam9iTW9uaXRvci5pc1J1bm5pbmcsXG4gICAgICB1cHRpbWU6IHN0YXR1cy51cHRpbWUgPyBgJHtNYXRoLnJvdW5kKHN0YXR1cy51cHRpbWUgLyA2MCl9IG1pbnV0ZXNgIDogJ04vQSdcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3QgYmFja2dyb3VuZFdvcmtlciA9IEJhY2tncm91bmRXb3JrZXIuZ2V0SW5zdGFuY2UoKTsiXSwibmFtZXMiOlsiam9iTW9uaXRvciIsIkJhY2tncm91bmRXb3JrZXIiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwic3RhcnQiLCJpc1N0YXJ0ZWQiLCJjb25zb2xlIiwibG9nIiwic2V0SW50ZXJ2YWwiLCJsb2dTdGF0dXMiLCJlcnJvciIsInN0b3AiLCJnZXRTdGF0dXMiLCJ1cHRpbWUiLCJwcm9jZXNzIiwidW5kZWZpbmVkIiwic3RhdHVzIiwiaXNSdW5uaW5nIiwiTWF0aCIsInJvdW5kIiwiYmFja2dyb3VuZFdvcmtlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/background-worker.ts\n");

/***/ }),

/***/ "(rsc)/./lib/encryption.ts":
/*!***************************!*\
  !*** ./lib/encryption.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EncryptionService: () => (/* binding */ EncryptionService)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n/**\n * Simple encryption utility for securing sensitive data\n * Uses AES-256-CBC with proper IV handling\n */ class EncryptionService {\n    static{\n        this.ALGORITHM = 'aes-256-cbc';\n    }\n    static{\n        this.IV_LENGTH = 16;\n    }\n    static getEncryptionKey() {\n        const key = process.env.ENCRYPTION_KEY;\n        if (!key) {\n            throw new Error('ENCRYPTION_KEY environment variable is required');\n        }\n        if (key.length !== 32) {\n            throw new Error('ENCRYPTION_KEY must be exactly 32 characters long');\n        }\n        return Buffer.from(key, 'utf8');\n    }\n    /**\n   * Encrypt sensitive data\n   * Format: IV:EncryptedData\n   */ static encrypt(text) {\n        try {\n            const key = this.getEncryptionKey();\n            const iv = crypto__WEBPACK_IMPORTED_MODULE_0___default().randomBytes(this.IV_LENGTH);\n            const cipher = crypto__WEBPACK_IMPORTED_MODULE_0___default().createCipheriv(this.ALGORITHM, key, iv);\n            let encrypted = cipher.update(text, 'utf8', 'hex');\n            encrypted += cipher.final('hex');\n            return iv.toString('hex') + ':' + encrypted;\n        } catch (error) {\n            console.error('Encryption error:', error);\n            throw new Error('Failed to encrypt data');\n        }\n    }\n    /**\n   * Decrypt sensitive data\n   * Expects format: IV:EncryptedData\n   */ static decrypt(encryptedText) {\n        try {\n            console.log('🔓 DEBUG - Starting decryption process...');\n            console.log('- Input encrypted text length:', encryptedText.length);\n            console.log('- Input preview:', encryptedText.substring(0, 100) + '...');\n            const key = this.getEncryptionKey();\n            console.log('- Encryption key length:', key.length);\n            console.log('- Encryption key preview:', key.toString('hex').substring(0, 16) + '...');\n            const parts = encryptedText.split(':');\n            console.log('- Split parts count:', parts.length);\n            if (parts.length !== 2) {\n                console.error('❌ DEBUG - Invalid format, expected IV:EncryptedData but got', parts.length, 'parts');\n                throw new Error('Invalid encrypted data format - expected IV:EncryptedData');\n            }\n            console.log('- IV part (hex):', parts[0]);\n            console.log('- Encrypted data part length:', parts[1].length);\n            console.log('- Encrypted data preview:', parts[1].substring(0, 50) + '...');\n            const iv = Buffer.from(parts[0], 'hex');\n            console.log('- IV buffer length:', iv.length);\n            console.log('- IV buffer:', iv.toString('hex'));\n            const encryptedData = parts[1];\n            console.log('- Creating decipher with algorithm:', this.ALGORITHM);\n            const decipher = crypto__WEBPACK_IMPORTED_MODULE_0___default().createDecipheriv(this.ALGORITHM, key, iv);\n            console.log('- Updating decipher...');\n            let decrypted = decipher.update(encryptedData, 'hex', 'utf8');\n            console.log('- First update result length:', decrypted.length);\n            console.log('- Finalizing decipher...');\n            decrypted += decipher.final('utf8');\n            console.log('- Final decrypted length:', decrypted.length);\n            console.log('- Decrypted preview:', decrypted.substring(0, 100) + '...');\n            return decrypted;\n        } catch (error) {\n            console.error('❌ Decryption error details:', error);\n            console.error('- Error name:', error instanceof Error ? error.name : 'Unknown');\n            console.error('- Error message:', error instanceof Error ? error.message : String(error));\n            console.error('- Error stack:', error instanceof Error ? error.stack : 'No stack');\n            throw new Error('Failed to decrypt data');\n        }\n    }\n    /**\n   * Test if encrypted data can be decrypted with current key\n   */ static testDecryption(encryptedText) {\n        try {\n            this.decrypt(encryptedText);\n            return true;\n        } catch (error) {\n            return false;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE1BQU07WUFFN0RjLFFBQVFHLEdBQUcsQ0FBQztZQUNaTyxhQUFhRixTQUFTWCxLQUFLLENBQUM7WUFDNUJHLFFBQVFHLEdBQUcsQ0FBQyw2QkFBNkJPLFVBQVV4QixNQUFNO1lBQ3pEYyxRQUFRRyxHQUFHLENBQUMsd0JBQXdCTyxVQUFVTixTQUFTLENBQUMsR0FBRyxPQUFPO1lBRWxFLE9BQU9NO1FBQ1QsRUFBRSxPQUFPWCxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQywrQkFBK0JBO1lBQzdDQyxRQUFRRCxLQUFLLENBQUMsaUJBQWlCQSxpQkFBaUJkLFFBQVFjLE1BQU1ZLElBQUksR0FBRztZQUNyRVgsUUFBUUQsS0FBSyxDQUFDLG9CQUFvQkEsaUJBQWlCZCxRQUFRYyxNQUFNYSxPQUFPLEdBQUdDLE9BQU9kO1lBQ2xGQyxRQUFRRCxLQUFLLENBQUMsa0JBQWtCQSxpQkFBaUJkLFFBQVFjLE1BQU1lLEtBQUssR0FBRztZQUN2RSxNQUFNLElBQUk3QixNQUFNO1FBQ2xCO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELE9BQU84QixlQUFlYixhQUFxQixFQUFXO1FBQ3BELElBQUk7WUFDRixJQUFJLENBQUNELE9BQU8sQ0FBQ0M7WUFDYixPQUFPO1FBQ1QsRUFBRSxPQUFPSCxPQUFPO1lBQ2QsT0FBTztRQUNUO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9saWIvZW5jcnlwdGlvbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5cbi8qKlxuICogU2ltcGxlIGVuY3J5cHRpb24gdXRpbGl0eSBmb3Igc2VjdXJpbmcgc2Vuc2l0aXZlIGRhdGFcbiAqIFVzZXMgQUVTLTI1Ni1DQkMgd2l0aCBwcm9wZXIgSVYgaGFuZGxpbmdcbiAqL1xuZXhwb3J0IGNsYXNzIEVuY3J5cHRpb25TZXJ2aWNlIHtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQUxHT1JJVEhNID0gJ2Flcy0yNTYtY2JjJztcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgSVZfTEVOR1RIID0gMTY7XG4gIFxuICBwcml2YXRlIHN0YXRpYyBnZXRFbmNyeXB0aW9uS2V5KCk6IEJ1ZmZlciB7XG4gICAgY29uc3Qga2V5ID0gcHJvY2Vzcy5lbnYuRU5DUllQVElPTl9LRVk7XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRU5DUllQVElPTl9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKGtleS5sZW5ndGggIT09IDMyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VOQ1JZUFRJT05fS0VZIG11c3QgYmUgZXhhY3RseSAzMiBjaGFyYWN0ZXJzIGxvbmcnKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGtleSwgJ3V0ZjgnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNyeXB0IHNlbnNpdGl2ZSBkYXRhXG4gICAqIEZvcm1hdDogSVY6RW5jcnlwdGVkRGF0YVxuICAgKi9cbiAgc3RhdGljIGVuY3J5cHQodGV4dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qga2V5ID0gdGhpcy5nZXRFbmNyeXB0aW9uS2V5KCk7XG4gICAgICBjb25zdCBpdiA9IGNyeXB0by5yYW5kb21CeXRlcyh0aGlzLklWX0xFTkdUSCk7XG4gICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYodGhpcy5BTEdPUklUSE0sIGtleSwgaXYpO1xuICAgICAgXG4gICAgICBsZXQgZW5jcnlwdGVkID0gY2lwaGVyLnVwZGF0ZSh0ZXh0LCAndXRmOCcsICdoZXgnKTtcbiAgICAgIGVuY3J5cHRlZCArPSBjaXBoZXIuZmluYWwoJ2hleCcpO1xuICAgICAgXG4gICAgICByZXR1cm4gaXYudG9TdHJpbmcoJ2hleCcpICsgJzonICsgZW5jcnlwdGVkO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFbmNyeXB0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGVuY3J5cHQgZGF0YScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNyeXB0IHNlbnNpdGl2ZSBkYXRhXG4gICAqIEV4cGVjdHMgZm9ybWF0OiBJVjpFbmNyeXB0ZWREYXRhXG4gICAqL1xuICBzdGF0aWMgZGVjcnlwdChlbmNyeXB0ZWRUZXh0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+UkyBERUJVRyAtIFN0YXJ0aW5nIGRlY3J5cHRpb24gcHJvY2Vzcy4uLicpO1xuICAgICAgY29uc29sZS5sb2coJy0gSW5wdXQgZW5jcnlwdGVkIHRleHQgbGVuZ3RoOicsIGVuY3J5cHRlZFRleHQubGVuZ3RoKTtcbiAgICAgIGNvbnNvbGUubG9nKCctIElucHV0IHByZXZpZXc6JywgZW5jcnlwdGVkVGV4dC5zdWJzdHJpbmcoMCwgMTAwKSArICcuLi4nKTtcbiAgICAgIFxuICAgICAgY29uc3Qga2V5ID0gdGhpcy5nZXRFbmNyeXB0aW9uS2V5KCk7XG4gICAgICBjb25zb2xlLmxvZygnLSBFbmNyeXB0aW9uIGtleSBsZW5ndGg6Jywga2V5Lmxlbmd0aCk7XG4gICAgICBjb25zb2xlLmxvZygnLSBFbmNyeXB0aW9uIGtleSBwcmV2aWV3OicsIGtleS50b1N0cmluZygnaGV4Jykuc3Vic3RyaW5nKDAsIDE2KSArICcuLi4nKTtcbiAgICAgIFxuICAgICAgY29uc3QgcGFydHMgPSBlbmNyeXB0ZWRUZXh0LnNwbGl0KCc6Jyk7XG4gICAgICBjb25zb2xlLmxvZygnLSBTcGxpdCBwYXJ0cyBjb3VudDonLCBwYXJ0cy5sZW5ndGgpO1xuICAgICAgXG4gICAgICBpZiAocGFydHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBERUJVRyAtIEludmFsaWQgZm9ybWF0LCBleHBlY3RlZCBJVjpFbmNyeXB0ZWREYXRhIGJ1dCBnb3QnLCBwYXJ0cy5sZW5ndGgsICdwYXJ0cycpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW5jcnlwdGVkIGRhdGEgZm9ybWF0IC0gZXhwZWN0ZWQgSVY6RW5jcnlwdGVkRGF0YScpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnLSBJViBwYXJ0IChoZXgpOicsIHBhcnRzWzBdKTtcbiAgICAgIGNvbnNvbGUubG9nKCctIEVuY3J5cHRlZCBkYXRhIHBhcnQgbGVuZ3RoOicsIHBhcnRzWzFdLmxlbmd0aCk7XG4gICAgICBjb25zb2xlLmxvZygnLSBFbmNyeXB0ZWQgZGF0YSBwcmV2aWV3OicsIHBhcnRzWzFdLnN1YnN0cmluZygwLCA1MCkgKyAnLi4uJyk7XG4gICAgICBcbiAgICAgIGNvbnN0IGl2ID0gQnVmZmVyLmZyb20ocGFydHNbMF0sICdoZXgnKTtcbiAgICAgIGNvbnNvbGUubG9nKCctIElWIGJ1ZmZlciBsZW5ndGg6JywgaXYubGVuZ3RoKTtcbiAgICAgIGNvbnNvbGUubG9nKCctIElWIGJ1ZmZlcjonLCBpdi50b1N0cmluZygnaGV4JykpO1xuICAgICAgXG4gICAgICBjb25zdCBlbmNyeXB0ZWREYXRhID0gcGFydHNbMV07XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCctIENyZWF0aW5nIGRlY2lwaGVyIHdpdGggYWxnb3JpdGhtOicsIHRoaXMuQUxHT1JJVEhNKTtcbiAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYodGhpcy5BTEdPUklUSE0sIGtleSwgaXYpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnLSBVcGRhdGluZyBkZWNpcGhlci4uLicpO1xuICAgICAgbGV0IGRlY3J5cHRlZCA9IGRlY2lwaGVyLnVwZGF0ZShlbmNyeXB0ZWREYXRhLCAnaGV4JywgJ3V0ZjgnKTtcbiAgICAgIGNvbnNvbGUubG9nKCctIEZpcnN0IHVwZGF0ZSByZXN1bHQgbGVuZ3RoOicsIGRlY3J5cHRlZC5sZW5ndGgpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnLSBGaW5hbGl6aW5nIGRlY2lwaGVyLi4uJyk7XG4gICAgICBkZWNyeXB0ZWQgKz0gZGVjaXBoZXIuZmluYWwoJ3V0ZjgnKTtcbiAgICAgIGNvbnNvbGUubG9nKCctIEZpbmFsIGRlY3J5cHRlZCBsZW5ndGg6JywgZGVjcnlwdGVkLmxlbmd0aCk7XG4gICAgICBjb25zb2xlLmxvZygnLSBEZWNyeXB0ZWQgcHJldmlldzonLCBkZWNyeXB0ZWQuc3Vic3RyaW5nKDAsIDEwMCkgKyAnLi4uJyk7XG4gICAgICBcbiAgICAgIHJldHVybiBkZWNyeXB0ZWQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBEZWNyeXB0aW9uIGVycm9yIGRldGFpbHM6JywgZXJyb3IpO1xuICAgICAgY29uc29sZS5lcnJvcignLSBFcnJvciBuYW1lOicsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5uYW1lIDogJ1Vua25vd24nKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJy0gRXJyb3IgbWVzc2FnZTonLCBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcikpO1xuICAgICAgY29uc29sZS5lcnJvcignLSBFcnJvciBzdGFjazonLCBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3Iuc3RhY2sgOiAnTm8gc3RhY2snKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRlY3J5cHQgZGF0YScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0IGlmIGVuY3J5cHRlZCBkYXRhIGNhbiBiZSBkZWNyeXB0ZWQgd2l0aCBjdXJyZW50IGtleVxuICAgKi9cbiAgc3RhdGljIHRlc3REZWNyeXB0aW9uKGVuY3J5cHRlZFRleHQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmRlY3J5cHQoZW5jcnlwdGVkVGV4dCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSJdLCJuYW1lcyI6WyJjcnlwdG8iLCJFbmNyeXB0aW9uU2VydmljZSIsIkFMR09SSVRITSIsIklWX0xFTkdUSCIsImdldEVuY3J5cHRpb25LZXkiLCJrZXkiLCJwcm9jZXNzIiwiZW52IiwiRU5DUllQVElPTl9LRVkiLCJFcnJvciIsImxlbmd0aCIsIkJ1ZmZlciIsImZyb20iLCJlbmNyeXB0IiwidGV4dCIsIml2IiwicmFuZG9tQnl0ZXMiLCJjaXBoZXIiLCJjcmVhdGVDaXBoZXJpdiIsImVuY3J5cHRlZCIsInVwZGF0ZSIsImZpbmFsIiwidG9TdHJpbmciLCJlcnJvciIsImNvbnNvbGUiLCJkZWNyeXB0IiwiZW5jcnlwdGVkVGV4dCIsImxvZyIsInN1YnN0cmluZyIsInBhcnRzIiwic3BsaXQiLCJlbmNyeXB0ZWREYXRhIiwiZGVjaXBoZXIiLCJjcmVhdGVEZWNpcGhlcml2IiwiZGVjcnlwdGVkIiwibmFtZSIsIm1lc3NhZ2UiLCJTdHJpbmciLCJzdGFjayIsInRlc3REZWNyeXB0aW9uIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/encryption.ts\n");

/***/ }),

/***/ "(rsc)/./lib/google-auth-service.ts":
/*!************************************!*\
  !*** ./lib/google-auth-service.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GoogleAuthService: () => (/* binding */ GoogleAuthService)\n/* harmony export */ });\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase */ \"(rsc)/./lib/supabase.ts\");\n/* harmony import */ var _encryption__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./encryption */ \"(rsc)/./lib/encryption.ts\");\n/* harmony import */ var google_auth_library__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! google-auth-library */ \"(rsc)/./node_modules/google-auth-library/build/src/index.js\");\n\n\n\n/**\n * Google Authentication Service\n * \n * Handles the complete Google API authentication workflow:\n * 1. Decrypt service account credentials from database\n * 2. Generate JWT tokens using service account private key\n * 3. Exchange JWT for access tokens with Google's token endpoint\n * 4. Cache encrypted access tokens in database with expiration\n * 5. Manage token refresh and quota tracking\n */ class GoogleAuthService {\n    static{\n        this.INDEXING_SCOPE = 'https://www.googleapis.com/auth/indexing';\n    }\n    static{\n        this.TOKEN_EXPIRY_BUFFER = 5 * 60 * 1000; // 5 minutes buffer\n    }\n    static getInstance() {\n        if (!GoogleAuthService.instance) {\n            GoogleAuthService.instance = new GoogleAuthService();\n        }\n        return GoogleAuthService.instance;\n    }\n    /**\n   * Get a valid access token for Google API calls\n   * First checks cached token in database, then generates new one if needed\n   */ async getAccessToken(serviceAccountId) {\n        try {\n            console.log(`🔑 Getting access token for service account: ${serviceAccountId}`);\n            // Get service account from database\n            const { data: serviceAccount, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_google_service_accounts').select('*').eq('id', serviceAccountId).single();\n            if (error || !serviceAccount) {\n                console.error('Service account not found:', error);\n                return null;\n            }\n            // DEBUG: Log encrypted data info\n            console.log('🔍 DEBUG - Service Account Data:');\n            console.log('- ID:', serviceAccount.id);\n            console.log('- Name:', serviceAccount.name);\n            console.log('- Email:', serviceAccount.email);\n            console.log('- Is Active:', serviceAccount.is_active);\n            console.log('- Encrypted Credentials Length:', serviceAccount.encrypted_credentials?.length || 0);\n            console.log('- Encrypted Credentials Preview:', serviceAccount.encrypted_credentials?.substring(0, 100) + '...');\n            console.log('- Current ENCRYPTION_KEY:', process.env.ENCRYPTION_KEY?.substring(0, 8) + '...');\n            // Check format\n            const parts = serviceAccount.encrypted_credentials?.split(':');\n            console.log('- Encrypted Format Parts:', parts?.length || 0);\n            if (parts && parts.length === 2) {\n                console.log('- IV Length (hex):', parts[0].length);\n                console.log('- Encrypted Data Length (hex):', parts[1].length);\n                console.log('- IV (first 16 chars):', parts[0].substring(0, 16));\n                console.log('- Encrypted Data (first 32 chars):', parts[1].substring(0, 32));\n            }\n            // Check if we have a valid cached token\n            const cachedToken = await this.getCachedAccessToken(serviceAccount);\n            if (cachedToken) {\n                console.log('✅ Using cached access token');\n                return cachedToken;\n            }\n            // Generate new access token\n            console.log('🔄 Generating new access token');\n            const newToken = await this.generateNewAccessToken(serviceAccount);\n            if (newToken) {\n                // Cache the new token in database\n                await this.cacheAccessToken(serviceAccountId, newToken);\n                console.log('✅ New access token generated and cached');\n                return newToken.access_token;\n            }\n            return null;\n        } catch (error) {\n            console.error('Error getting access token:', error);\n            return null;\n        }\n    }\n    /**\n   * Get available service account for a user\n   */ async getAvailableServiceAccount(userId) {\n        try {\n            const { data: accounts, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_google_service_accounts').select('*').eq('user_id', userId).eq('is_active', true).limit(1);\n            if (error || !accounts?.length) {\n                console.log('No active service accounts found for user:', userId);\n                return null;\n            }\n            return accounts[0];\n        } catch (error) {\n            console.error('Error getting service account:', error);\n            return null;\n        }\n    }\n    /**\n   * Check if we have a valid cached access token\n   */ async getCachedAccessToken(serviceAccount) {\n        try {\n            if (!serviceAccount.encrypted_access_token || !serviceAccount.access_token_expires_at) {\n                return null;\n            }\n            const expiresAt = new Date(serviceAccount.access_token_expires_at).getTime();\n            const now = Date.now();\n            // Check if token is still valid (with buffer)\n            if (expiresAt <= now + GoogleAuthService.TOKEN_EXPIRY_BUFFER) {\n                console.log('Cached token expired or expiring soon');\n                return null;\n            }\n            // Decrypt and return cached token\n            const accessToken = _encryption__WEBPACK_IMPORTED_MODULE_1__.EncryptionService.decrypt(serviceAccount.encrypted_access_token);\n            return accessToken;\n        } catch (error) {\n            console.error('Error checking cached token:', error);\n            return null;\n        }\n    }\n    /**\n   * Generate new access token using service account credentials\n   */ async generateNewAccessToken(serviceAccount) {\n        try {\n            console.log('🔄 Starting generateNewAccessToken process...');\n            // Check if credentials are empty \n            if (!serviceAccount.encrypted_credentials || serviceAccount.encrypted_credentials.trim() === '') {\n                console.log('⚠️ Service account has no encrypted credentials. Skipping...');\n                return null;\n            }\n            console.log('🔐 DEBUG - About to decrypt credentials...');\n            console.log('- Encrypted data length:', serviceAccount.encrypted_credentials.length);\n            console.log('- Encrypted data to decrypt:', serviceAccount.encrypted_credentials.substring(0, 100) + '...');\n            // Decrypt service account credentials - FORCE DECRYPTION ATTEMPT\n            let credentialsJson;\n            try {\n                console.log('🔓 FORCING DECRYPTION ATTEMPT...');\n                credentialsJson = _encryption__WEBPACK_IMPORTED_MODULE_1__.EncryptionService.decrypt(serviceAccount.encrypted_credentials);\n                console.log('✅ DEBUG - DECRYPTION SUCCESSFUL!');\n                console.log('- Decrypted JSON length:', credentialsJson.length);\n                console.log('- Decrypted JSON preview (first 500 chars):', credentialsJson.substring(0, 500));\n                console.log('- Full decrypted JSON:', credentialsJson);\n            } catch (decryptError) {\n                console.error('❌ DEBUG - DECRYPTION FAILED:', decryptError);\n                console.error('- Error type:', decryptError instanceof Error ? decryptError.name : typeof decryptError);\n                console.error('- Error message:', decryptError instanceof Error ? decryptError.message : String(decryptError));\n                console.error('- Error stack:', decryptError instanceof Error ? decryptError.stack : 'No stack');\n                // DO NOT CLEAR ANYTHING - just fail and show the error\n                throw decryptError;\n            }\n            console.log('📋 DEBUG - Parsing JSON credentials...');\n            let credentials;\n            try {\n                credentials = JSON.parse(credentialsJson);\n                console.log('✅ DEBUG - JSON parsing successful!');\n                console.log('- Service account type:', credentials.type);\n                console.log('- Project ID:', credentials.project_id);\n                console.log('- Client email:', credentials.client_email);\n                console.log('- Private key preview:', credentials.private_key?.substring(0, 50) + '...');\n            } catch (parseError) {\n                console.error('❌ DEBUG - JSON parsing failed:', parseError);\n                console.error('- Raw decrypted data:', credentialsJson);\n                throw parseError;\n            }\n            console.log('🔐 DEBUG - Creating JWT with service account credentials...');\n            console.log('- Email for JWT:', credentials.client_email);\n            console.log('- Private key starts with:', credentials.private_key?.substring(0, 30));\n            console.log('- Scopes:', [\n                GoogleAuthService.INDEXING_SCOPE\n            ]);\n            // Create JWT client\n            let jwtClient;\n            try {\n                jwtClient = new google_auth_library__WEBPACK_IMPORTED_MODULE_2__.JWT({\n                    email: credentials.client_email,\n                    key: credentials.private_key,\n                    scopes: [\n                        GoogleAuthService.INDEXING_SCOPE\n                    ]\n                });\n                console.log('✅ DEBUG - JWT client created successfully');\n            } catch (jwtError) {\n                console.error('❌ DEBUG - JWT client creation failed:', jwtError);\n                throw jwtError;\n            }\n            console.log('🌐 DEBUG - Requesting access token from Google...');\n            // Get access token\n            let tokenResponse;\n            try {\n                tokenResponse = await jwtClient.authorize();\n                console.log('✅ DEBUG - Google authorization successful!');\n                console.log('- Token type:', typeof tokenResponse.access_token);\n                console.log('- Token length:', tokenResponse.access_token?.length || 0);\n                console.log('- Token preview:', tokenResponse.access_token?.substring(0, 20) + '...');\n                console.log('- Expires in:', tokenResponse.expiry_date);\n            } catch (authError) {\n                console.error('❌ DEBUG - Google authorization failed:', authError);\n                console.error('- Error details:', authError instanceof Error ? authError.message : String(authError));\n                throw authError;\n            }\n            if (!tokenResponse.access_token) {\n                console.error('❌ DEBUG - No access token received from Google');\n                console.error('- Response:', tokenResponse);\n                throw new Error('No access token received from Google');\n            }\n            console.log('✅ Successfully obtained access token from Google');\n            return {\n                access_token: tokenResponse.access_token,\n                expires_in: 3600 // Google tokens typically expire in 1 hour\n            };\n        } catch (error) {\n            console.error('Error generating access token:', error);\n            return null;\n        }\n    }\n    /**\n   * Cache encrypted access token in database\n   */ async cacheAccessToken(serviceAccountId, tokenData) {\n        try {\n            // Encrypt access token\n            const encryptedToken = _encryption__WEBPACK_IMPORTED_MODULE_1__.EncryptionService.encrypt(tokenData.access_token);\n            // Calculate expiration time (with some buffer)\n            const expiresAt = new Date(Date.now() + tokenData.expires_in * 1000 - GoogleAuthService.TOKEN_EXPIRY_BUFFER);\n            // Update service account with cached token\n            const { error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_google_service_accounts').update({\n                encrypted_access_token: encryptedToken,\n                access_token_expires_at: expiresAt.toISOString(),\n                updated_at: new Date().toISOString()\n            }).eq('id', serviceAccountId);\n            if (error) {\n                console.error('Error caching access token:', error);\n            } else {\n                console.log('✅ Access token cached in database');\n            }\n        } catch (error) {\n            console.error('Error caching access token:', error);\n        }\n    }\n    /**\n   * Validate service account credentials format\n   */ static validateServiceAccountCredentials(credentialsJson) {\n        try {\n            const credentials = JSON.parse(credentialsJson);\n            const requiredFields = [\n                'type',\n                'project_id',\n                'private_key_id',\n                'private_key',\n                'client_email',\n                'client_id',\n                'auth_uri',\n                'token_uri'\n            ];\n            return requiredFields.every((field)=>credentials[field]);\n        } catch (error) {\n            return false;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvZ29vZ2xlLWF1dGgtc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTJDO0FBQ007QUFDUDtBQTBCMUM7Ozs7Ozs7OztDQVNDLEdBQ00sTUFBTUc7O2FBRWFDLGlCQUFpQjs7O2FBQ2pCQyxzQkFBc0IsSUFBSSxLQUFLLE1BQU0sbUJBQW1COztJQUVoRixPQUFPQyxjQUFpQztRQUN0QyxJQUFJLENBQUNILGtCQUFrQkksUUFBUSxFQUFFO1lBQy9CSixrQkFBa0JJLFFBQVEsR0FBRyxJQUFJSjtRQUNuQztRQUNBLE9BQU9BLGtCQUFrQkksUUFBUTtJQUNuQztJQUVBOzs7R0FHQyxHQUNELE1BQU1DLGVBQWVDLGdCQUF3QixFQUEwQjtRQUNyRSxJQUFJO1lBQ0ZDLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLDZDQUE2QyxFQUFFRixrQkFBa0I7WUFFOUUsb0NBQW9DO1lBQ3BDLE1BQU0sRUFBRUcsTUFBTUMsY0FBYyxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNZCxvREFBYUEsQ0FDeERlLElBQUksQ0FBQyxnQ0FDTEMsTUFBTSxDQUFDLEtBQ1BDLEVBQUUsQ0FBQyxNQUFNUixrQkFDVFMsTUFBTTtZQUVULElBQUlKLFNBQVMsQ0FBQ0QsZ0JBQWdCO2dCQUM1QkgsUUFBUUksS0FBSyxDQUFDLDhCQUE4QkE7Z0JBQzVDLE9BQU87WUFDVDtZQUVBLGlDQUFpQztZQUNqQ0osUUFBUUMsR0FBRyxDQUFDO1lBQ1pELFFBQVFDLEdBQUcsQ0FBQyxTQUFTRSxlQUFlTSxFQUFFO1lBQ3RDVCxRQUFRQyxHQUFHLENBQUMsV0FBV0UsZUFBZU8sSUFBSTtZQUMxQ1YsUUFBUUMsR0FBRyxDQUFDLFlBQVlFLGVBQWVRLEtBQUs7WUFDNUNYLFFBQVFDLEdBQUcsQ0FBQyxnQkFBZ0JFLGVBQWVTLFNBQVM7WUFDcERaLFFBQVFDLEdBQUcsQ0FBQyxtQ0FBbUNFLGVBQWVVLHFCQUFxQixFQUFFQyxVQUFVO1lBQy9GZCxRQUFRQyxHQUFHLENBQUMsb0NBQW9DRSxlQUFlVSxxQkFBcUIsRUFBRUUsVUFBVSxHQUFHLE9BQU87WUFDMUdmLFFBQVFDLEdBQUcsQ0FBQyw2QkFBNkJlLFFBQVFDLEdBQUcsQ0FBQ0MsY0FBYyxFQUFFSCxVQUFVLEdBQUcsS0FBSztZQUV2RixlQUFlO1lBQ2YsTUFBTUksUUFBUWhCLGVBQWVVLHFCQUFxQixFQUFFTyxNQUFNO1lBQzFEcEIsUUFBUUMsR0FBRyxDQUFDLDZCQUE2QmtCLE9BQU9MLFVBQVU7WUFDMUQsSUFBSUssU0FBU0EsTUFBTUwsTUFBTSxLQUFLLEdBQUc7Z0JBQy9CZCxRQUFRQyxHQUFHLENBQUMsc0JBQXNCa0IsS0FBSyxDQUFDLEVBQUUsQ0FBQ0wsTUFBTTtnQkFDakRkLFFBQVFDLEdBQUcsQ0FBQyxrQ0FBa0NrQixLQUFLLENBQUMsRUFBRSxDQUFDTCxNQUFNO2dCQUM3RGQsUUFBUUMsR0FBRyxDQUFDLDBCQUEwQmtCLEtBQUssQ0FBQyxFQUFFLENBQUNKLFNBQVMsQ0FBQyxHQUFHO2dCQUM1RGYsUUFBUUMsR0FBRyxDQUFDLHNDQUFzQ2tCLEtBQUssQ0FBQyxFQUFFLENBQUNKLFNBQVMsQ0FBQyxHQUFHO1lBQzFFO1lBRUEsd0NBQXdDO1lBQ3hDLE1BQU1NLGNBQWMsTUFBTSxJQUFJLENBQUNDLG9CQUFvQixDQUFDbkI7WUFDcEQsSUFBSWtCLGFBQWE7Z0JBQ2ZyQixRQUFRQyxHQUFHLENBQUM7Z0JBQ1osT0FBT29CO1lBQ1Q7WUFFQSw0QkFBNEI7WUFDNUJyQixRQUFRQyxHQUFHLENBQUM7WUFDWixNQUFNc0IsV0FBVyxNQUFNLElBQUksQ0FBQ0Msc0JBQXNCLENBQUNyQjtZQUVuRCxJQUFJb0IsVUFBVTtnQkFDWixrQ0FBa0M7Z0JBQ2xDLE1BQU0sSUFBSSxDQUFDRSxnQkFBZ0IsQ0FBQzFCLGtCQUFrQndCO2dCQUM5Q3ZCLFFBQVFDLEdBQUcsQ0FBQztnQkFDWixPQUFPc0IsU0FBU0csWUFBWTtZQUM5QjtZQUVBLE9BQU87UUFDVCxFQUFFLE9BQU90QixPQUFPO1lBQ2RKLFFBQVFJLEtBQUssQ0FBQywrQkFBK0JBO1lBQzdDLE9BQU87UUFDVDtJQUNGO0lBRUE7O0dBRUMsR0FDRCxNQUFNdUIsMkJBQTJCQyxNQUFjLEVBQWtDO1FBQy9FLElBQUk7WUFDRixNQUFNLEVBQUUxQixNQUFNMkIsUUFBUSxFQUFFekIsS0FBSyxFQUFFLEdBQUcsTUFBTWQsb0RBQWFBLENBQ2xEZSxJQUFJLENBQUMsZ0NBQ0xDLE1BQU0sQ0FBQyxLQUNQQyxFQUFFLENBQUMsV0FBV3FCLFFBQ2RyQixFQUFFLENBQUMsYUFBYSxNQUNoQnVCLEtBQUssQ0FBQztZQUVULElBQUkxQixTQUFTLENBQUN5QixVQUFVZixRQUFRO2dCQUM5QmQsUUFBUUMsR0FBRyxDQUFDLDhDQUE4QzJCO2dCQUMxRCxPQUFPO1lBQ1Q7WUFFQSxPQUFPQyxRQUFRLENBQUMsRUFBRTtRQUNwQixFQUFFLE9BQU96QixPQUFPO1lBQ2RKLFFBQVFJLEtBQUssQ0FBQyxrQ0FBa0NBO1lBQ2hELE9BQU87UUFDVDtJQUNGO0lBRUE7O0dBRUMsR0FDRCxNQUFja0IscUJBQXFCbkIsY0FBOEIsRUFBMEI7UUFDekYsSUFBSTtZQUNGLElBQUksQ0FBQ0EsZUFBZTRCLHNCQUFzQixJQUFJLENBQUM1QixlQUFlNkIsdUJBQXVCLEVBQUU7Z0JBQ3JGLE9BQU87WUFDVDtZQUVBLE1BQU1DLFlBQVksSUFBSUMsS0FBSy9CLGVBQWU2Qix1QkFBdUIsRUFBRUcsT0FBTztZQUMxRSxNQUFNQyxNQUFNRixLQUFLRSxHQUFHO1lBRXBCLDhDQUE4QztZQUM5QyxJQUFJSCxhQUFhRyxNQUFNM0Msa0JBQWtCRSxtQkFBbUIsRUFBRTtnQkFDNURLLFFBQVFDLEdBQUcsQ0FBQztnQkFDWixPQUFPO1lBQ1Q7WUFFQSxrQ0FBa0M7WUFDbEMsTUFBTW9DLGNBQWM5QywwREFBaUJBLENBQUMrQyxPQUFPLENBQUNuQyxlQUFlNEIsc0JBQXNCO1lBQ25GLE9BQU9NO1FBQ1QsRUFBRSxPQUFPakMsT0FBTztZQUNkSixRQUFRSSxLQUFLLENBQUMsZ0NBQWdDQTtZQUM5QyxPQUFPO1FBQ1Q7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBY29CLHVCQUF1QnJCLGNBQThCLEVBQWdFO1FBQ2pJLElBQUk7WUFDRkgsUUFBUUMsR0FBRyxDQUFDO1lBRVosa0NBQWtDO1lBQ2xDLElBQUksQ0FBQ0UsZUFBZVUscUJBQXFCLElBQUlWLGVBQWVVLHFCQUFxQixDQUFDMEIsSUFBSSxPQUFPLElBQUk7Z0JBQy9GdkMsUUFBUUMsR0FBRyxDQUFDO2dCQUNaLE9BQU87WUFDVDtZQUVBRCxRQUFRQyxHQUFHLENBQUM7WUFDWkQsUUFBUUMsR0FBRyxDQUFDLDRCQUE0QkUsZUFBZVUscUJBQXFCLENBQUNDLE1BQU07WUFDbkZkLFFBQVFDLEdBQUcsQ0FBQyxnQ0FBZ0NFLGVBQWVVLHFCQUFxQixDQUFDRSxTQUFTLENBQUMsR0FBRyxPQUFPO1lBRXJHLGlFQUFpRTtZQUNqRSxJQUFJeUI7WUFDSixJQUFJO2dCQUNGeEMsUUFBUUMsR0FBRyxDQUFDO2dCQUNadUMsa0JBQWtCakQsMERBQWlCQSxDQUFDK0MsT0FBTyxDQUFDbkMsZUFBZVUscUJBQXFCO2dCQUNoRmIsUUFBUUMsR0FBRyxDQUFDO2dCQUNaRCxRQUFRQyxHQUFHLENBQUMsNEJBQTRCdUMsZ0JBQWdCMUIsTUFBTTtnQkFDOURkLFFBQVFDLEdBQUcsQ0FBQywrQ0FBK0N1QyxnQkFBZ0J6QixTQUFTLENBQUMsR0FBRztnQkFDeEZmLFFBQVFDLEdBQUcsQ0FBQywwQkFBMEJ1QztZQUN4QyxFQUFFLE9BQU9DLGNBQWM7Z0JBQ3JCekMsUUFBUUksS0FBSyxDQUFDLGdDQUFnQ3FDO2dCQUM5Q3pDLFFBQVFJLEtBQUssQ0FBQyxpQkFBaUJxQyx3QkFBd0JDLFFBQVFELGFBQWEvQixJQUFJLEdBQUcsT0FBTytCO2dCQUMxRnpDLFFBQVFJLEtBQUssQ0FBQyxvQkFBb0JxQyx3QkFBd0JDLFFBQVFELGFBQWFFLE9BQU8sR0FBR0MsT0FBT0g7Z0JBQ2hHekMsUUFBUUksS0FBSyxDQUFDLGtCQUFrQnFDLHdCQUF3QkMsUUFBUUQsYUFBYUksS0FBSyxHQUFHO2dCQUVyRix1REFBdUQ7Z0JBQ3ZELE1BQU1KO1lBQ1I7WUFFQXpDLFFBQVFDLEdBQUcsQ0FBQztZQUNaLElBQUk2QztZQUNKLElBQUk7Z0JBQ0ZBLGNBQWNDLEtBQUtDLEtBQUssQ0FBQ1I7Z0JBQ3pCeEMsUUFBUUMsR0FBRyxDQUFDO2dCQUNaRCxRQUFRQyxHQUFHLENBQUMsMkJBQTJCNkMsWUFBWUcsSUFBSTtnQkFDdkRqRCxRQUFRQyxHQUFHLENBQUMsaUJBQWlCNkMsWUFBWUksVUFBVTtnQkFDbkRsRCxRQUFRQyxHQUFHLENBQUMsbUJBQW1CNkMsWUFBWUssWUFBWTtnQkFDdkRuRCxRQUFRQyxHQUFHLENBQUMsMEJBQTBCNkMsWUFBWU0sV0FBVyxFQUFFckMsVUFBVSxHQUFHLE1BQU07WUFDcEYsRUFBRSxPQUFPc0MsWUFBWTtnQkFDbkJyRCxRQUFRSSxLQUFLLENBQUMsa0NBQWtDaUQ7Z0JBQ2hEckQsUUFBUUksS0FBSyxDQUFDLHlCQUF5Qm9DO2dCQUN2QyxNQUFNYTtZQUNSO1lBRUFyRCxRQUFRQyxHQUFHLENBQUM7WUFDWkQsUUFBUUMsR0FBRyxDQUFDLG9CQUFvQjZDLFlBQVlLLFlBQVk7WUFDeERuRCxRQUFRQyxHQUFHLENBQUMsOEJBQThCNkMsWUFBWU0sV0FBVyxFQUFFckMsVUFBVSxHQUFHO1lBQ2hGZixRQUFRQyxHQUFHLENBQUMsYUFBYTtnQkFBQ1Isa0JBQWtCQyxjQUFjO2FBQUM7WUFFM0Qsb0JBQW9CO1lBQ3BCLElBQUk0RDtZQUNKLElBQUk7Z0JBQ0ZBLFlBQVksSUFBSTlELG9EQUFHQSxDQUFDO29CQUNsQm1CLE9BQU9tQyxZQUFZSyxZQUFZO29CQUMvQkksS0FBS1QsWUFBWU0sV0FBVztvQkFDNUJJLFFBQVE7d0JBQUMvRCxrQkFBa0JDLGNBQWM7cUJBQUM7Z0JBQzVDO2dCQUNBTSxRQUFRQyxHQUFHLENBQUM7WUFDZCxFQUFFLE9BQU93RCxVQUFVO2dCQUNqQnpELFFBQVFJLEtBQUssQ0FBQyx5Q0FBeUNxRDtnQkFDdkQsTUFBTUE7WUFDUjtZQUVBekQsUUFBUUMsR0FBRyxDQUFDO1lBQ1osbUJBQW1CO1lBQ25CLElBQUl5RDtZQUNKLElBQUk7Z0JBQ0ZBLGdCQUFnQixNQUFNSixVQUFVSyxTQUFTO2dCQUN6QzNELFFBQVFDLEdBQUcsQ0FBQztnQkFDWkQsUUFBUUMsR0FBRyxDQUFDLGlCQUFpQixPQUFPeUQsY0FBY2hDLFlBQVk7Z0JBQzlEMUIsUUFBUUMsR0FBRyxDQUFDLG1CQUFtQnlELGNBQWNoQyxZQUFZLEVBQUVaLFVBQVU7Z0JBQ3JFZCxRQUFRQyxHQUFHLENBQUMsb0JBQW9CeUQsY0FBY2hDLFlBQVksRUFBRVgsVUFBVSxHQUFHLE1BQU07Z0JBQy9FZixRQUFRQyxHQUFHLENBQUMsaUJBQWlCeUQsY0FBY0UsV0FBVztZQUN4RCxFQUFFLE9BQU9DLFdBQVc7Z0JBQ2xCN0QsUUFBUUksS0FBSyxDQUFDLDBDQUEwQ3lEO2dCQUN4RDdELFFBQVFJLEtBQUssQ0FBQyxvQkFBb0J5RCxxQkFBcUJuQixRQUFRbUIsVUFBVWxCLE9BQU8sR0FBR0MsT0FBT2lCO2dCQUMxRixNQUFNQTtZQUNSO1lBRUEsSUFBSSxDQUFDSCxjQUFjaEMsWUFBWSxFQUFFO2dCQUMvQjFCLFFBQVFJLEtBQUssQ0FBQztnQkFDZEosUUFBUUksS0FBSyxDQUFDLGVBQWVzRDtnQkFDN0IsTUFBTSxJQUFJaEIsTUFBTTtZQUNsQjtZQUVBMUMsUUFBUUMsR0FBRyxDQUFDO1lBRVosT0FBTztnQkFDTHlCLGNBQWNnQyxjQUFjaEMsWUFBWTtnQkFDeENvQyxZQUFZLEtBQUssMkNBQTJDO1lBQzlEO1FBRUYsRUFBRSxPQUFPMUQsT0FBTztZQUNkSixRQUFRSSxLQUFLLENBQUMsa0NBQWtDQTtZQUNoRCxPQUFPO1FBQ1Q7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBY3FCLGlCQUFpQjFCLGdCQUF3QixFQUFFZ0UsU0FBdUQsRUFBaUI7UUFDL0gsSUFBSTtZQUNGLHVCQUF1QjtZQUN2QixNQUFNQyxpQkFBaUJ6RSwwREFBaUJBLENBQUMwRSxPQUFPLENBQUNGLFVBQVVyQyxZQUFZO1lBRXZFLCtDQUErQztZQUMvQyxNQUFNTyxZQUFZLElBQUlDLEtBQUtBLEtBQUtFLEdBQUcsS0FBTTJCLFVBQVVELFVBQVUsR0FBRyxPQUFRckUsa0JBQWtCRSxtQkFBbUI7WUFFN0csMkNBQTJDO1lBQzNDLE1BQU0sRUFBRVMsS0FBSyxFQUFFLEdBQUcsTUFBTWQsb0RBQWFBLENBQ2xDZSxJQUFJLENBQUMsZ0NBQ0w2RCxNQUFNLENBQUM7Z0JBQ05uQyx3QkFBd0JpQztnQkFDeEJoQyx5QkFBeUJDLFVBQVVrQyxXQUFXO2dCQUM5Q0MsWUFBWSxJQUFJbEMsT0FBT2lDLFdBQVc7WUFDcEMsR0FDQzVELEVBQUUsQ0FBQyxNQUFNUjtZQUVaLElBQUlLLE9BQU87Z0JBQ1RKLFFBQVFJLEtBQUssQ0FBQywrQkFBK0JBO1lBQy9DLE9BQU87Z0JBQ0xKLFFBQVFDLEdBQUcsQ0FBQztZQUNkO1FBQ0YsRUFBRSxPQUFPRyxPQUFPO1lBQ2RKLFFBQVFJLEtBQUssQ0FBQywrQkFBK0JBO1FBQy9DO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELE9BQU9pRSxrQ0FBa0M3QixlQUF1QixFQUFXO1FBQ3pFLElBQUk7WUFDRixNQUFNTSxjQUFjQyxLQUFLQyxLQUFLLENBQUNSO1lBQy9CLE1BQU04QixpQkFBaUI7Z0JBQ3JCO2dCQUFRO2dCQUFjO2dCQUFrQjtnQkFDeEM7Z0JBQWdCO2dCQUFhO2dCQUFZO2FBQzFDO1lBRUQsT0FBT0EsZUFBZUMsS0FBSyxDQUFDQyxDQUFBQSxRQUFTMUIsV0FBVyxDQUFDMEIsTUFBTTtRQUN6RCxFQUFFLE9BQU9wRSxPQUFPO1lBQ2QsT0FBTztRQUNUO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9saWIvZ29vZ2xlLWF1dGgtc2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdXBhYmFzZUFkbWluIH0gZnJvbSAnLi9zdXBhYmFzZSc7XG5pbXBvcnQgeyBFbmNyeXB0aW9uU2VydmljZSB9IGZyb20gJy4vZW5jcnlwdGlvbic7XG5pbXBvcnQgeyBKV1QgfSBmcm9tICdnb29nbGUtYXV0aC1saWJyYXJ5JztcblxuZXhwb3J0IGludGVyZmFjZSBTZXJ2aWNlQWNjb3VudCB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgZW1haWw6IHN0cmluZztcbiAgZW5jcnlwdGVkX2NyZWRlbnRpYWxzOiBzdHJpbmc7XG4gIGRhaWx5X3F1b3RhX2xpbWl0OiBudW1iZXI7XG4gIG1pbnV0ZV9xdW90YV9saW1pdDogbnVtYmVyO1xuICBlbmNyeXB0ZWRfYWNjZXNzX3Rva2VuPzogc3RyaW5nO1xuICBhY2Nlc3NfdG9rZW5fZXhwaXJlc19hdD86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFNlcnZpY2VBY2NvdW50Q3JlZGVudGlhbHMge1xuICB0eXBlOiBzdHJpbmc7XG4gIHByb2plY3RfaWQ6IHN0cmluZztcbiAgcHJpdmF0ZV9rZXlfaWQ6IHN0cmluZztcbiAgcHJpdmF0ZV9rZXk6IHN0cmluZztcbiAgY2xpZW50X2VtYWlsOiBzdHJpbmc7XG4gIGNsaWVudF9pZDogc3RyaW5nO1xuICBhdXRoX3VyaTogc3RyaW5nO1xuICB0b2tlbl91cmk6IHN0cmluZztcbiAgYXV0aF9wcm92aWRlcl94NTA5X2NlcnRfdXJsOiBzdHJpbmc7XG4gIGNsaWVudF94NTA5X2NlcnRfdXJsOiBzdHJpbmc7XG59XG5cbi8qKlxuICogR29vZ2xlIEF1dGhlbnRpY2F0aW9uIFNlcnZpY2VcbiAqIFxuICogSGFuZGxlcyB0aGUgY29tcGxldGUgR29vZ2xlIEFQSSBhdXRoZW50aWNhdGlvbiB3b3JrZmxvdzpcbiAqIDEuIERlY3J5cHQgc2VydmljZSBhY2NvdW50IGNyZWRlbnRpYWxzIGZyb20gZGF0YWJhc2VcbiAqIDIuIEdlbmVyYXRlIEpXVCB0b2tlbnMgdXNpbmcgc2VydmljZSBhY2NvdW50IHByaXZhdGUga2V5XG4gKiAzLiBFeGNoYW5nZSBKV1QgZm9yIGFjY2VzcyB0b2tlbnMgd2l0aCBHb29nbGUncyB0b2tlbiBlbmRwb2ludFxuICogNC4gQ2FjaGUgZW5jcnlwdGVkIGFjY2VzcyB0b2tlbnMgaW4gZGF0YWJhc2Ugd2l0aCBleHBpcmF0aW9uXG4gKiA1LiBNYW5hZ2UgdG9rZW4gcmVmcmVzaCBhbmQgcXVvdGEgdHJhY2tpbmdcbiAqL1xuZXhwb3J0IGNsYXNzIEdvb2dsZUF1dGhTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IEdvb2dsZUF1dGhTZXJ2aWNlO1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBJTkRFWElOR19TQ09QRSA9ICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2luZGV4aW5nJztcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgVE9LRU5fRVhQSVJZX0JVRkZFUiA9IDUgKiA2MCAqIDEwMDA7IC8vIDUgbWludXRlcyBidWZmZXJcblxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogR29vZ2xlQXV0aFNlcnZpY2Uge1xuICAgIGlmICghR29vZ2xlQXV0aFNlcnZpY2UuaW5zdGFuY2UpIHtcbiAgICAgIEdvb2dsZUF1dGhTZXJ2aWNlLmluc3RhbmNlID0gbmV3IEdvb2dsZUF1dGhTZXJ2aWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBHb29nbGVBdXRoU2VydmljZS5pbnN0YW5jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB2YWxpZCBhY2Nlc3MgdG9rZW4gZm9yIEdvb2dsZSBBUEkgY2FsbHNcbiAgICogRmlyc3QgY2hlY2tzIGNhY2hlZCB0b2tlbiBpbiBkYXRhYmFzZSwgdGhlbiBnZW5lcmF0ZXMgbmV3IG9uZSBpZiBuZWVkZWRcbiAgICovXG4gIGFzeW5jIGdldEFjY2Vzc1Rva2VuKHNlcnZpY2VBY2NvdW50SWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+UkSBHZXR0aW5nIGFjY2VzcyB0b2tlbiBmb3Igc2VydmljZSBhY2NvdW50OiAke3NlcnZpY2VBY2NvdW50SWR9YCk7XG4gICAgICBcbiAgICAgIC8vIEdldCBzZXJ2aWNlIGFjY291bnQgZnJvbSBkYXRhYmFzZVxuICAgICAgY29uc3QgeyBkYXRhOiBzZXJ2aWNlQWNjb3VudCwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlQWRtaW5cbiAgICAgICAgLmZyb20oJ2luZGJfZ29vZ2xlX3NlcnZpY2VfYWNjb3VudHMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCdpZCcsIHNlcnZpY2VBY2NvdW50SWQpXG4gICAgICAgIC5zaW5nbGUoKTtcblxuICAgICAgaWYgKGVycm9yIHx8ICFzZXJ2aWNlQWNjb3VudCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTZXJ2aWNlIGFjY291bnQgbm90IGZvdW5kOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIERFQlVHOiBMb2cgZW5jcnlwdGVkIGRhdGEgaW5mb1xuICAgICAgY29uc29sZS5sb2coJ/CflI0gREVCVUcgLSBTZXJ2aWNlIEFjY291bnQgRGF0YTonKTtcbiAgICAgIGNvbnNvbGUubG9nKCctIElEOicsIHNlcnZpY2VBY2NvdW50LmlkKTtcbiAgICAgIGNvbnNvbGUubG9nKCctIE5hbWU6Jywgc2VydmljZUFjY291bnQubmFtZSk7XG4gICAgICBjb25zb2xlLmxvZygnLSBFbWFpbDonLCBzZXJ2aWNlQWNjb3VudC5lbWFpbCk7XG4gICAgICBjb25zb2xlLmxvZygnLSBJcyBBY3RpdmU6Jywgc2VydmljZUFjY291bnQuaXNfYWN0aXZlKTtcbiAgICAgIGNvbnNvbGUubG9nKCctIEVuY3J5cHRlZCBDcmVkZW50aWFscyBMZW5ndGg6Jywgc2VydmljZUFjY291bnQuZW5jcnlwdGVkX2NyZWRlbnRpYWxzPy5sZW5ndGggfHwgMCk7XG4gICAgICBjb25zb2xlLmxvZygnLSBFbmNyeXB0ZWQgQ3JlZGVudGlhbHMgUHJldmlldzonLCBzZXJ2aWNlQWNjb3VudC5lbmNyeXB0ZWRfY3JlZGVudGlhbHM/LnN1YnN0cmluZygwLCAxMDApICsgJy4uLicpO1xuICAgICAgY29uc29sZS5sb2coJy0gQ3VycmVudCBFTkNSWVBUSU9OX0tFWTonLCBwcm9jZXNzLmVudi5FTkNSWVBUSU9OX0tFWT8uc3Vic3RyaW5nKDAsIDgpICsgJy4uLicpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3JtYXRcbiAgICAgIGNvbnN0IHBhcnRzID0gc2VydmljZUFjY291bnQuZW5jcnlwdGVkX2NyZWRlbnRpYWxzPy5zcGxpdCgnOicpO1xuICAgICAgY29uc29sZS5sb2coJy0gRW5jcnlwdGVkIEZvcm1hdCBQYXJ0czonLCBwYXJ0cz8ubGVuZ3RoIHx8IDApO1xuICAgICAgaWYgKHBhcnRzICYmIHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBjb25zb2xlLmxvZygnLSBJViBMZW5ndGggKGhleCk6JywgcGFydHNbMF0ubGVuZ3RoKTtcbiAgICAgICAgY29uc29sZS5sb2coJy0gRW5jcnlwdGVkIERhdGEgTGVuZ3RoIChoZXgpOicsIHBhcnRzWzFdLmxlbmd0aCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCctIElWIChmaXJzdCAxNiBjaGFycyk6JywgcGFydHNbMF0uc3Vic3RyaW5nKDAsIDE2KSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCctIEVuY3J5cHRlZCBEYXRhIChmaXJzdCAzMiBjaGFycyk6JywgcGFydHNbMV0uc3Vic3RyaW5nKDAsIDMyKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgYSB2YWxpZCBjYWNoZWQgdG9rZW5cbiAgICAgIGNvbnN0IGNhY2hlZFRva2VuID0gYXdhaXQgdGhpcy5nZXRDYWNoZWRBY2Nlc3NUb2tlbihzZXJ2aWNlQWNjb3VudCk7XG4gICAgICBpZiAoY2FjaGVkVG9rZW4pIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBVc2luZyBjYWNoZWQgYWNjZXNzIHRva2VuJyk7XG4gICAgICAgIHJldHVybiBjYWNoZWRUb2tlbjtcbiAgICAgIH1cblxuICAgICAgLy8gR2VuZXJhdGUgbmV3IGFjY2VzcyB0b2tlblxuICAgICAgY29uc29sZS5sb2coJ/CflIQgR2VuZXJhdGluZyBuZXcgYWNjZXNzIHRva2VuJyk7XG4gICAgICBjb25zdCBuZXdUb2tlbiA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVOZXdBY2Nlc3NUb2tlbihzZXJ2aWNlQWNjb3VudCk7XG4gICAgICBcbiAgICAgIGlmIChuZXdUb2tlbikge1xuICAgICAgICAvLyBDYWNoZSB0aGUgbmV3IHRva2VuIGluIGRhdGFiYXNlXG4gICAgICAgIGF3YWl0IHRoaXMuY2FjaGVBY2Nlc3NUb2tlbihzZXJ2aWNlQWNjb3VudElkLCBuZXdUb2tlbik7XG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgTmV3IGFjY2VzcyB0b2tlbiBnZW5lcmF0ZWQgYW5kIGNhY2hlZCcpO1xuICAgICAgICByZXR1cm4gbmV3VG9rZW4uYWNjZXNzX3Rva2VuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBhY2Nlc3MgdG9rZW46JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhdmFpbGFibGUgc2VydmljZSBhY2NvdW50IGZvciBhIHVzZXJcbiAgICovXG4gIGFzeW5jIGdldEF2YWlsYWJsZVNlcnZpY2VBY2NvdW50KHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxTZXJ2aWNlQWNjb3VudCB8IG51bGw+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhOiBhY2NvdW50cywgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlQWRtaW5cbiAgICAgICAgLmZyb20oJ2luZGJfZ29vZ2xlX3NlcnZpY2VfYWNjb3VudHMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuICAgICAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpXG4gICAgICAgIC5saW1pdCgxKTtcblxuICAgICAgaWYgKGVycm9yIHx8ICFhY2NvdW50cz8ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdObyBhY3RpdmUgc2VydmljZSBhY2NvdW50cyBmb3VuZCBmb3IgdXNlcjonLCB1c2VySWQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjY291bnRzWzBdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHNlcnZpY2UgYWNjb3VudDonLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgd2UgaGF2ZSBhIHZhbGlkIGNhY2hlZCBhY2Nlc3MgdG9rZW5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZ2V0Q2FjaGVkQWNjZXNzVG9rZW4oc2VydmljZUFjY291bnQ6IFNlcnZpY2VBY2NvdW50KTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghc2VydmljZUFjY291bnQuZW5jcnlwdGVkX2FjY2Vzc190b2tlbiB8fCAhc2VydmljZUFjY291bnQuYWNjZXNzX3Rva2VuX2V4cGlyZXNfYXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV4cGlyZXNBdCA9IG5ldyBEYXRlKHNlcnZpY2VBY2NvdW50LmFjY2Vzc190b2tlbl9leHBpcmVzX2F0KS5nZXRUaW1lKCk7XG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0b2tlbiBpcyBzdGlsbCB2YWxpZCAod2l0aCBidWZmZXIpXG4gICAgICBpZiAoZXhwaXJlc0F0IDw9IG5vdyArIEdvb2dsZUF1dGhTZXJ2aWNlLlRPS0VOX0VYUElSWV9CVUZGRVIpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0NhY2hlZCB0b2tlbiBleHBpcmVkIG9yIGV4cGlyaW5nIHNvb24nKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIERlY3J5cHQgYW5kIHJldHVybiBjYWNoZWQgdG9rZW5cbiAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gRW5jcnlwdGlvblNlcnZpY2UuZGVjcnlwdChzZXJ2aWNlQWNjb3VudC5lbmNyeXB0ZWRfYWNjZXNzX3Rva2VuKTtcbiAgICAgIHJldHVybiBhY2Nlc3NUb2tlbjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgY2FjaGVkIHRva2VuOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBuZXcgYWNjZXNzIHRva2VuIHVzaW5nIHNlcnZpY2UgYWNjb3VudCBjcmVkZW50aWFsc1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBnZW5lcmF0ZU5ld0FjY2Vzc1Rva2VuKHNlcnZpY2VBY2NvdW50OiBTZXJ2aWNlQWNjb3VudCk6IFByb21pc2U8eyBhY2Nlc3NfdG9rZW46IHN0cmluZzsgZXhwaXJlc19pbjogbnVtYmVyIH0gfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SEIFN0YXJ0aW5nIGdlbmVyYXRlTmV3QWNjZXNzVG9rZW4gcHJvY2Vzcy4uLicpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiBjcmVkZW50aWFscyBhcmUgZW1wdHkgXG4gICAgICBpZiAoIXNlcnZpY2VBY2NvdW50LmVuY3J5cHRlZF9jcmVkZW50aWFscyB8fCBzZXJ2aWNlQWNjb3VudC5lbmNyeXB0ZWRfY3JlZGVudGlhbHMudHJpbSgpID09PSAnJykge1xuICAgICAgICBjb25zb2xlLmxvZygn4pqg77iPIFNlcnZpY2UgYWNjb3VudCBoYXMgbm8gZW5jcnlwdGVkIGNyZWRlbnRpYWxzLiBTa2lwcGluZy4uLicpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ/CflJAgREVCVUcgLSBBYm91dCB0byBkZWNyeXB0IGNyZWRlbnRpYWxzLi4uJyk7XG4gICAgICBjb25zb2xlLmxvZygnLSBFbmNyeXB0ZWQgZGF0YSBsZW5ndGg6Jywgc2VydmljZUFjY291bnQuZW5jcnlwdGVkX2NyZWRlbnRpYWxzLmxlbmd0aCk7XG4gICAgICBjb25zb2xlLmxvZygnLSBFbmNyeXB0ZWQgZGF0YSB0byBkZWNyeXB0OicsIHNlcnZpY2VBY2NvdW50LmVuY3J5cHRlZF9jcmVkZW50aWFscy5zdWJzdHJpbmcoMCwgMTAwKSArICcuLi4nKTtcbiAgICAgIFxuICAgICAgLy8gRGVjcnlwdCBzZXJ2aWNlIGFjY291bnQgY3JlZGVudGlhbHMgLSBGT1JDRSBERUNSWVBUSU9OIEFUVEVNUFRcbiAgICAgIGxldCBjcmVkZW50aWFsc0pzb246IHN0cmluZztcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5STIEZPUkNJTkcgREVDUllQVElPTiBBVFRFTVBULi4uJyk7XG4gICAgICAgIGNyZWRlbnRpYWxzSnNvbiA9IEVuY3J5cHRpb25TZXJ2aWNlLmRlY3J5cHQoc2VydmljZUFjY291bnQuZW5jcnlwdGVkX2NyZWRlbnRpYWxzKTtcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBERUJVRyAtIERFQ1JZUFRJT04gU1VDQ0VTU0ZVTCEnKTtcbiAgICAgICAgY29uc29sZS5sb2coJy0gRGVjcnlwdGVkIEpTT04gbGVuZ3RoOicsIGNyZWRlbnRpYWxzSnNvbi5sZW5ndGgpO1xuICAgICAgICBjb25zb2xlLmxvZygnLSBEZWNyeXB0ZWQgSlNPTiBwcmV2aWV3IChmaXJzdCA1MDAgY2hhcnMpOicsIGNyZWRlbnRpYWxzSnNvbi5zdWJzdHJpbmcoMCwgNTAwKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCctIEZ1bGwgZGVjcnlwdGVkIEpTT046JywgY3JlZGVudGlhbHNKc29uKTtcbiAgICAgIH0gY2F0Y2ggKGRlY3J5cHRFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgREVCVUcgLSBERUNSWVBUSU9OIEZBSUxFRDonLCBkZWNyeXB0RXJyb3IpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCctIEVycm9yIHR5cGU6JywgZGVjcnlwdEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBkZWNyeXB0RXJyb3IubmFtZSA6IHR5cGVvZiBkZWNyeXB0RXJyb3IpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCctIEVycm9yIG1lc3NhZ2U6JywgZGVjcnlwdEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBkZWNyeXB0RXJyb3IubWVzc2FnZSA6IFN0cmluZyhkZWNyeXB0RXJyb3IpKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignLSBFcnJvciBzdGFjazonLCBkZWNyeXB0RXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGRlY3J5cHRFcnJvci5zdGFjayA6ICdObyBzdGFjaycpO1xuICAgICAgICBcbiAgICAgICAgLy8gRE8gTk9UIENMRUFSIEFOWVRISU5HIC0ganVzdCBmYWlsIGFuZCBzaG93IHRoZSBlcnJvclxuICAgICAgICB0aHJvdyBkZWNyeXB0RXJyb3I7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn5OLIERFQlVHIC0gUGFyc2luZyBKU09OIGNyZWRlbnRpYWxzLi4uJyk7XG4gICAgICBsZXQgY3JlZGVudGlhbHM6IFNlcnZpY2VBY2NvdW50Q3JlZGVudGlhbHM7XG4gICAgICB0cnkge1xuICAgICAgICBjcmVkZW50aWFscyA9IEpTT04ucGFyc2UoY3JlZGVudGlhbHNKc29uKTtcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBERUJVRyAtIEpTT04gcGFyc2luZyBzdWNjZXNzZnVsIScpO1xuICAgICAgICBjb25zb2xlLmxvZygnLSBTZXJ2aWNlIGFjY291bnQgdHlwZTonLCBjcmVkZW50aWFscy50eXBlKTtcbiAgICAgICAgY29uc29sZS5sb2coJy0gUHJvamVjdCBJRDonLCBjcmVkZW50aWFscy5wcm9qZWN0X2lkKTtcbiAgICAgICAgY29uc29sZS5sb2coJy0gQ2xpZW50IGVtYWlsOicsIGNyZWRlbnRpYWxzLmNsaWVudF9lbWFpbCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCctIFByaXZhdGUga2V5IHByZXZpZXc6JywgY3JlZGVudGlhbHMucHJpdmF0ZV9rZXk/LnN1YnN0cmluZygwLCA1MCkgKyAnLi4uJyk7XG4gICAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBERUJVRyAtIEpTT04gcGFyc2luZyBmYWlsZWQ6JywgcGFyc2VFcnJvcik7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJy0gUmF3IGRlY3J5cHRlZCBkYXRhOicsIGNyZWRlbnRpYWxzSnNvbik7XG4gICAgICAgIHRocm93IHBhcnNlRXJyb3I7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn5SQIERFQlVHIC0gQ3JlYXRpbmcgSldUIHdpdGggc2VydmljZSBhY2NvdW50IGNyZWRlbnRpYWxzLi4uJyk7XG4gICAgICBjb25zb2xlLmxvZygnLSBFbWFpbCBmb3IgSldUOicsIGNyZWRlbnRpYWxzLmNsaWVudF9lbWFpbCk7XG4gICAgICBjb25zb2xlLmxvZygnLSBQcml2YXRlIGtleSBzdGFydHMgd2l0aDonLCBjcmVkZW50aWFscy5wcml2YXRlX2tleT8uc3Vic3RyaW5nKDAsIDMwKSk7XG4gICAgICBjb25zb2xlLmxvZygnLSBTY29wZXM6JywgW0dvb2dsZUF1dGhTZXJ2aWNlLklOREVYSU5HX1NDT1BFXSk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBKV1QgY2xpZW50XG4gICAgICBsZXQgand0Q2xpZW50OiBKV1Q7XG4gICAgICB0cnkge1xuICAgICAgICBqd3RDbGllbnQgPSBuZXcgSldUKHtcbiAgICAgICAgICBlbWFpbDogY3JlZGVudGlhbHMuY2xpZW50X2VtYWlsLFxuICAgICAgICAgIGtleTogY3JlZGVudGlhbHMucHJpdmF0ZV9rZXksXG4gICAgICAgICAgc2NvcGVzOiBbR29vZ2xlQXV0aFNlcnZpY2UuSU5ERVhJTkdfU0NPUEVdXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zb2xlLmxvZygn4pyFIERFQlVHIC0gSldUIGNsaWVudCBjcmVhdGVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgfSBjYXRjaCAoand0RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIERFQlVHIC0gSldUIGNsaWVudCBjcmVhdGlvbiBmYWlsZWQ6Jywgand0RXJyb3IpO1xuICAgICAgICB0aHJvdyBqd3RFcnJvcjtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ/CfjJAgREVCVUcgLSBSZXF1ZXN0aW5nIGFjY2VzcyB0b2tlbiBmcm9tIEdvb2dsZS4uLicpO1xuICAgICAgLy8gR2V0IGFjY2VzcyB0b2tlblxuICAgICAgbGV0IHRva2VuUmVzcG9uc2U7XG4gICAgICB0cnkge1xuICAgICAgICB0b2tlblJlc3BvbnNlID0gYXdhaXQgand0Q2xpZW50LmF1dGhvcml6ZSgpO1xuICAgICAgICBjb25zb2xlLmxvZygn4pyFIERFQlVHIC0gR29vZ2xlIGF1dGhvcml6YXRpb24gc3VjY2Vzc2Z1bCEnKTtcbiAgICAgICAgY29uc29sZS5sb2coJy0gVG9rZW4gdHlwZTonLCB0eXBlb2YgdG9rZW5SZXNwb25zZS5hY2Nlc3NfdG9rZW4pO1xuICAgICAgICBjb25zb2xlLmxvZygnLSBUb2tlbiBsZW5ndGg6JywgdG9rZW5SZXNwb25zZS5hY2Nlc3NfdG9rZW4/Lmxlbmd0aCB8fCAwKTtcbiAgICAgICAgY29uc29sZS5sb2coJy0gVG9rZW4gcHJldmlldzonLCB0b2tlblJlc3BvbnNlLmFjY2Vzc190b2tlbj8uc3Vic3RyaW5nKDAsIDIwKSArICcuLi4nKTtcbiAgICAgICAgY29uc29sZS5sb2coJy0gRXhwaXJlcyBpbjonLCB0b2tlblJlc3BvbnNlLmV4cGlyeV9kYXRlKTtcbiAgICAgIH0gY2F0Y2ggKGF1dGhFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgREVCVUcgLSBHb29nbGUgYXV0aG9yaXphdGlvbiBmYWlsZWQ6JywgYXV0aEVycm9yKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignLSBFcnJvciBkZXRhaWxzOicsIGF1dGhFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gYXV0aEVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoYXV0aEVycm9yKSk7XG4gICAgICAgIHRocm93IGF1dGhFcnJvcjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKCF0b2tlblJlc3BvbnNlLmFjY2Vzc190b2tlbikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgREVCVUcgLSBObyBhY2Nlc3MgdG9rZW4gcmVjZWl2ZWQgZnJvbSBHb29nbGUnKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignLSBSZXNwb25zZTonLCB0b2tlblJlc3BvbnNlKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY2Nlc3MgdG9rZW4gcmVjZWl2ZWQgZnJvbSBHb29nbGUnKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ+KchSBTdWNjZXNzZnVsbHkgb2J0YWluZWQgYWNjZXNzIHRva2VuIGZyb20gR29vZ2xlJyk7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFjY2Vzc190b2tlbjogdG9rZW5SZXNwb25zZS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgIGV4cGlyZXNfaW46IDM2MDAgLy8gR29vZ2xlIHRva2VucyB0eXBpY2FsbHkgZXhwaXJlIGluIDEgaG91clxuICAgICAgfTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZW5lcmF0aW5nIGFjY2VzcyB0b2tlbjonLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FjaGUgZW5jcnlwdGVkIGFjY2VzcyB0b2tlbiBpbiBkYXRhYmFzZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjYWNoZUFjY2Vzc1Rva2VuKHNlcnZpY2VBY2NvdW50SWQ6IHN0cmluZywgdG9rZW5EYXRhOiB7IGFjY2Vzc190b2tlbjogc3RyaW5nOyBleHBpcmVzX2luOiBudW1iZXIgfSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBFbmNyeXB0IGFjY2VzcyB0b2tlblxuICAgICAgY29uc3QgZW5jcnlwdGVkVG9rZW4gPSBFbmNyeXB0aW9uU2VydmljZS5lbmNyeXB0KHRva2VuRGF0YS5hY2Nlc3NfdG9rZW4pO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgZXhwaXJhdGlvbiB0aW1lICh3aXRoIHNvbWUgYnVmZmVyKVxuICAgICAgY29uc3QgZXhwaXJlc0F0ID0gbmV3IERhdGUoRGF0ZS5ub3coKSArICh0b2tlbkRhdGEuZXhwaXJlc19pbiAqIDEwMDApIC0gR29vZ2xlQXV0aFNlcnZpY2UuVE9LRU5fRVhQSVJZX0JVRkZFUik7XG5cbiAgICAgIC8vIFVwZGF0ZSBzZXJ2aWNlIGFjY291bnQgd2l0aCBjYWNoZWQgdG9rZW5cbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlQWRtaW5cbiAgICAgICAgLmZyb20oJ2luZGJfZ29vZ2xlX3NlcnZpY2VfYWNjb3VudHMnKVxuICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICBlbmNyeXB0ZWRfYWNjZXNzX3Rva2VuOiBlbmNyeXB0ZWRUb2tlbixcbiAgICAgICAgICBhY2Nlc3NfdG9rZW5fZXhwaXJlc19hdDogZXhwaXJlc0F0LnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH0pXG4gICAgICAgIC5lcSgnaWQnLCBzZXJ2aWNlQWNjb3VudElkKTtcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNhY2hpbmcgYWNjZXNzIHRva2VuOicsIGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgQWNjZXNzIHRva2VuIGNhY2hlZCBpbiBkYXRhYmFzZScpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjYWNoaW5nIGFjY2VzcyB0b2tlbjonLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHNlcnZpY2UgYWNjb3VudCBjcmVkZW50aWFscyBmb3JtYXRcbiAgICovXG4gIHN0YXRpYyB2YWxpZGF0ZVNlcnZpY2VBY2NvdW50Q3JlZGVudGlhbHMoY3JlZGVudGlhbHNKc29uOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY3JlZGVudGlhbHMgPSBKU09OLnBhcnNlKGNyZWRlbnRpYWxzSnNvbik7XG4gICAgICBjb25zdCByZXF1aXJlZEZpZWxkcyA9IFtcbiAgICAgICAgJ3R5cGUnLCAncHJvamVjdF9pZCcsICdwcml2YXRlX2tleV9pZCcsICdwcml2YXRlX2tleScsXG4gICAgICAgICdjbGllbnRfZW1haWwnLCAnY2xpZW50X2lkJywgJ2F1dGhfdXJpJywgJ3Rva2VuX3VyaSdcbiAgICAgIF07XG4gICAgICBcbiAgICAgIHJldHVybiByZXF1aXJlZEZpZWxkcy5ldmVyeShmaWVsZCA9PiBjcmVkZW50aWFsc1tmaWVsZF0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59Il0sIm5hbWVzIjpbInN1cGFiYXNlQWRtaW4iLCJFbmNyeXB0aW9uU2VydmljZSIsIkpXVCIsIkdvb2dsZUF1dGhTZXJ2aWNlIiwiSU5ERVhJTkdfU0NPUEUiLCJUT0tFTl9FWFBJUllfQlVGRkVSIiwiZ2V0SW5zdGFuY2UiLCJpbnN0YW5jZSIsImdldEFjY2Vzc1Rva2VuIiwic2VydmljZUFjY291bnRJZCIsImNvbnNvbGUiLCJsb2ciLCJkYXRhIiwic2VydmljZUFjY291bnQiLCJlcnJvciIsImZyb20iLCJzZWxlY3QiLCJlcSIsInNpbmdsZSIsImlkIiwibmFtZSIsImVtYWlsIiwiaXNfYWN0aXZlIiwiZW5jcnlwdGVkX2NyZWRlbnRpYWxzIiwibGVuZ3RoIiwic3Vic3RyaW5nIiwicHJvY2VzcyIsImVudiIsIkVOQ1JZUFRJT05fS0VZIiwicGFydHMiLCJzcGxpdCIsImNhY2hlZFRva2VuIiwiZ2V0Q2FjaGVkQWNjZXNzVG9rZW4iLCJuZXdUb2tlbiIsImdlbmVyYXRlTmV3QWNjZXNzVG9rZW4iLCJjYWNoZUFjY2Vzc1Rva2VuIiwiYWNjZXNzX3Rva2VuIiwiZ2V0QXZhaWxhYmxlU2VydmljZUFjY291bnQiLCJ1c2VySWQiLCJhY2NvdW50cyIsImxpbWl0IiwiZW5jcnlwdGVkX2FjY2Vzc190b2tlbiIsImFjY2Vzc190b2tlbl9leHBpcmVzX2F0IiwiZXhwaXJlc0F0IiwiRGF0ZSIsImdldFRpbWUiLCJub3ciLCJhY2Nlc3NUb2tlbiIsImRlY3J5cHQiLCJ0cmltIiwiY3JlZGVudGlhbHNKc29uIiwiZGVjcnlwdEVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwiU3RyaW5nIiwic3RhY2siLCJjcmVkZW50aWFscyIsIkpTT04iLCJwYXJzZSIsInR5cGUiLCJwcm9qZWN0X2lkIiwiY2xpZW50X2VtYWlsIiwicHJpdmF0ZV9rZXkiLCJwYXJzZUVycm9yIiwiand0Q2xpZW50Iiwia2V5Iiwic2NvcGVzIiwiand0RXJyb3IiLCJ0b2tlblJlc3BvbnNlIiwiYXV0aG9yaXplIiwiZXhwaXJ5X2RhdGUiLCJhdXRoRXJyb3IiLCJleHBpcmVzX2luIiwidG9rZW5EYXRhIiwiZW5jcnlwdGVkVG9rZW4iLCJlbmNyeXB0IiwidXBkYXRlIiwidG9JU09TdHJpbmciLCJ1cGRhdGVkX2F0IiwidmFsaWRhdGVTZXJ2aWNlQWNjb3VudENyZWRlbnRpYWxzIiwicmVxdWlyZWRGaWVsZHMiLCJldmVyeSIsImZpZWxkIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/google-auth-service.ts\n");

/***/ }),

/***/ "(rsc)/./lib/google-indexing-processor.ts":
/*!******************************************!*\
  !*** ./lib/google-indexing-processor.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GoogleIndexingProcessor: () => (/* binding */ GoogleIndexingProcessor)\n/* harmony export */ });\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase */ \"(rsc)/./lib/supabase.ts\");\n/* harmony import */ var _google_auth_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./google-auth-service */ \"(rsc)/./lib/google-auth-service.ts\");\n/* harmony import */ var _websocket_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./websocket-service */ \"(rsc)/./lib/websocket-service.ts\");\n/* harmony import */ var _job_logging_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./job-logging-service */ \"(rsc)/./lib/job-logging-service.ts\");\n\n\n\n\n/**\n * Google Indexing Processor\n * \n * Professional-grade URL indexing system that integrates with Google's Indexing API\n * to automatically submit URLs for indexing with proper error handling, retry logic,\n * and quota management across multiple service accounts.\n */ class GoogleIndexingProcessor {\n    constructor(){\n        this.processingJobs = new Set();\n        this.googleAuth = _google_auth_service__WEBPACK_IMPORTED_MODULE_1__.GoogleAuthService.getInstance();\n        this.websocketService = _websocket_service__WEBPACK_IMPORTED_MODULE_2__.WebSocketService.getInstance();\n        this.jobLogger = _job_logging_service__WEBPACK_IMPORTED_MODULE_3__.JobLoggingService.getInstance();\n    }\n    static getInstance() {\n        if (!GoogleIndexingProcessor.instance) {\n            GoogleIndexingProcessor.instance = new GoogleIndexingProcessor();\n        }\n        return GoogleIndexingProcessor.instance;\n    }\n    /**\n   * Process a complete indexing job\n   * Extracts URLs, creates submissions, and processes each URL through Google's API\n   */ async processIndexingJob(jobId) {\n        if (this.processingJobs.has(jobId)) {\n            return {\n                success: false,\n                error: 'Job is already being processed'\n            };\n        }\n        try {\n            // Lock the job to prevent concurrent processing\n            const lockResult = await this.lockJobForProcessing(jobId);\n            if (!lockResult) {\n                return {\n                    success: false,\n                    error: 'Failed to lock job - may already be processing'\n                };\n            }\n            this.processingJobs.add(jobId);\n            console.log(`🚀 Starting indexing job ${jobId}`);\n            // Get job details\n            const job = await this.getJobDetails(jobId);\n            if (!job) {\n                return {\n                    success: false,\n                    error: 'Job not found'\n                };\n            }\n            // Log job start\n            await this.jobLogger.logJobStarted(jobId, job.name, job.total_urls || 0);\n            // Update job status to running\n            await this.updateJobStatus(jobId, 'running', {\n                started_at: new Date().toISOString(),\n                processed_urls: 0,\n                successful_urls: 0,\n                failed_urls: 0,\n                progress_percentage: 0\n            });\n            // Extract URLs from job source data\n            const urls = await this.extractUrlsFromJobSource(job);\n            if (urls.length === 0) {\n                throw new Error('No URLs found to process in job source data');\n            }\n            console.log(`📋 Found ${urls.length} URLs to process`);\n            // Log URL extraction\n            await this.jobLogger.logJobEvent({\n                job_id: jobId,\n                level: 'INFO',\n                message: `Found ${urls.length} URLs to process`,\n                metadata: {\n                    event_type: 'urls_extracted',\n                    url_count: urls.length,\n                    job_type: job.type\n                }\n            });\n            // Create URL submissions for tracking\n            await this.createUrlSubmissionsForJob(jobId, urls);\n            // Process all URLs through Google's Indexing API\n            await this.processUrlSubmissionsWithGoogleAPI(job);\n            // Get final stats\n            const finalJob = await this.getJobDetails(jobId);\n            const processingTimeMs = finalJob?.started_at ? new Date().getTime() - new Date(finalJob.started_at).getTime() : undefined;\n            // Mark job as completed\n            await this.updateJobStatus(jobId, 'completed', {\n                completed_at: new Date().toISOString()\n            });\n            // Log job completion\n            await this.jobLogger.logJobCompleted(jobId, job.name, {\n                total_urls: finalJob?.total_urls || 0,\n                successful_urls: finalJob?.successful_urls || 0,\n                failed_urls: finalJob?.failed_urls || 0,\n                processing_time_ms: processingTimeMs\n            });\n            // Send real-time completion update\n            this.websocketService.broadcastJobUpdate(job.user_id, jobId, {\n                status: 'completed',\n                progress: {\n                    total_urls: finalJob?.total_urls || 0,\n                    processed_urls: finalJob?.processed_urls || 0,\n                    successful_urls: finalJob?.successful_urls || 0,\n                    failed_urls: finalJob?.failed_urls || 0,\n                    progress_percentage: 100\n                }\n            });\n            console.log(`✅ Indexing job ${jobId} completed successfully`);\n            return {\n                success: true\n            };\n        } catch (error) {\n            console.error(`❌ Indexing job ${jobId} failed:`, error);\n            // Get job details for logging\n            const job = await this.getJobDetails(jobId);\n            // Log job failure\n            if (job) {\n                await this.jobLogger.logJobFailed(jobId, job.name, error instanceof Error ? error.message : 'Unknown error', {\n                    error_type: error instanceof Error ? error.constructor.name : 'UnknownError',\n                    stack_trace: error instanceof Error ? error.stack : undefined\n                });\n            }\n            // Mark job as failed\n            await this.updateJobStatus(jobId, 'failed', {\n                error_message: error instanceof Error ? error.message : 'Unknown error',\n                locked_at: null,\n                locked_by: null\n            });\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error'\n            };\n        } finally{\n            this.processingJobs.delete(jobId);\n        }\n    }\n    /**\n   * Extract URLs from job source data based on job type\n   */ async extractUrlsFromJobSource(job) {\n        try {\n            if (job.type === 'manual') {\n                // For manual jobs, URLs are stored in source_data.urls\n                const urls = job.source_data?.urls || [];\n                console.log(`📝 Manual job: extracted ${urls.length} URLs`);\n                return urls;\n            } else if (job.type === 'sitemap') {\n                // For sitemap jobs, parse the sitemap URL\n                const sitemapUrl = job.source_data?.sitemapUrl;\n                if (!sitemapUrl) {\n                    throw new Error('No sitemap URL found in job source data');\n                }\n                console.log(`🗺️ Sitemap job: parsing ${sitemapUrl}`);\n                return await this.parseSitemapUrls(sitemapUrl);\n            }\n            return [];\n        } catch (error) {\n            console.error('Error extracting URLs from job source:', error);\n            throw error;\n        }\n    }\n    /**\n   * Parse sitemap XML to extract all URLs\n   */ async parseSitemapUrls(sitemapUrl) {\n        try {\n            console.log(`🔍 Fetching sitemap: ${sitemapUrl}`);\n            const response = await fetch(sitemapUrl);\n            if (!response.ok) {\n                throw new Error(`Failed to fetch sitemap: ${response.status} ${response.statusText}`);\n            }\n            const xmlContent = await response.text();\n            const xml2js = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/xmlbuilder\"), __webpack_require__.e(\"vendor-chunks/xml2js\"), __webpack_require__.e(\"vendor-chunks/sax\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! xml2js */ \"(rsc)/./node_modules/xml2js/lib/xml2js.js\", 23));\n            const parser = new xml2js.Parser();\n            const parsedXml = await parser.parseStringPromise(xmlContent);\n            const urls = [];\n            // Handle regular sitemap with URL entries\n            if (parsedXml.urlset?.url) {\n                parsedXml.urlset.url.forEach((urlEntry)=>{\n                    if (urlEntry.loc?.[0]) {\n                        urls.push(urlEntry.loc[0]);\n                    }\n                });\n            }\n            // Handle sitemap index with nested sitemaps\n            if (parsedXml.sitemapindex?.sitemap) {\n                for (const sitemapEntry of parsedXml.sitemapindex.sitemap){\n                    if (sitemapEntry.loc?.[0]) {\n                        const nestedUrls = await this.parseSitemapUrls(sitemapEntry.loc[0]);\n                        urls.push(...nestedUrls);\n                    }\n                }\n            }\n            console.log(`✅ Extracted ${urls.length} URLs from sitemap`);\n            return urls;\n        } catch (error) {\n            console.error('Error parsing sitemap:', error);\n            throw new Error(`Sitemap parsing failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n    }\n    /**\n   * Create URL submission records for tracking individual URL processing\n   */ async createUrlSubmissionsForJob(jobId, urls) {\n        try {\n            console.log(`📊 Creating ${urls.length} URL submission records`);\n            const submissions = urls.map((url)=>({\n                    job_id: jobId,\n                    url: url,\n                    status: 'pending',\n                    retry_count: 0,\n                    created_at: new Date().toISOString(),\n                    updated_at: new Date().toISOString()\n                }));\n            // Insert submissions in batches to avoid database limits\n            const batchSize = 100;\n            for(let i = 0; i < submissions.length; i += batchSize){\n                const batch = submissions.slice(i, i + batchSize);\n                const { error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_indexing_url_submissions').insert(batch);\n                if (error) {\n                    throw new Error(`Failed to create URL submissions: ${error.message}`);\n                }\n            }\n            // Update job with total URL count\n            await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_indexing_jobs').update({\n                total_urls: urls.length,\n                updated_at: new Date().toISOString()\n            }).eq('id', jobId);\n            console.log(`✅ Created ${urls.length} URL submission records`);\n        } catch (error) {\n            console.error('Error creating URL submissions:', error);\n            throw error;\n        }\n    }\n    /**\n   * Process all URL submissions through Google's Indexing API\n   */ async processUrlSubmissionsWithGoogleAPI(job) {\n        try {\n            console.log(`🔄 Processing URL submissions for job ${job.id}`);\n            // Get active service accounts for load balancing\n            const { data: serviceAccounts, error: saError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_google_service_accounts').select('*').eq('user_id', job.user_id).eq('is_active', true);\n            if (saError || !serviceAccounts || serviceAccounts.length === 0) {\n                throw new Error('No active Google service accounts found for user');\n            }\n            console.log(`📈 Using ${serviceAccounts.length} service accounts for load balancing`);\n            // Get pending submissions for this job\n            const { data: submissions, error: subError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_indexing_url_submissions').select('*').eq('job_id', job.id).eq('status', 'pending').order('created_at');\n            if (subError) {\n                throw new Error(`Error fetching URL submissions: ${subError.message}`);\n            }\n            if (!submissions || submissions.length === 0) {\n                console.log('⚠️ No pending submissions found for processing');\n                return;\n            }\n            console.log(`🎯 Processing ${submissions.length} URL submissions`);\n            let processed = 0;\n            let successful = 0;\n            let failed = 0;\n            // Process each URL submission\n            for (const submission of submissions){\n                try {\n                    // Round-robin service account selection for load balancing\n                    const serviceAccount = serviceAccounts[processed % serviceAccounts.length];\n                    // Log service account usage\n                    await this.jobLogger.logServiceAccountUsage(job.id, serviceAccount.email, 'selected_for_url_processing');\n                    // Get access token for Google API\n                    const accessToken = await this.googleAuth.getAccessToken(serviceAccount.id);\n                    if (!accessToken) {\n                        console.log(`⚠️ Skipping service account ${serviceAccount.id} - no valid access token (likely missing credentials)`);\n                        await this.jobLogger.logWarning(job.id, `Skipping service account ${serviceAccount.email} - no valid access token`, {\n                            service_account_id: serviceAccount.id,\n                            service_account_email: serviceAccount.email\n                        });\n                        continue; // Skip this service account and try the next one\n                    }\n                    // Submit URL to Google's Indexing API\n                    const startTime = Date.now();\n                    await this.submitUrlToGoogleIndexingAPI(submission.url, accessToken);\n                    const responseTime = Date.now() - startTime;\n                    // Update submission as successful\n                    await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_indexing_url_submissions').update({\n                        status: 'submitted',\n                        submitted_at: new Date().toISOString(),\n                        service_account_id: serviceAccount.id,\n                        updated_at: new Date().toISOString()\n                    }).eq('id', submission.id);\n                    // Update quota usage for the service account (-1 for successful request)\n                    await this.updateQuotaUsage(serviceAccount.id, true);\n                    // Log successful URL processing\n                    await this.jobLogger.logUrlProcessed(job.id, submission.url, true, undefined, responseTime);\n                    const remainingQuota = await this.getRemainingQuota(serviceAccount.id);\n                    await this.jobLogger.logQuotaUsage(job.id, serviceAccount.id, remainingQuota);\n                    successful++;\n                    console.log(`✅ Successfully indexed: ${submission.url}`);\n                } catch (error) {\n                    console.error(`❌ Failed to index ${submission.url}:`, error);\n                    // Get the service account for this submission\n                    const serviceAccount = serviceAccounts[processed % serviceAccounts.length];\n                    // Log failed URL processing\n                    await this.jobLogger.logUrlProcessed(job.id, submission.url, false, error instanceof Error ? error.message : 'Unknown error');\n                    // Update submission as failed\n                    await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_indexing_url_submissions').update({\n                        status: 'failed',\n                        error_message: error instanceof Error ? error.message : 'Indexing failed',\n                        retry_count: submission.retry_count + 1,\n                        service_account_id: serviceAccount.id,\n                        updated_at: new Date().toISOString()\n                    }).eq('id', submission.id);\n                    // Update quota usage for the service account (still counts as a request attempt)\n                    await this.updateQuotaUsage(serviceAccount.id, false);\n                    failed++;\n                }\n                processed++;\n                // Update job progress in real-time\n                const progressPercentage = Math.round(processed / submissions.length * 100);\n                await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_indexing_jobs').update({\n                    processed_urls: processed,\n                    successful_urls: successful,\n                    failed_urls: failed,\n                    progress_percentage: progressPercentage,\n                    updated_at: new Date().toISOString()\n                }).eq('id', job.id);\n                // Log progress update every 10 processed URLs or on completion\n                if (processed % 10 === 0 || processed === submissions.length) {\n                    await this.jobLogger.logProgressUpdate(job.id, progressPercentage, processed, submissions.length);\n                }\n                // Send real-time progress update via WebSocket\n                this.websocketService.broadcastJobUpdate(job.user_id, job.id, {\n                    status: 'running',\n                    progress: {\n                        total_urls: submissions.length,\n                        processed_urls: processed,\n                        successful_urls: successful,\n                        failed_urls: failed,\n                        progress_percentage: progressPercentage\n                    }\n                });\n                // Respect Google API rate limits\n                await new Promise((resolve)=>setTimeout(resolve, 100));\n            }\n            console.log(`📊 Job processing complete: ${successful} successful, ${failed} failed out of ${processed} total`);\n        } catch (error) {\n            console.error('Error processing URL submissions:', error);\n            throw error;\n        }\n    }\n    /**\n   * Submit individual URL to Google's Indexing API\n   */ async submitUrlToGoogleIndexingAPI(url, accessToken) {\n        const apiUrl = 'https://indexing.googleapis.com/v3/urlNotifications:publish';\n        const response = await fetch(apiUrl, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${accessToken}`\n            },\n            body: JSON.stringify({\n                url: url,\n                type: 'URL_UPDATED'\n            })\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            const errorMessage = errorData.error?.message || `HTTP ${response.status}: ${response.statusText}`;\n            throw new Error(`Google Indexing API error: ${errorMessage}`);\n        }\n        // Log successful response for debugging\n        const responseData = await response.json();\n        console.log(`🎯 Google API response for ${url}:`, responseData);\n    }\n    /**\n   * Update quota usage for a service account\n   */ async updateQuotaUsage(serviceAccountId, successful) {\n        try {\n            const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD format\n            // Get current quota usage for today\n            const { data: currentUsage, error: fetchError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_google_quota_usage').select('*').eq('service_account_id', serviceAccountId).eq('date', today).single();\n            if (fetchError && fetchError.code !== 'PGRST116') {\n                console.error('Error fetching current quota usage:', fetchError);\n                return;\n            }\n            // Calculate new usage numbers\n            const currentRequestsMade = currentUsage?.requests_made || 0;\n            const currentRequestsSuccessful = currentUsage?.requests_successful || 0;\n            const currentRequestsFailed = currentUsage?.requests_failed || 0;\n            const updatedUsage = {\n                service_account_id: serviceAccountId,\n                date: today,\n                requests_made: currentRequestsMade + 1,\n                requests_successful: successful ? currentRequestsSuccessful + 1 : currentRequestsSuccessful,\n                requests_failed: successful ? currentRequestsFailed : currentRequestsFailed + 1,\n                last_request_at: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            };\n            // If record doesn't exist, add created_at\n            if (!currentUsage) {\n                updatedUsage.created_at = new Date().toISOString();\n            }\n            // Upsert quota usage record\n            const { error: upsertError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_google_quota_usage').upsert(updatedUsage, {\n                onConflict: 'service_account_id,date'\n            });\n            if (upsertError) {\n                console.error('Error updating quota usage:', upsertError);\n            } else {\n                console.log(`📊 Updated quota for service account ${serviceAccountId}: ${updatedUsage.requests_made} requests (${updatedUsage.requests_successful} successful, ${updatedUsage.requests_failed} failed)`);\n            }\n        } catch (error) {\n            console.error('Error in updateQuotaUsage:', error);\n        }\n    }\n    /**\n   * Lock job to prevent concurrent processing\n   */ async lockJobForProcessing(jobId) {\n        try {\n            const lockTime = new Date().toISOString();\n            const lockId = `processor-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n            const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_indexing_jobs').update({\n                status: 'running'\n            }).eq('id', jobId).eq('status', 'pending').select();\n            // Send real-time status update\n            if (data && data.length > 0) {\n                // Get user_id from the job data\n                const job = await this.getJobDetails(jobId);\n                if (job) {\n                    this.websocketService.broadcastJobUpdate(job.user_id, jobId, {\n                        status: 'running',\n                        progress: {\n                            total_urls: job.total_urls,\n                            processed_urls: 0,\n                            successful_urls: 0,\n                            failed_urls: 0,\n                            progress_percentage: 0\n                        }\n                    });\n                }\n            }\n            if (error) {\n                console.error('Error locking job:', error);\n                return false;\n            }\n            const success = data && data.length > 0;\n            if (!success) {\n                console.log(`Job ${jobId} is already locked or not in pending status`);\n            }\n            return success;\n        } catch (error) {\n            console.error('Error locking job:', error);\n            return false;\n        }\n    }\n    /**\n   * Get job details from database\n   */ async getJobDetails(jobId) {\n        try {\n            const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_indexing_jobs').select('*').eq('id', jobId).single();\n            return error ? null : data;\n        } catch (error) {\n            console.error('Error getting job details:', error);\n            return null;\n        }\n    }\n    /**\n   * Update job status and additional fields\n   */ async updateJobStatus(jobId, status, extraFields = {}) {\n        try {\n            await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_indexing_jobs').update({\n                status,\n                updated_at: new Date().toISOString(),\n                ...extraFields\n            }).eq('id', jobId);\n        } catch (error) {\n            console.error('Error updating job status:', error);\n        }\n    }\n    /**\n   * Get remaining quota for a service account\n   */ async getRemainingQuota(serviceAccountId) {\n        try {\n            const today = new Date().toISOString().split('T')[0];\n            // Get service account quota limit\n            const { data: serviceAccount } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_google_service_accounts').select('daily_quota_limit').eq('id', serviceAccountId).single();\n            const dailyLimit = serviceAccount?.daily_quota_limit || 200; // Default Google API limit\n            // Get current usage\n            const { data: usage } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_google_quota_usage').select('requests_made').eq('service_account_id', serviceAccountId).eq('date', today).single();\n            const usedRequests = usage?.requests_made || 0;\n            return Math.max(0, dailyLimit - usedRequests);\n        } catch (error) {\n            console.error('Error getting remaining quota:', error);\n            return 0;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvZ29vZ2xlLWluZGV4aW5nLXByb2Nlc3Nvci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEyQztBQUNlO0FBQ0g7QUFDRztBQThCMUQ7Ozs7OztDQU1DLEdBQ00sTUFBTUk7SUFPWCxhQUFjO2FBRk5DLGlCQUFpQixJQUFJQztRQUczQixJQUFJLENBQUNDLFVBQVUsR0FBR04sbUVBQWlCQSxDQUFDTyxXQUFXO1FBQy9DLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUdQLGdFQUFnQkEsQ0FBQ00sV0FBVztRQUNwRCxJQUFJLENBQUNFLFNBQVMsR0FBR1AsbUVBQWlCQSxDQUFDSyxXQUFXO0lBQ2hEO0lBRUEsT0FBT0EsY0FBdUM7UUFDNUMsSUFBSSxDQUFDSix3QkFBd0JPLFFBQVEsRUFBRTtZQUNyQ1Asd0JBQXdCTyxRQUFRLEdBQUcsSUFBSVA7UUFDekM7UUFDQSxPQUFPQSx3QkFBd0JPLFFBQVE7SUFDekM7SUFFQTs7O0dBR0MsR0FDRCxNQUFNQyxtQkFBbUJDLEtBQWEsRUFBaUQ7UUFDckYsSUFBSSxJQUFJLENBQUNSLGNBQWMsQ0FBQ1MsR0FBRyxDQUFDRCxRQUFRO1lBQ2xDLE9BQU87Z0JBQUVFLFNBQVM7Z0JBQU9DLE9BQU87WUFBaUM7UUFDbkU7UUFFQSxJQUFJO1lBQ0YsZ0RBQWdEO1lBQ2hELE1BQU1DLGFBQWEsTUFBTSxJQUFJLENBQUNDLG9CQUFvQixDQUFDTDtZQUNuRCxJQUFJLENBQUNJLFlBQVk7Z0JBQ2YsT0FBTztvQkFBRUYsU0FBUztvQkFBT0MsT0FBTztnQkFBaUQ7WUFDbkY7WUFFQSxJQUFJLENBQUNYLGNBQWMsQ0FBQ2MsR0FBRyxDQUFDTjtZQUN4Qk8sUUFBUUMsR0FBRyxDQUFDLENBQUMseUJBQXlCLEVBQUVSLE9BQU87WUFFL0Msa0JBQWtCO1lBQ2xCLE1BQU1TLE1BQU0sTUFBTSxJQUFJLENBQUNDLGFBQWEsQ0FBQ1Y7WUFDckMsSUFBSSxDQUFDUyxLQUFLO2dCQUNSLE9BQU87b0JBQUVQLFNBQVM7b0JBQU9DLE9B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O1lBQ2RJLFFBQVFKLEtBQUssQ0FBQyxrQ0FBa0NBO1lBQ2hELE9BQU87UUFDVDtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2UvbGliL2dvb2dsZS1pbmRleGluZy1wcm9jZXNzb3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3VwYWJhc2VBZG1pbiB9IGZyb20gJy4vc3VwYWJhc2UnO1xuaW1wb3J0IHsgR29vZ2xlQXV0aFNlcnZpY2UgfSBmcm9tICcuL2dvb2dsZS1hdXRoLXNlcnZpY2UnO1xuaW1wb3J0IHsgV2ViU29ja2V0U2VydmljZSB9IGZyb20gJy4vd2Vic29ja2V0LXNlcnZpY2UnO1xuaW1wb3J0IHsgSm9iTG9nZ2luZ1NlcnZpY2UgfSBmcm9tICcuL2pvYi1sb2dnaW5nLXNlcnZpY2UnO1xuXG5pbnRlcmZhY2UgSW5kZXhpbmdKb2Ige1xuICBpZDogc3RyaW5nO1xuICB1c2VyX2lkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgdHlwZTogJ21hbnVhbCcgfCAnc2l0ZW1hcCc7XG4gIHN0YXR1czogc3RyaW5nO1xuICBzb3VyY2VfZGF0YTogYW55O1xuICB0b3RhbF91cmxzOiBudW1iZXI7XG4gIHByb2Nlc3NlZF91cmxzOiBudW1iZXI7XG4gIHN1Y2Nlc3NmdWxfdXJsczogbnVtYmVyO1xuICBmYWlsZWRfdXJsczogbnVtYmVyO1xuICBwcm9ncmVzc19wZXJjZW50YWdlOiBudW1iZXI7XG4gIHN0YXJ0ZWRfYXQ/OiBzdHJpbmc7XG4gIGNvbXBsZXRlZF9hdD86IHN0cmluZztcbiAgY3JlYXRlZF9hdD86IHN0cmluZztcbiAgdXBkYXRlZF9hdD86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFVybFN1Ym1pc3Npb24ge1xuICBpZDogc3RyaW5nO1xuICBqb2JfaWQ6IHN0cmluZztcbiAgdXJsOiBzdHJpbmc7XG4gIHN0YXR1czogc3RyaW5nO1xuICByZXRyeV9jb3VudDogbnVtYmVyO1xuICBzZXJ2aWNlX2FjY291bnRfaWQ/OiBzdHJpbmc7XG4gIGVycm9yX21lc3NhZ2U/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogR29vZ2xlIEluZGV4aW5nIFByb2Nlc3NvclxuICogXG4gKiBQcm9mZXNzaW9uYWwtZ3JhZGUgVVJMIGluZGV4aW5nIHN5c3RlbSB0aGF0IGludGVncmF0ZXMgd2l0aCBHb29nbGUncyBJbmRleGluZyBBUElcbiAqIHRvIGF1dG9tYXRpY2FsbHkgc3VibWl0IFVSTHMgZm9yIGluZGV4aW5nIHdpdGggcHJvcGVyIGVycm9yIGhhbmRsaW5nLCByZXRyeSBsb2dpYyxcbiAqIGFuZCBxdW90YSBtYW5hZ2VtZW50IGFjcm9zcyBtdWx0aXBsZSBzZXJ2aWNlIGFjY291bnRzLlxuICovXG5leHBvcnQgY2xhc3MgR29vZ2xlSW5kZXhpbmdQcm9jZXNzb3Ige1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogR29vZ2xlSW5kZXhpbmdQcm9jZXNzb3I7XG4gIHByaXZhdGUgZ29vZ2xlQXV0aDogR29vZ2xlQXV0aFNlcnZpY2U7XG4gIHByaXZhdGUgd2Vic29ja2V0U2VydmljZTogV2ViU29ja2V0U2VydmljZTtcbiAgcHJpdmF0ZSBqb2JMb2dnZXI6IEpvYkxvZ2dpbmdTZXJ2aWNlO1xuICBwcml2YXRlIHByb2Nlc3NpbmdKb2JzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5nb29nbGVBdXRoID0gR29vZ2xlQXV0aFNlcnZpY2UuZ2V0SW5zdGFuY2UoKTtcbiAgICB0aGlzLndlYnNvY2tldFNlcnZpY2UgPSBXZWJTb2NrZXRTZXJ2aWNlLmdldEluc3RhbmNlKCk7XG4gICAgdGhpcy5qb2JMb2dnZXIgPSBKb2JMb2dnaW5nU2VydmljZS5nZXRJbnN0YW5jZSgpO1xuICB9XG5cbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IEdvb2dsZUluZGV4aW5nUHJvY2Vzc29yIHtcbiAgICBpZiAoIUdvb2dsZUluZGV4aW5nUHJvY2Vzc29yLmluc3RhbmNlKSB7XG4gICAgICBHb29nbGVJbmRleGluZ1Byb2Nlc3Nvci5pbnN0YW5jZSA9IG5ldyBHb29nbGVJbmRleGluZ1Byb2Nlc3NvcigpO1xuICAgIH1cbiAgICByZXR1cm4gR29vZ2xlSW5kZXhpbmdQcm9jZXNzb3IuaW5zdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyBhIGNvbXBsZXRlIGluZGV4aW5nIGpvYlxuICAgKiBFeHRyYWN0cyBVUkxzLCBjcmVhdGVzIHN1Ym1pc3Npb25zLCBhbmQgcHJvY2Vzc2VzIGVhY2ggVVJMIHRocm91Z2ggR29vZ2xlJ3MgQVBJXG4gICAqL1xuICBhc3luYyBwcm9jZXNzSW5kZXhpbmdKb2Ioam9iSWQ6IHN0cmluZyk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PiB7XG4gICAgaWYgKHRoaXMucHJvY2Vzc2luZ0pvYnMuaGFzKGpvYklkKSkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnSm9iIGlzIGFscmVhZHkgYmVpbmcgcHJvY2Vzc2VkJyB9O1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBMb2NrIHRoZSBqb2IgdG8gcHJldmVudCBjb25jdXJyZW50IHByb2Nlc3NpbmdcbiAgICAgIGNvbnN0IGxvY2tSZXN1bHQgPSBhd2FpdCB0aGlzLmxvY2tKb2JGb3JQcm9jZXNzaW5nKGpvYklkKTtcbiAgICAgIGlmICghbG9ja1Jlc3VsdCkge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdGYWlsZWQgdG8gbG9jayBqb2IgLSBtYXkgYWxyZWFkeSBiZSBwcm9jZXNzaW5nJyB9O1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByb2Nlc3NpbmdKb2JzLmFkZChqb2JJZCk7XG4gICAgICBjb25zb2xlLmxvZyhg8J+agCBTdGFydGluZyBpbmRleGluZyBqb2IgJHtqb2JJZH1gKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IGpvYiBkZXRhaWxzXG4gICAgICBjb25zdCBqb2IgPSBhd2FpdCB0aGlzLmdldEpvYkRldGFpbHMoam9iSWQpO1xuICAgICAgaWYgKCFqb2IpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnSm9iIG5vdCBmb3VuZCcgfTtcbiAgICAgIH1cblxuICAgICAgLy8gTG9nIGpvYiBzdGFydFxuICAgICAgYXdhaXQgdGhpcy5qb2JMb2dnZXIubG9nSm9iU3RhcnRlZChqb2JJZCwgam9iLm5hbWUsIGpvYi50b3RhbF91cmxzIHx8IDApO1xuXG4gICAgICAvLyBVcGRhdGUgam9iIHN0YXR1cyB0byBydW5uaW5nXG4gICAgICBhd2FpdCB0aGlzLnVwZGF0ZUpvYlN0YXR1cyhqb2JJZCwgJ3J1bm5pbmcnLCB7IFxuICAgICAgICBzdGFydGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIHByb2Nlc3NlZF91cmxzOiAwLFxuICAgICAgICBzdWNjZXNzZnVsX3VybHM6IDAsXG4gICAgICAgIGZhaWxlZF91cmxzOiAwLFxuICAgICAgICBwcm9ncmVzc19wZXJjZW50YWdlOiAwXG4gICAgICB9KTtcblxuICAgICAgLy8gRXh0cmFjdCBVUkxzIGZyb20gam9iIHNvdXJjZSBkYXRhXG4gICAgICBjb25zdCB1cmxzID0gYXdhaXQgdGhpcy5leHRyYWN0VXJsc0Zyb21Kb2JTb3VyY2Uoam9iKTtcbiAgICAgIGlmICh1cmxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFVSTHMgZm91bmQgdG8gcHJvY2VzcyBpbiBqb2Igc291cmNlIGRhdGEnKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYPCfk4sgRm91bmQgJHt1cmxzLmxlbmd0aH0gVVJMcyB0byBwcm9jZXNzYCk7XG5cbiAgICAgIC8vIExvZyBVUkwgZXh0cmFjdGlvblxuICAgICAgYXdhaXQgdGhpcy5qb2JMb2dnZXIubG9nSm9iRXZlbnQoe1xuICAgICAgICBqb2JfaWQ6IGpvYklkLFxuICAgICAgICBsZXZlbDogJ0lORk8nLFxuICAgICAgICBtZXNzYWdlOiBgRm91bmQgJHt1cmxzLmxlbmd0aH0gVVJMcyB0byBwcm9jZXNzYCxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBldmVudF90eXBlOiAndXJsc19leHRyYWN0ZWQnLFxuICAgICAgICAgIHVybF9jb3VudDogdXJscy5sZW5ndGgsXG4gICAgICAgICAgam9iX3R5cGU6IGpvYi50eXBlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBDcmVhdGUgVVJMIHN1Ym1pc3Npb25zIGZvciB0cmFja2luZ1xuICAgICAgYXdhaXQgdGhpcy5jcmVhdGVVcmxTdWJtaXNzaW9uc0ZvckpvYihqb2JJZCwgdXJscyk7XG5cbiAgICAgIC8vIFByb2Nlc3MgYWxsIFVSTHMgdGhyb3VnaCBHb29nbGUncyBJbmRleGluZyBBUElcbiAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc1VybFN1Ym1pc3Npb25zV2l0aEdvb2dsZUFQSShqb2IpO1xuXG4gICAgICAvLyBHZXQgZmluYWwgc3RhdHNcbiAgICAgIGNvbnN0IGZpbmFsSm9iID0gYXdhaXQgdGhpcy5nZXRKb2JEZXRhaWxzKGpvYklkKTtcbiAgICAgIGNvbnN0IHByb2Nlc3NpbmdUaW1lTXMgPSBmaW5hbEpvYj8uc3RhcnRlZF9hdCA/IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gbmV3IERhdGUoZmluYWxKb2Iuc3RhcnRlZF9hdCkuZ2V0VGltZSgpIDogdW5kZWZpbmVkO1xuXG4gICAgICAvLyBNYXJrIGpvYiBhcyBjb21wbGV0ZWRcbiAgICAgIGF3YWl0IHRoaXMudXBkYXRlSm9iU3RhdHVzKGpvYklkLCAnY29tcGxldGVkJywgeyBcbiAgICAgICAgY29tcGxldGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH0pO1xuXG4gICAgICAvLyBMb2cgam9iIGNvbXBsZXRpb25cbiAgICAgIGF3YWl0IHRoaXMuam9iTG9nZ2VyLmxvZ0pvYkNvbXBsZXRlZChqb2JJZCwgam9iLm5hbWUsIHtcbiAgICAgICAgdG90YWxfdXJsczogZmluYWxKb2I/LnRvdGFsX3VybHMgfHwgMCxcbiAgICAgICAgc3VjY2Vzc2Z1bF91cmxzOiBmaW5hbEpvYj8uc3VjY2Vzc2Z1bF91cmxzIHx8IDAsXG4gICAgICAgIGZhaWxlZF91cmxzOiBmaW5hbEpvYj8uZmFpbGVkX3VybHMgfHwgMCxcbiAgICAgICAgcHJvY2Vzc2luZ190aW1lX21zOiBwcm9jZXNzaW5nVGltZU1zXG4gICAgICB9KTtcblxuICAgICAgLy8gU2VuZCByZWFsLXRpbWUgY29tcGxldGlvbiB1cGRhdGVcbiAgICAgIHRoaXMud2Vic29ja2V0U2VydmljZS5icm9hZGNhc3RKb2JVcGRhdGUoam9iLnVzZXJfaWQsIGpvYklkLCB7XG4gICAgICAgIHN0YXR1czogJ2NvbXBsZXRlZCcsXG4gICAgICAgIHByb2dyZXNzOiB7XG4gICAgICAgICAgdG90YWxfdXJsczogZmluYWxKb2I/LnRvdGFsX3VybHMgfHwgMCxcbiAgICAgICAgICBwcm9jZXNzZWRfdXJsczogZmluYWxKb2I/LnByb2Nlc3NlZF91cmxzIHx8IDAsXG4gICAgICAgICAgc3VjY2Vzc2Z1bF91cmxzOiBmaW5hbEpvYj8uc3VjY2Vzc2Z1bF91cmxzIHx8IDAsXG4gICAgICAgICAgZmFpbGVkX3VybHM6IGZpbmFsSm9iPy5mYWlsZWRfdXJscyB8fCAwLFxuICAgICAgICAgIHByb2dyZXNzX3BlcmNlbnRhZ2U6IDEwMFxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coYOKchSBJbmRleGluZyBqb2IgJHtqb2JJZH0gY29tcGxldGVkIHN1Y2Nlc3NmdWxseWApO1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBJbmRleGluZyBqb2IgJHtqb2JJZH0gZmFpbGVkOmAsIGVycm9yKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IGpvYiBkZXRhaWxzIGZvciBsb2dnaW5nXG4gICAgICBjb25zdCBqb2IgPSBhd2FpdCB0aGlzLmdldEpvYkRldGFpbHMoam9iSWQpO1xuICAgICAgXG4gICAgICAvLyBMb2cgam9iIGZhaWx1cmVcbiAgICAgIGlmIChqb2IpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5qb2JMb2dnZXIubG9nSm9iRmFpbGVkKGpvYklkLCBqb2IubmFtZSwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicsIHtcbiAgICAgICAgICBlcnJvcl90eXBlOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IuY29uc3RydWN0b3IubmFtZSA6ICdVbmtub3duRXJyb3InLFxuICAgICAgICAgIHN0YWNrX3RyYWNlOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3Iuc3RhY2sgOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIE1hcmsgam9iIGFzIGZhaWxlZFxuICAgICAgYXdhaXQgdGhpcy51cGRhdGVKb2JTdGF0dXMoam9iSWQsICdmYWlsZWQnLCB7IFxuICAgICAgICBlcnJvcl9tZXNzYWdlOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyxcbiAgICAgICAgbG9ja2VkX2F0OiBudWxsLFxuICAgICAgICBsb2NrZWRfYnk6IG51bGxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMucHJvY2Vzc2luZ0pvYnMuZGVsZXRlKGpvYklkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdCBVUkxzIGZyb20gam9iIHNvdXJjZSBkYXRhIGJhc2VkIG9uIGpvYiB0eXBlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGV4dHJhY3RVcmxzRnJvbUpvYlNvdXJjZShqb2I6IEluZGV4aW5nSm9iKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoam9iLnR5cGUgPT09ICdtYW51YWwnKSB7XG4gICAgICAgIC8vIEZvciBtYW51YWwgam9icywgVVJMcyBhcmUgc3RvcmVkIGluIHNvdXJjZV9kYXRhLnVybHNcbiAgICAgICAgY29uc3QgdXJscyA9IGpvYi5zb3VyY2VfZGF0YT8udXJscyB8fCBbXTtcbiAgICAgICAgY29uc29sZS5sb2coYPCfk50gTWFudWFsIGpvYjogZXh0cmFjdGVkICR7dXJscy5sZW5ndGh9IFVSTHNgKTtcbiAgICAgICAgcmV0dXJuIHVybHM7XG4gICAgICB9IGVsc2UgaWYgKGpvYi50eXBlID09PSAnc2l0ZW1hcCcpIHtcbiAgICAgICAgLy8gRm9yIHNpdGVtYXAgam9icywgcGFyc2UgdGhlIHNpdGVtYXAgVVJMXG4gICAgICAgIGNvbnN0IHNpdGVtYXBVcmwgPSBqb2Iuc291cmNlX2RhdGE/LnNpdGVtYXBVcmw7XG4gICAgICAgIGlmICghc2l0ZW1hcFVybCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2l0ZW1hcCBVUkwgZm91bmQgaW4gam9iIHNvdXJjZSBkYXRhJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coYPCfl7rvuI8gU2l0ZW1hcCBqb2I6IHBhcnNpbmcgJHtzaXRlbWFwVXJsfWApO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wYXJzZVNpdGVtYXBVcmxzKHNpdGVtYXBVcmwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBleHRyYWN0aW5nIFVSTHMgZnJvbSBqb2Igc291cmNlOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBzaXRlbWFwIFhNTCB0byBleHRyYWN0IGFsbCBVUkxzXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHBhcnNlU2l0ZW1hcFVybHMoc2l0ZW1hcFVybDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+UjSBGZXRjaGluZyBzaXRlbWFwOiAke3NpdGVtYXBVcmx9YCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHNpdGVtYXBVcmwpO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBzaXRlbWFwOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB4bWxDb250ZW50ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgY29uc3QgeG1sMmpzID0gYXdhaXQgaW1wb3J0KCd4bWwyanMnKTtcbiAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyB4bWwyanMuUGFyc2VyKCk7XG4gICAgICBjb25zdCBwYXJzZWRYbWwgPSBhd2FpdCBwYXJzZXIucGFyc2VTdHJpbmdQcm9taXNlKHhtbENvbnRlbnQpO1xuXG4gICAgICBjb25zdCB1cmxzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgXG4gICAgICAvLyBIYW5kbGUgcmVndWxhciBzaXRlbWFwIHdpdGggVVJMIGVudHJpZXNcbiAgICAgIGlmIChwYXJzZWRYbWwudXJsc2V0Py51cmwpIHtcbiAgICAgICAgcGFyc2VkWG1sLnVybHNldC51cmwuZm9yRWFjaCgodXJsRW50cnk6IGFueSkgPT4ge1xuICAgICAgICAgIGlmICh1cmxFbnRyeS5sb2M/LlswXSkge1xuICAgICAgICAgICAgdXJscy5wdXNoKHVybEVudHJ5LmxvY1swXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSGFuZGxlIHNpdGVtYXAgaW5kZXggd2l0aCBuZXN0ZWQgc2l0ZW1hcHNcbiAgICAgIGlmIChwYXJzZWRYbWwuc2l0ZW1hcGluZGV4Py5zaXRlbWFwKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc2l0ZW1hcEVudHJ5IG9mIHBhcnNlZFhtbC5zaXRlbWFwaW5kZXguc2l0ZW1hcCkge1xuICAgICAgICAgIGlmIChzaXRlbWFwRW50cnkubG9jPy5bMF0pIHtcbiAgICAgICAgICAgIGNvbnN0IG5lc3RlZFVybHMgPSBhd2FpdCB0aGlzLnBhcnNlU2l0ZW1hcFVybHMoc2l0ZW1hcEVudHJ5LmxvY1swXSk7XG4gICAgICAgICAgICB1cmxzLnB1c2goLi4ubmVzdGVkVXJscyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKGDinIUgRXh0cmFjdGVkICR7dXJscy5sZW5ndGh9IFVSTHMgZnJvbSBzaXRlbWFwYCk7XG4gICAgICByZXR1cm4gdXJscztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyBzaXRlbWFwOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU2l0ZW1hcCBwYXJzaW5nIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIFVSTCBzdWJtaXNzaW9uIHJlY29yZHMgZm9yIHRyYWNraW5nIGluZGl2aWR1YWwgVVJMIHByb2Nlc3NpbmdcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlVXJsU3VibWlzc2lvbnNGb3JKb2Ioam9iSWQ6IHN0cmluZywgdXJsczogc3RyaW5nW10pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYPCfk4ogQ3JlYXRpbmcgJHt1cmxzLmxlbmd0aH0gVVJMIHN1Ym1pc3Npb24gcmVjb3Jkc2ApO1xuICAgICAgXG4gICAgICBjb25zdCBzdWJtaXNzaW9ucyA9IHVybHMubWFwKHVybCA9PiAoe1xuICAgICAgICBqb2JfaWQ6IGpvYklkLFxuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgc3RhdHVzOiAncGVuZGluZycsXG4gICAgICAgIHJldHJ5X2NvdW50OiAwLFxuICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSkpO1xuXG4gICAgICAvLyBJbnNlcnQgc3VibWlzc2lvbnMgaW4gYmF0Y2hlcyB0byBhdm9pZCBkYXRhYmFzZSBsaW1pdHNcbiAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IDEwMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3VibWlzc2lvbnMubGVuZ3RoOyBpICs9IGJhdGNoU2l6ZSkge1xuICAgICAgICBjb25zdCBiYXRjaCA9IHN1Ym1pc3Npb25zLnNsaWNlKGksIGkgKyBiYXRjaFNpemUpO1xuICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZUFkbWluXG4gICAgICAgICAgLmZyb20oJ2luZGJfaW5kZXhpbmdfdXJsX3N1Ym1pc3Npb25zJylcbiAgICAgICAgICAuaW5zZXJ0KGJhdGNoKTtcblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgVVJMIHN1Ym1pc3Npb25zOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGpvYiB3aXRoIHRvdGFsIFVSTCBjb3VudFxuICAgICAgYXdhaXQgc3VwYWJhc2VBZG1pblxuICAgICAgICAuZnJvbSgnaW5kYl9pbmRleGluZ19qb2JzJylcbiAgICAgICAgLnVwZGF0ZSh7IFxuICAgICAgICAgIHRvdGFsX3VybHM6IHVybHMubGVuZ3RoLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9KVxuICAgICAgICAuZXEoJ2lkJywgam9iSWQpO1xuXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIENyZWF0ZWQgJHt1cmxzLmxlbmd0aH0gVVJMIHN1Ym1pc3Npb24gcmVjb3Jkc2ApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBVUkwgc3VibWlzc2lvbnM6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgYWxsIFVSTCBzdWJtaXNzaW9ucyB0aHJvdWdoIEdvb2dsZSdzIEluZGV4aW5nIEFQSVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBwcm9jZXNzVXJsU3VibWlzc2lvbnNXaXRoR29vZ2xlQVBJKGpvYjogSW5kZXhpbmdKb2IpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYPCflIQgUHJvY2Vzc2luZyBVUkwgc3VibWlzc2lvbnMgZm9yIGpvYiAke2pvYi5pZH1gKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IGFjdGl2ZSBzZXJ2aWNlIGFjY291bnRzIGZvciBsb2FkIGJhbGFuY2luZ1xuICAgICAgY29uc3QgeyBkYXRhOiBzZXJ2aWNlQWNjb3VudHMsIGVycm9yOiBzYUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZUFkbWluXG4gICAgICAgIC5mcm9tKCdpbmRiX2dvb2dsZV9zZXJ2aWNlX2FjY291bnRzJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIGpvYi51c2VyX2lkKVxuICAgICAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpO1xuXG4gICAgICBpZiAoc2FFcnJvciB8fCAhc2VydmljZUFjY291bnRzIHx8IHNlcnZpY2VBY2NvdW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY3RpdmUgR29vZ2xlIHNlcnZpY2UgYWNjb3VudHMgZm91bmQgZm9yIHVzZXInKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYPCfk4ggVXNpbmcgJHtzZXJ2aWNlQWNjb3VudHMubGVuZ3RofSBzZXJ2aWNlIGFjY291bnRzIGZvciBsb2FkIGJhbGFuY2luZ2ApO1xuXG4gICAgICAvLyBHZXQgcGVuZGluZyBzdWJtaXNzaW9ucyBmb3IgdGhpcyBqb2JcbiAgICAgIGNvbnN0IHsgZGF0YTogc3VibWlzc2lvbnMsIGVycm9yOiBzdWJFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VBZG1pblxuICAgICAgICAuZnJvbSgnaW5kYl9pbmRleGluZ191cmxfc3VibWlzc2lvbnMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCdqb2JfaWQnLCBqb2IuaWQpXG4gICAgICAgIC5lcSgnc3RhdHVzJywgJ3BlbmRpbmcnKVxuICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnKTtcblxuICAgICAgaWYgKHN1YkVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZmV0Y2hpbmcgVVJMIHN1Ym1pc3Npb25zOiAke3N1YkVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc3VibWlzc2lvbnMgfHwgc3VibWlzc2lvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gTm8gcGVuZGluZyBzdWJtaXNzaW9ucyBmb3VuZCBmb3IgcHJvY2Vzc2luZycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKGDwn46vIFByb2Nlc3NpbmcgJHtzdWJtaXNzaW9ucy5sZW5ndGh9IFVSTCBzdWJtaXNzaW9uc2ApO1xuXG4gICAgICBsZXQgcHJvY2Vzc2VkID0gMDtcbiAgICAgIGxldCBzdWNjZXNzZnVsID0gMDtcbiAgICAgIGxldCBmYWlsZWQgPSAwO1xuXG4gICAgICAvLyBQcm9jZXNzIGVhY2ggVVJMIHN1Ym1pc3Npb25cbiAgICAgIGZvciAoY29uc3Qgc3VibWlzc2lvbiBvZiBzdWJtaXNzaW9ucykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFJvdW5kLXJvYmluIHNlcnZpY2UgYWNjb3VudCBzZWxlY3Rpb24gZm9yIGxvYWQgYmFsYW5jaW5nXG4gICAgICAgICAgY29uc3Qgc2VydmljZUFjY291bnQgPSBzZXJ2aWNlQWNjb3VudHNbcHJvY2Vzc2VkICUgc2VydmljZUFjY291bnRzLmxlbmd0aF07XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTG9nIHNlcnZpY2UgYWNjb3VudCB1c2FnZVxuICAgICAgICAgIGF3YWl0IHRoaXMuam9iTG9nZ2VyLmxvZ1NlcnZpY2VBY2NvdW50VXNhZ2Uoam9iLmlkLCBzZXJ2aWNlQWNjb3VudC5lbWFpbCwgJ3NlbGVjdGVkX2Zvcl91cmxfcHJvY2Vzc2luZycpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdldCBhY2Nlc3MgdG9rZW4gZm9yIEdvb2dsZSBBUElcbiAgICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IGF3YWl0IHRoaXMuZ29vZ2xlQXV0aC5nZXRBY2Nlc3NUb2tlbihzZXJ2aWNlQWNjb3VudC5pZCk7XG4gICAgICAgICAgaWYgKCFhY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBTa2lwcGluZyBzZXJ2aWNlIGFjY291bnQgJHtzZXJ2aWNlQWNjb3VudC5pZH0gLSBubyB2YWxpZCBhY2Nlc3MgdG9rZW4gKGxpa2VseSBtaXNzaW5nIGNyZWRlbnRpYWxzKWApO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5qb2JMb2dnZXIubG9nV2FybmluZyhqb2IuaWQsIGBTa2lwcGluZyBzZXJ2aWNlIGFjY291bnQgJHtzZXJ2aWNlQWNjb3VudC5lbWFpbH0gLSBubyB2YWxpZCBhY2Nlc3MgdG9rZW5gLCB7XG4gICAgICAgICAgICAgIHNlcnZpY2VfYWNjb3VudF9pZDogc2VydmljZUFjY291bnQuaWQsXG4gICAgICAgICAgICAgIHNlcnZpY2VfYWNjb3VudF9lbWFpbDogc2VydmljZUFjY291bnQuZW1haWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBzZXJ2aWNlIGFjY291bnQgYW5kIHRyeSB0aGUgbmV4dCBvbmVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTdWJtaXQgVVJMIHRvIEdvb2dsZSdzIEluZGV4aW5nIEFQSVxuICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgYXdhaXQgdGhpcy5zdWJtaXRVcmxUb0dvb2dsZUluZGV4aW5nQVBJKHN1Ym1pc3Npb24udXJsLCBhY2Nlc3NUb2tlbik7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2VUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVcGRhdGUgc3VibWlzc2lvbiBhcyBzdWNjZXNzZnVsXG4gICAgICAgICAgYXdhaXQgc3VwYWJhc2VBZG1pblxuICAgICAgICAgICAgLmZyb20oJ2luZGJfaW5kZXhpbmdfdXJsX3N1Ym1pc3Npb25zJylcbiAgICAgICAgICAgIC51cGRhdGUoe1xuICAgICAgICAgICAgICBzdGF0dXM6ICdzdWJtaXR0ZWQnLFxuICAgICAgICAgICAgICBzdWJtaXR0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgc2VydmljZV9hY2NvdW50X2lkOiBzZXJ2aWNlQWNjb3VudC5pZCxcbiAgICAgICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmVxKCdpZCcsIHN1Ym1pc3Npb24uaWQpO1xuXG4gICAgICAgICAgLy8gVXBkYXRlIHF1b3RhIHVzYWdlIGZvciB0aGUgc2VydmljZSBhY2NvdW50ICgtMSBmb3Igc3VjY2Vzc2Z1bCByZXF1ZXN0KVxuICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlUXVvdGFVc2FnZShzZXJ2aWNlQWNjb3VudC5pZCwgdHJ1ZSk7XG5cbiAgICAgICAgICAvLyBMb2cgc3VjY2Vzc2Z1bCBVUkwgcHJvY2Vzc2luZ1xuICAgICAgICAgIGF3YWl0IHRoaXMuam9iTG9nZ2VyLmxvZ1VybFByb2Nlc3NlZChqb2IuaWQsIHN1Ym1pc3Npb24udXJsLCB0cnVlLCB1bmRlZmluZWQsIHJlc3BvbnNlVGltZSk7XG4gICAgICAgICAgY29uc3QgcmVtYWluaW5nUXVvdGEgPSBhd2FpdCB0aGlzLmdldFJlbWFpbmluZ1F1b3RhKHNlcnZpY2VBY2NvdW50LmlkKTtcbiAgICAgICAgICBhd2FpdCB0aGlzLmpvYkxvZ2dlci5sb2dRdW90YVVzYWdlKGpvYi5pZCwgc2VydmljZUFjY291bnQuaWQsIHJlbWFpbmluZ1F1b3RhKTtcblxuICAgICAgICAgIHN1Y2Nlc3NmdWwrKztcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFN1Y2Nlc3NmdWxseSBpbmRleGVkOiAke3N1Ym1pc3Npb24udXJsfWApO1xuXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihg4p2MIEZhaWxlZCB0byBpbmRleCAke3N1Ym1pc3Npb24udXJsfTpgLCBlcnJvcik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gR2V0IHRoZSBzZXJ2aWNlIGFjY291bnQgZm9yIHRoaXMgc3VibWlzc2lvblxuICAgICAgICAgIGNvbnN0IHNlcnZpY2VBY2NvdW50ID0gc2VydmljZUFjY291bnRzW3Byb2Nlc3NlZCAlIHNlcnZpY2VBY2NvdW50cy5sZW5ndGhdO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIExvZyBmYWlsZWQgVVJMIHByb2Nlc3NpbmdcbiAgICAgICAgICBhd2FpdCB0aGlzLmpvYkxvZ2dlci5sb2dVcmxQcm9jZXNzZWQoam9iLmlkLCBzdWJtaXNzaW9uLnVybCwgZmFsc2UsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVcGRhdGUgc3VibWlzc2lvbiBhcyBmYWlsZWRcbiAgICAgICAgICBhd2FpdCBzdXBhYmFzZUFkbWluXG4gICAgICAgICAgICAuZnJvbSgnaW5kYl9pbmRleGluZ191cmxfc3VibWlzc2lvbnMnKVxuICAgICAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgICAgIHN0YXR1czogJ2ZhaWxlZCcsXG4gICAgICAgICAgICAgIGVycm9yX21lc3NhZ2U6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0luZGV4aW5nIGZhaWxlZCcsXG4gICAgICAgICAgICAgIHJldHJ5X2NvdW50OiBzdWJtaXNzaW9uLnJldHJ5X2NvdW50ICsgMSxcbiAgICAgICAgICAgICAgc2VydmljZV9hY2NvdW50X2lkOiBzZXJ2aWNlQWNjb3VudC5pZCxcbiAgICAgICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmVxKCdpZCcsIHN1Ym1pc3Npb24uaWQpO1xuXG4gICAgICAgICAgLy8gVXBkYXRlIHF1b3RhIHVzYWdlIGZvciB0aGUgc2VydmljZSBhY2NvdW50IChzdGlsbCBjb3VudHMgYXMgYSByZXF1ZXN0IGF0dGVtcHQpXG4gICAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVRdW90YVVzYWdlKHNlcnZpY2VBY2NvdW50LmlkLCBmYWxzZSk7XG5cbiAgICAgICAgICBmYWlsZWQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHByb2Nlc3NlZCsrO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIGpvYiBwcm9ncmVzcyBpbiByZWFsLXRpbWVcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3NQZXJjZW50YWdlID0gTWF0aC5yb3VuZCgocHJvY2Vzc2VkIC8gc3VibWlzc2lvbnMubGVuZ3RoKSAqIDEwMCk7XG4gICAgICAgIGF3YWl0IHN1cGFiYXNlQWRtaW5cbiAgICAgICAgICAuZnJvbSgnaW5kYl9pbmRleGluZ19qb2JzJylcbiAgICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICAgIHByb2Nlc3NlZF91cmxzOiBwcm9jZXNzZWQsXG4gICAgICAgICAgICBzdWNjZXNzZnVsX3VybHM6IHN1Y2Nlc3NmdWwsXG4gICAgICAgICAgICBmYWlsZWRfdXJsczogZmFpbGVkLFxuICAgICAgICAgICAgcHJvZ3Jlc3NfcGVyY2VudGFnZTogcHJvZ3Jlc3NQZXJjZW50YWdlLFxuICAgICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZXEoJ2lkJywgam9iLmlkKTtcblxuICAgICAgICAvLyBMb2cgcHJvZ3Jlc3MgdXBkYXRlIGV2ZXJ5IDEwIHByb2Nlc3NlZCBVUkxzIG9yIG9uIGNvbXBsZXRpb25cbiAgICAgICAgaWYgKHByb2Nlc3NlZCAlIDEwID09PSAwIHx8IHByb2Nlc3NlZCA9PT0gc3VibWlzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5qb2JMb2dnZXIubG9nUHJvZ3Jlc3NVcGRhdGUoam9iLmlkLCBwcm9ncmVzc1BlcmNlbnRhZ2UsIHByb2Nlc3NlZCwgc3VibWlzc2lvbnMubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlbmQgcmVhbC10aW1lIHByb2dyZXNzIHVwZGF0ZSB2aWEgV2ViU29ja2V0XG4gICAgICAgIHRoaXMud2Vic29ja2V0U2VydmljZS5icm9hZGNhc3RKb2JVcGRhdGUoam9iLnVzZXJfaWQsIGpvYi5pZCwge1xuICAgICAgICAgIHN0YXR1czogJ3J1bm5pbmcnLFxuICAgICAgICAgIHByb2dyZXNzOiB7XG4gICAgICAgICAgICB0b3RhbF91cmxzOiBzdWJtaXNzaW9ucy5sZW5ndGgsXG4gICAgICAgICAgICBwcm9jZXNzZWRfdXJsczogcHJvY2Vzc2VkLFxuICAgICAgICAgICAgc3VjY2Vzc2Z1bF91cmxzOiBzdWNjZXNzZnVsLFxuICAgICAgICAgICAgZmFpbGVkX3VybHM6IGZhaWxlZCxcbiAgICAgICAgICAgIHByb2dyZXNzX3BlcmNlbnRhZ2U6IHByb2dyZXNzUGVyY2VudGFnZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVzcGVjdCBHb29nbGUgQVBJIHJhdGUgbGltaXRzXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYPCfk4ogSm9iIHByb2Nlc3NpbmcgY29tcGxldGU6ICR7c3VjY2Vzc2Z1bH0gc3VjY2Vzc2Z1bCwgJHtmYWlsZWR9IGZhaWxlZCBvdXQgb2YgJHtwcm9jZXNzZWR9IHRvdGFsYCk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcHJvY2Vzc2luZyBVUkwgc3VibWlzc2lvbnM6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN1Ym1pdCBpbmRpdmlkdWFsIFVSTCB0byBHb29nbGUncyBJbmRleGluZyBBUElcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgc3VibWl0VXJsVG9Hb29nbGVJbmRleGluZ0FQSSh1cmw6IHN0cmluZywgYWNjZXNzVG9rZW46IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGFwaVVybCA9ICdodHRwczovL2luZGV4aW5nLmdvb2dsZWFwaXMuY29tL3YzL3VybE5vdGlmaWNhdGlvbnM6cHVibGlzaCc7XG4gICAgXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhcGlVcmwsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgdHlwZTogJ1VSTF9VUERBVEVEJ1xuICAgICAgfSlcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yRGF0YS5lcnJvcj8ubWVzc2FnZSB8fCBgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBHb29nbGUgSW5kZXhpbmcgQVBJIGVycm9yOiAke2Vycm9yTWVzc2FnZX1gKTtcbiAgICB9XG5cbiAgICAvLyBMb2cgc3VjY2Vzc2Z1bCByZXNwb25zZSBmb3IgZGVidWdnaW5nXG4gICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGNvbnNvbGUubG9nKGDwn46vIEdvb2dsZSBBUEkgcmVzcG9uc2UgZm9yICR7dXJsfTpgLCByZXNwb25zZURhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBxdW90YSB1c2FnZSBmb3IgYSBzZXJ2aWNlIGFjY291bnRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgdXBkYXRlUXVvdGFVc2FnZShzZXJ2aWNlQWNjb3VudElkOiBzdHJpbmcsIHN1Y2Nlc3NmdWw6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTsgLy8gWVlZWS1NTS1ERCBmb3JtYXRcbiAgICAgIFxuICAgICAgLy8gR2V0IGN1cnJlbnQgcXVvdGEgdXNhZ2UgZm9yIHRvZGF5XG4gICAgICBjb25zdCB7IGRhdGE6IGN1cnJlbnRVc2FnZSwgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlQWRtaW5cbiAgICAgICAgLmZyb20oJ2luZGJfZ29vZ2xlX3F1b3RhX3VzYWdlJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5lcSgnc2VydmljZV9hY2NvdW50X2lkJywgc2VydmljZUFjY291bnRJZClcbiAgICAgICAgLmVxKCdkYXRlJywgdG9kYXkpXG4gICAgICAgIC5zaW5nbGUoKTtcblxuICAgICAgaWYgKGZldGNoRXJyb3IgJiYgZmV0Y2hFcnJvci5jb2RlICE9PSAnUEdSU1QxMTYnKSB7IC8vIFBHUlNUMTE2ID0gbm8gcm93cyBmb3VuZFxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjdXJyZW50IHF1b3RhIHVzYWdlOicsIGZldGNoRXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBuZXcgdXNhZ2UgbnVtYmVyc1xuICAgICAgY29uc3QgY3VycmVudFJlcXVlc3RzTWFkZSA9IGN1cnJlbnRVc2FnZT8ucmVxdWVzdHNfbWFkZSB8fCAwO1xuICAgICAgY29uc3QgY3VycmVudFJlcXVlc3RzU3VjY2Vzc2Z1bCA9IGN1cnJlbnRVc2FnZT8ucmVxdWVzdHNfc3VjY2Vzc2Z1bCB8fCAwO1xuICAgICAgY29uc3QgY3VycmVudFJlcXVlc3RzRmFpbGVkID0gY3VycmVudFVzYWdlPy5yZXF1ZXN0c19mYWlsZWQgfHwgMDtcblxuICAgICAgY29uc3QgdXBkYXRlZFVzYWdlID0ge1xuICAgICAgICBzZXJ2aWNlX2FjY291bnRfaWQ6IHNlcnZpY2VBY2NvdW50SWQsXG4gICAgICAgIGRhdGU6IHRvZGF5LFxuICAgICAgICByZXF1ZXN0c19tYWRlOiBjdXJyZW50UmVxdWVzdHNNYWRlICsgMSxcbiAgICAgICAgcmVxdWVzdHNfc3VjY2Vzc2Z1bDogc3VjY2Vzc2Z1bCA/IGN1cnJlbnRSZXF1ZXN0c1N1Y2Nlc3NmdWwgKyAxIDogY3VycmVudFJlcXVlc3RzU3VjY2Vzc2Z1bCxcbiAgICAgICAgcmVxdWVzdHNfZmFpbGVkOiBzdWNjZXNzZnVsID8gY3VycmVudFJlcXVlc3RzRmFpbGVkIDogY3VycmVudFJlcXVlc3RzRmFpbGVkICsgMSxcbiAgICAgICAgbGFzdF9yZXF1ZXN0X2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfTtcblxuICAgICAgLy8gSWYgcmVjb3JkIGRvZXNuJ3QgZXhpc3QsIGFkZCBjcmVhdGVkX2F0XG4gICAgICBpZiAoIWN1cnJlbnRVc2FnZSkge1xuICAgICAgICAodXBkYXRlZFVzYWdlIGFzIGFueSkuY3JlYXRlZF9hdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBzZXJ0IHF1b3RhIHVzYWdlIHJlY29yZFxuICAgICAgY29uc3QgeyBlcnJvcjogdXBzZXJ0RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlQWRtaW5cbiAgICAgICAgLmZyb20oJ2luZGJfZ29vZ2xlX3F1b3RhX3VzYWdlJylcbiAgICAgICAgLnVwc2VydCh1cGRhdGVkVXNhZ2UsIHtcbiAgICAgICAgICBvbkNvbmZsaWN0OiAnc2VydmljZV9hY2NvdW50X2lkLGRhdGUnXG4gICAgICAgIH0pO1xuXG4gICAgICBpZiAodXBzZXJ0RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgcXVvdGEgdXNhZ2U6JywgdXBzZXJ0RXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coYPCfk4ogVXBkYXRlZCBxdW90YSBmb3Igc2VydmljZSBhY2NvdW50ICR7c2VydmljZUFjY291bnRJZH06ICR7dXBkYXRlZFVzYWdlLnJlcXVlc3RzX21hZGV9IHJlcXVlc3RzICgke3VwZGF0ZWRVc2FnZS5yZXF1ZXN0c19zdWNjZXNzZnVsfSBzdWNjZXNzZnVsLCAke3VwZGF0ZWRVc2FnZS5yZXF1ZXN0c19mYWlsZWR9IGZhaWxlZClgKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gdXBkYXRlUXVvdGFVc2FnZTonLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvY2sgam9iIHRvIHByZXZlbnQgY29uY3VycmVudCBwcm9jZXNzaW5nXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGxvY2tKb2JGb3JQcm9jZXNzaW5nKGpvYklkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbG9ja1RpbWUgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICBjb25zdCBsb2NrSWQgPSBgcHJvY2Vzc29yLSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YDtcblxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VBZG1pblxuICAgICAgICAuZnJvbSgnaW5kYl9pbmRleGluZ19qb2JzJylcbiAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgc3RhdHVzOiAncnVubmluZydcbiAgICAgICAgfSlcbiAgICAgICAgLmVxKCdpZCcsIGpvYklkKVxuICAgICAgICAuZXEoJ3N0YXR1cycsICdwZW5kaW5nJylcbiAgICAgICAgLnNlbGVjdCgpO1xuXG4gICAgICAvLyBTZW5kIHJlYWwtdGltZSBzdGF0dXMgdXBkYXRlXG4gICAgICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gR2V0IHVzZXJfaWQgZnJvbSB0aGUgam9iIGRhdGFcbiAgICAgICAgY29uc3Qgam9iID0gYXdhaXQgdGhpcy5nZXRKb2JEZXRhaWxzKGpvYklkKTtcbiAgICAgICAgaWYgKGpvYikge1xuICAgICAgICAgIHRoaXMud2Vic29ja2V0U2VydmljZS5icm9hZGNhc3RKb2JVcGRhdGUoam9iLnVzZXJfaWQsIGpvYklkLCB7XG4gICAgICAgICAgICBzdGF0dXM6ICdydW5uaW5nJyxcbiAgICAgICAgICAgIHByb2dyZXNzOiB7XG4gICAgICAgICAgICAgIHRvdGFsX3VybHM6IGpvYi50b3RhbF91cmxzLFxuICAgICAgICAgICAgICBwcm9jZXNzZWRfdXJsczogMCxcbiAgICAgICAgICAgICAgc3VjY2Vzc2Z1bF91cmxzOiAwLFxuICAgICAgICAgICAgICBmYWlsZWRfdXJsczogMCxcbiAgICAgICAgICAgICAgcHJvZ3Jlc3NfcGVyY2VudGFnZTogMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2NraW5nIGpvYjonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3VjY2VzcyA9IGRhdGEgJiYgZGF0YS5sZW5ndGggPiAwO1xuICAgICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBKb2IgJHtqb2JJZH0gaXMgYWxyZWFkeSBsb2NrZWQgb3Igbm90IGluIHBlbmRpbmcgc3RhdHVzYCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2NraW5nIGpvYjonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBqb2IgZGV0YWlscyBmcm9tIGRhdGFiYXNlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGdldEpvYkRldGFpbHMoam9iSWQ6IHN0cmluZyk6IFByb21pc2U8SW5kZXhpbmdKb2IgfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlQWRtaW5cbiAgICAgICAgLmZyb20oJ2luZGJfaW5kZXhpbmdfam9icycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAuZXEoJ2lkJywgam9iSWQpXG4gICAgICAgIC5zaW5nbGUoKTtcblxuICAgICAgcmV0dXJuIGVycm9yID8gbnVsbCA6IGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgam9iIGRldGFpbHM6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBqb2Igc3RhdHVzIGFuZCBhZGRpdGlvbmFsIGZpZWxkc1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyB1cGRhdGVKb2JTdGF0dXMoam9iSWQ6IHN0cmluZywgc3RhdHVzOiBzdHJpbmcsIGV4dHJhRmllbGRzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge30pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgc3VwYWJhc2VBZG1pblxuICAgICAgICAuZnJvbSgnaW5kYl9pbmRleGluZ19qb2JzJylcbiAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAuLi5leHRyYUZpZWxkc1xuICAgICAgICB9KVxuICAgICAgICAuZXEoJ2lkJywgam9iSWQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBqb2Igc3RhdHVzOicsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHJlbWFpbmluZyBxdW90YSBmb3IgYSBzZXJ2aWNlIGFjY291bnRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZ2V0UmVtYWluaW5nUXVvdGEoc2VydmljZUFjY291bnRJZDogc3RyaW5nKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcbiAgICAgIFxuICAgICAgLy8gR2V0IHNlcnZpY2UgYWNjb3VudCBxdW90YSBsaW1pdFxuICAgICAgY29uc3QgeyBkYXRhOiBzZXJ2aWNlQWNjb3VudCB9ID0gYXdhaXQgc3VwYWJhc2VBZG1pblxuICAgICAgICAuZnJvbSgnaW5kYl9nb29nbGVfc2VydmljZV9hY2NvdW50cycpXG4gICAgICAgIC5zZWxlY3QoJ2RhaWx5X3F1b3RhX2xpbWl0JylcbiAgICAgICAgLmVxKCdpZCcsIHNlcnZpY2VBY2NvdW50SWQpXG4gICAgICAgIC5zaW5nbGUoKTtcblxuICAgICAgY29uc3QgZGFpbHlMaW1pdCA9IHNlcnZpY2VBY2NvdW50Py5kYWlseV9xdW90YV9saW1pdCB8fCAyMDA7IC8vIERlZmF1bHQgR29vZ2xlIEFQSSBsaW1pdFxuXG4gICAgICAvLyBHZXQgY3VycmVudCB1c2FnZVxuICAgICAgY29uc3QgeyBkYXRhOiB1c2FnZSB9ID0gYXdhaXQgc3VwYWJhc2VBZG1pblxuICAgICAgICAuZnJvbSgnaW5kYl9nb29nbGVfcXVvdGFfdXNhZ2UnKVxuICAgICAgICAuc2VsZWN0KCdyZXF1ZXN0c19tYWRlJylcbiAgICAgICAgLmVxKCdzZXJ2aWNlX2FjY291bnRfaWQnLCBzZXJ2aWNlQWNjb3VudElkKVxuICAgICAgICAuZXEoJ2RhdGUnLCB0b2RheSlcbiAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICBjb25zdCB1c2VkUmVxdWVzdHMgPSB1c2FnZT8ucmVxdWVzdHNfbWFkZSB8fCAwO1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIGRhaWx5TGltaXQgLSB1c2VkUmVxdWVzdHMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHJlbWFpbmluZyBxdW90YTonLCBlcnJvcik7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cbn0iXSwibmFtZXMiOlsic3VwYWJhc2VBZG1pbiIsIkdvb2dsZUF1dGhTZXJ2aWNlIiwiV2ViU29ja2V0U2VydmljZSIsIkpvYkxvZ2dpbmdTZXJ2aWNlIiwiR29vZ2xlSW5kZXhpbmdQcm9jZXNzb3IiLCJwcm9jZXNzaW5nSm9icyIsIlNldCIsImdvb2dsZUF1dGgiLCJnZXRJbnN0YW5jZSIsIndlYnNvY2tldFNlcnZpY2UiLCJqb2JMb2dnZXIiLCJpbnN0YW5jZSIsInByb2Nlc3NJbmRleGluZ0pvYiIsImpvYklkIiwiaGFzIiwic3VjY2VzcyIsImVycm9yIiwibG9ja1Jlc3VsdCIsImxvY2tKb2JGb3JQcm9jZXNzaW5nIiwiYWRkIiwiY29uc29sZSIsImxvZyIsImpvYiIsImdldEpvYkRldGFpbHMiLCJsb2dKb2JTdGFydGVkIiwibmFtZSIsInRvdGFsX3VybHMiLCJ1cGRhdGVKb2JTdGF0dXMiLCJzdGFydGVkX2F0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwicHJvY2Vzc2VkX3VybHMiLCJzdWNjZXNzZnVsX3VybHMiLCJmYWlsZWRfdXJscyIsInByb2dyZXNzX3BlcmNlbnRhZ2UiLCJ1cmxzIiwiZXh0cmFjdFVybHNGcm9tSm9iU291cmNlIiwibGVuZ3RoIiwiRXJyb3IiLCJsb2dKb2JFdmVudCIsImpvYl9pZCIsImxldmVsIiwibWVzc2FnZSIsIm1ldGFkYXRhIiwiZXZlbnRfdHlwZSIsInVybF9jb3VudCIsImpvYl90eXBlIiwidHlwZSIsImNyZWF0ZVVybFN1Ym1pc3Npb25zRm9ySm9iIiwicHJvY2Vzc1VybFN1Ym1pc3Npb25zV2l0aEdvb2dsZUFQSSIsImZpbmFsSm9iIiwicHJvY2Vzc2luZ1RpbWVNcyIsImdldFRpbWUiLCJ1bmRlZmluZWQiLCJjb21wbGV0ZWRfYXQiLCJsb2dKb2JDb21wbGV0ZWQiLCJwcm9jZXNzaW5nX3RpbWVfbXMiLCJicm9hZGNhc3RKb2JVcGRhdGUiLCJ1c2VyX2lkIiwic3RhdHVzIiwicHJvZ3Jlc3MiLCJsb2dKb2JGYWlsZWQiLCJlcnJvcl90eXBlIiwic3RhY2tfdHJhY2UiLCJzdGFjayIsImVycm9yX21lc3NhZ2UiLCJsb2NrZWRfYXQiLCJsb2NrZWRfYnkiLCJkZWxldGUiLCJzb3VyY2VfZGF0YSIsInNpdGVtYXBVcmwiLCJwYXJzZVNpdGVtYXBVcmxzIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwic3RhdHVzVGV4dCIsInhtbENvbnRlbnQiLCJ0ZXh0IiwieG1sMmpzIiwicGFyc2VyIiwiUGFyc2VyIiwicGFyc2VkWG1sIiwicGFyc2VTdHJpbmdQcm9taXNlIiwidXJsc2V0IiwidXJsIiwiZm9yRWFjaCIsInVybEVudHJ5IiwibG9jIiwicHVzaCIsInNpdGVtYXBpbmRleCIsInNpdGVtYXAiLCJzaXRlbWFwRW50cnkiLCJuZXN0ZWRVcmxzIiwic3VibWlzc2lvbnMiLCJtYXAiLCJyZXRyeV9jb3VudCIsImNyZWF0ZWRfYXQiLCJ1cGRhdGVkX2F0IiwiYmF0Y2hTaXplIiwiaSIsImJhdGNoIiwic2xpY2UiLCJmcm9tIiwiaW5zZXJ0IiwidXBkYXRlIiwiZXEiLCJpZCIsImRhdGEiLCJzZXJ2aWNlQWNjb3VudHMiLCJzYUVycm9yIiwic2VsZWN0Iiwic3ViRXJyb3IiLCJvcmRlciIsInByb2Nlc3NlZCIsInN1Y2Nlc3NmdWwiLCJmYWlsZWQiLCJzdWJtaXNzaW9uIiwic2VydmljZUFjY291bnQiLCJsb2dTZXJ2aWNlQWNjb3VudFVzYWdlIiwiZW1haWwiLCJhY2Nlc3NUb2tlbiIsImdldEFjY2Vzc1Rva2VuIiwibG9nV2FybmluZyIsInNlcnZpY2VfYWNjb3VudF9pZCIsInNlcnZpY2VfYWNjb3VudF9lbWFpbCIsInN0YXJ0VGltZSIsIm5vdyIsInN1Ym1pdFVybFRvR29vZ2xlSW5kZXhpbmdBUEkiLCJyZXNwb25zZVRpbWUiLCJzdWJtaXR0ZWRfYXQiLCJ1cGRhdGVRdW90YVVzYWdlIiwibG9nVXJsUHJvY2Vzc2VkIiwicmVtYWluaW5nUXVvdGEiLCJnZXRSZW1haW5pbmdRdW90YSIsImxvZ1F1b3RhVXNhZ2UiLCJwcm9ncmVzc1BlcmNlbnRhZ2UiLCJNYXRoIiwicm91bmQiLCJsb2dQcm9ncmVzc1VwZGF0ZSIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImFwaVVybCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImVycm9yRGF0YSIsImpzb24iLCJjYXRjaCIsImVycm9yTWVzc2FnZSIsInJlc3BvbnNlRGF0YSIsInNlcnZpY2VBY2NvdW50SWQiLCJ0b2RheSIsInNwbGl0IiwiY3VycmVudFVzYWdlIiwiZmV0Y2hFcnJvciIsInNpbmdsZSIsImNvZGUiLCJjdXJyZW50UmVxdWVzdHNNYWRlIiwicmVxdWVzdHNfbWFkZSIsImN1cnJlbnRSZXF1ZXN0c1N1Y2Nlc3NmdWwiLCJyZXF1ZXN0c19zdWNjZXNzZnVsIiwiY3VycmVudFJlcXVlc3RzRmFpbGVkIiwicmVxdWVzdHNfZmFpbGVkIiwidXBkYXRlZFVzYWdlIiwiZGF0ZSIsImxhc3RfcmVxdWVzdF9hdCIsInVwc2VydEVycm9yIiwidXBzZXJ0Iiwib25Db25mbGljdCIsImxvY2tUaW1lIiwibG9ja0lkIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHIiLCJleHRyYUZpZWxkcyIsImRhaWx5TGltaXQiLCJkYWlseV9xdW90YV9saW1pdCIsInVzYWdlIiwidXNlZFJlcXVlc3RzIiwibWF4Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/google-indexing-processor.ts\n");

/***/ }),

/***/ "(rsc)/./lib/job-logging-service.ts":
/*!************************************!*\
  !*** ./lib/job-logging-service.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JobLoggingService: () => (/* binding */ JobLoggingService)\n/* harmony export */ });\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase */ \"(rsc)/./lib/supabase.ts\");\n\n/**\n * Job Logging Service\n * \n * Handles detailed logging of job execution events to the indb_indexing_job_logs table\n * Provides comprehensive tracking of job processing steps, errors, and performance metrics\n */ class JobLoggingService {\n    constructor(){}\n    static getInstance() {\n        if (!JobLoggingService.instance) {\n            JobLoggingService.instance = new JobLoggingService();\n        }\n        return JobLoggingService.instance;\n    }\n    /**\n   * Log a job event to the database\n   */ async logJobEvent(entry) {\n        try {\n            const { error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabaseAdmin.from('indb_indexing_job_logs').insert({\n                job_id: entry.job_id,\n                level: entry.level.toLowerCase(),\n                message: entry.message,\n                metadata: entry.metadata || null,\n                created_at: new Date().toISOString()\n            });\n            if (error) {\n                console.error('Failed to log job event:', error);\n            }\n        } catch (error) {\n            console.error('Error logging job event:', error);\n        }\n    }\n    /**\n   * Log job start event\n   */ async logJobStarted(jobId, jobName, totalUrls) {\n        await this.logJobEvent({\n            job_id: jobId,\n            level: 'INFO',\n            message: `Job started: ${jobName}`,\n            metadata: {\n                job_name: jobName,\n                event_type: 'job_started',\n                started_at: new Date().toISOString(),\n                total_urls: totalUrls\n            }\n        });\n    }\n    /**\n   * Log job completion event\n   */ async logJobCompleted(jobId, jobName, stats) {\n        await this.logJobEvent({\n            job_id: jobId,\n            level: 'INFO',\n            message: `Job completed: ${jobName}`,\n            metadata: {\n                job_name: jobName,\n                event_type: 'job_completed',\n                completed_at: new Date().toISOString(),\n                ...stats\n            }\n        });\n    }\n    /**\n   * Log job failure event\n   */ async logJobFailed(jobId, jobName, errorMessage, metadata) {\n        await this.logJobEvent({\n            job_id: jobId,\n            level: 'ERROR',\n            message: `Job failed: ${jobName} - ${errorMessage}`,\n            metadata: {\n                job_name: jobName,\n                event_type: 'job_failed',\n                error_message: errorMessage,\n                failed_at: new Date().toISOString(),\n                ...metadata\n            }\n        });\n    }\n    /**\n   * Log URL processing event\n   */ async logUrlProcessed(jobId, url, success, errorMessage, responseTime) {\n        await this.logJobEvent({\n            job_id: jobId,\n            level: success ? 'INFO' : 'ERROR',\n            message: success ? `Successfully indexed URL: ${url}` : `Failed to index URL: ${url}`,\n            metadata: {\n                event_type: 'url_processed',\n                url: url,\n                success: success,\n                error_message: errorMessage,\n                response_time_ms: responseTime,\n                processed_at: new Date().toISOString()\n            }\n        });\n    }\n    /**\n   * Log quota usage event\n   */ async logQuotaUsage(jobId, serviceAccountId, remainingQuota, apiResponse) {\n        await this.logJobEvent({\n            job_id: jobId,\n            level: 'DEBUG',\n            message: `Quota usage updated - ${remainingQuota} requests remaining`,\n            metadata: {\n                event_type: 'quota_usage',\n                service_account_id: serviceAccountId,\n                remaining_quota: remainingQuota,\n                api_response: apiResponse,\n                timestamp: new Date().toISOString()\n            }\n        });\n    }\n    /**\n   * Log service account usage\n   */ async logServiceAccountUsage(jobId, serviceAccountEmail, action) {\n        await this.logJobEvent({\n            job_id: jobId,\n            level: 'DEBUG',\n            message: `Service account ${action}: ${serviceAccountEmail}`,\n            metadata: {\n                event_type: 'service_account_usage',\n                service_account_email: serviceAccountEmail,\n                action: action,\n                timestamp: new Date().toISOString()\n            }\n        });\n    }\n    /**\n   * Log progress update\n   */ async logProgressUpdate(jobId, progress, processedUrls, totalUrls) {\n        await this.logJobEvent({\n            job_id: jobId,\n            level: 'INFO',\n            message: `Progress update: ${processedUrls}/${totalUrls} URLs processed (${progress.toFixed(1)}%)`,\n            metadata: {\n                event_type: 'progress_update',\n                progress_percentage: progress,\n                processed_urls: processedUrls,\n                total_urls: totalUrls,\n                timestamp: new Date().toISOString()\n            }\n        });\n    }\n    /**\n   * Log Google API interaction\n   */ async logGoogleApiCall(jobId, url, statusCode, responseData, errorMessage) {\n        await this.logJobEvent({\n            job_id: jobId,\n            level: statusCode >= 400 ? 'ERROR' : 'DEBUG',\n            message: `Google API call for ${url}: ${statusCode}`,\n            metadata: {\n                event_type: 'google_api_call',\n                url: url,\n                status_code: statusCode,\n                response_data: responseData,\n                error_message: errorMessage,\n                timestamp: new Date().toISOString()\n            }\n        });\n    }\n    /**\n   * Log warning events\n   */ async logWarning(jobId, message, metadata) {\n        await this.logJobEvent({\n            job_id: jobId,\n            level: 'WARN',\n            message: message,\n            metadata: {\n                event_type: 'warning',\n                timestamp: new Date().toISOString(),\n                ...metadata\n            }\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q25DO1FBQ0Y7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBTXlDLGlCQUFpQnRDLEtBQWEsRUFBRWUsR0FBVyxFQUFFd0IsVUFBa0IsRUFBRUMsWUFBa0IsRUFBRTdCLFlBQXFCLEVBQWlCO1FBQy9ILE1BQU0sSUFBSSxDQUFDMUIsV0FBVyxDQUFDO1lBQ3JCSyxRQUFRVTtZQUNSVCxPQUFPZ0QsY0FBYyxNQUFNLFVBQVU7WUFDckM5QyxTQUFTLENBQUMsb0JBQW9CLEVBQUVzQixJQUFJLEVBQUUsRUFBRXdCLFlBQVk7WUFDcEQ3QyxVQUFVO2dCQUNSVSxZQUFZO2dCQUNaVyxLQUFLQTtnQkFDTDBCLGFBQWFGO2dCQUNiRyxlQUFlRjtnQkFDZjVCLGVBQWVEO2dCQUNmZ0IsV0FBVyxJQUFJL0IsT0FBT0MsV0FBVztZQUNuQztRQUNGO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELE1BQU04QyxXQUFXM0MsS0FBYSxFQUFFUCxPQUFlLEVBQUVDLFFBQThCLEVBQWlCO1FBQzlGLE1BQU0sSUFBSSxDQUFDVCxXQUFXLENBQUM7WUFDckJLLFFBQVFVO1lBQ1JULE9BQU87WUFDUEUsU0FBU0E7WUFDVEMsVUFBVTtnQkFDUlUsWUFBWTtnQkFDWnVCLFdBQVcsSUFBSS9CLE9BQU9DLFdBQVc7Z0JBQ2pDLEdBQUdILFFBQVE7WUFDYjtRQUNGO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9saWIvam9iLWxvZ2dpbmctc2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdXBhYmFzZUFkbWluIH0gZnJvbSAnLi9zdXBhYmFzZSc7XG5cbmV4cG9ydCB0eXBlIExvZ0xldmVsID0gJ0lORk8nIHwgJ1dBUk4nIHwgJ0VSUk9SJyB8ICdERUJVRyc7XG5cbmludGVyZmFjZSBKb2JMb2dFbnRyeSB7XG4gIGpvYl9pZDogc3RyaW5nO1xuICBsZXZlbDogTG9nTGV2ZWw7XG4gIG1lc3NhZ2U6IHN0cmluZztcbiAgbWV0YWRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xufVxuXG4vKipcbiAqIEpvYiBMb2dnaW5nIFNlcnZpY2VcbiAqIFxuICogSGFuZGxlcyBkZXRhaWxlZCBsb2dnaW5nIG9mIGpvYiBleGVjdXRpb24gZXZlbnRzIHRvIHRoZSBpbmRiX2luZGV4aW5nX2pvYl9sb2dzIHRhYmxlXG4gKiBQcm92aWRlcyBjb21wcmVoZW5zaXZlIHRyYWNraW5nIG9mIGpvYiBwcm9jZXNzaW5nIHN0ZXBzLCBlcnJvcnMsIGFuZCBwZXJmb3JtYW5jZSBtZXRyaWNzXG4gKi9cbmV4cG9ydCBjbGFzcyBKb2JMb2dnaW5nU2VydmljZSB7XG4gIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBKb2JMb2dnaW5nU2VydmljZTtcblxuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IEpvYkxvZ2dpbmdTZXJ2aWNlIHtcbiAgICBpZiAoIUpvYkxvZ2dpbmdTZXJ2aWNlLmluc3RhbmNlKSB7XG4gICAgICBKb2JMb2dnaW5nU2VydmljZS5pbnN0YW5jZSA9IG5ldyBKb2JMb2dnaW5nU2VydmljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gSm9iTG9nZ2luZ1NlcnZpY2UuaW5zdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogTG9nIGEgam9iIGV2ZW50IHRvIHRoZSBkYXRhYmFzZVxuICAgKi9cbiAgYXN5bmMgbG9nSm9iRXZlbnQoZW50cnk6IEpvYkxvZ0VudHJ5KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlQWRtaW5cbiAgICAgICAgLmZyb20oJ2luZGJfaW5kZXhpbmdfam9iX2xvZ3MnKVxuICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICBqb2JfaWQ6IGVudHJ5LmpvYl9pZCxcbiAgICAgICAgICBsZXZlbDogZW50cnkubGV2ZWwudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICBtZXNzYWdlOiBlbnRyeS5tZXNzYWdlLFxuICAgICAgICAgIG1ldGFkYXRhOiBlbnRyeS5tZXRhZGF0YSB8fCBudWxsLFxuICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9KTtcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2cgam9iIGV2ZW50OicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9nZ2luZyBqb2IgZXZlbnQ6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2cgam9iIHN0YXJ0IGV2ZW50XG4gICAqL1xuICBhc3luYyBsb2dKb2JTdGFydGVkKGpvYklkOiBzdHJpbmcsIGpvYk5hbWU6IHN0cmluZywgdG90YWxVcmxzOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLmxvZ0pvYkV2ZW50KHtcbiAgICAgIGpvYl9pZDogam9iSWQsXG4gICAgICBsZXZlbDogJ0lORk8nLFxuICAgICAgbWVzc2FnZTogYEpvYiBzdGFydGVkOiAke2pvYk5hbWV9YCxcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIGpvYl9uYW1lOiBqb2JOYW1lLFxuICAgICAgICBldmVudF90eXBlOiAnam9iX3N0YXJ0ZWQnLFxuICAgICAgICBzdGFydGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIHRvdGFsX3VybHM6IHRvdGFsVXJsc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZyBqb2IgY29tcGxldGlvbiBldmVudFxuICAgKi9cbiAgYXN5bmMgbG9nSm9iQ29tcGxldGVkKGpvYklkOiBzdHJpbmcsIGpvYk5hbWU6IHN0cmluZywgc3RhdHM6IHsgXG4gICAgdG90YWxfdXJsczogbnVtYmVyOyBcbiAgICBzdWNjZXNzZnVsX3VybHM6IG51bWJlcjsgXG4gICAgZmFpbGVkX3VybHM6IG51bWJlcjtcbiAgICBwcm9jZXNzaW5nX3RpbWVfbXM/OiBudW1iZXI7XG4gIH0pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLmxvZ0pvYkV2ZW50KHtcbiAgICAgIGpvYl9pZDogam9iSWQsXG4gICAgICBsZXZlbDogJ0lORk8nLFxuICAgICAgbWVzc2FnZTogYEpvYiBjb21wbGV0ZWQ6ICR7am9iTmFtZX1gLFxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgam9iX25hbWU6IGpvYk5hbWUsXG4gICAgICAgIGV2ZW50X3R5cGU6ICdqb2JfY29tcGxldGVkJyxcbiAgICAgICAgY29tcGxldGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIC4uLnN0YXRzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTG9nIGpvYiBmYWlsdXJlIGV2ZW50XG4gICAqL1xuICBhc3luYyBsb2dKb2JGYWlsZWQoam9iSWQ6IHN0cmluZywgam9iTmFtZTogc3RyaW5nLCBlcnJvck1lc3NhZ2U6IHN0cmluZywgbWV0YWRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5sb2dKb2JFdmVudCh7XG4gICAgICBqb2JfaWQ6IGpvYklkLFxuICAgICAgbGV2ZWw6ICdFUlJPUicsXG4gICAgICBtZXNzYWdlOiBgSm9iIGZhaWxlZDogJHtqb2JOYW1lfSAtICR7ZXJyb3JNZXNzYWdlfWAsXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICBqb2JfbmFtZTogam9iTmFtZSxcbiAgICAgICAgZXZlbnRfdHlwZTogJ2pvYl9mYWlsZWQnLFxuICAgICAgICBlcnJvcl9tZXNzYWdlOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgIGZhaWxlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAuLi5tZXRhZGF0YVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZyBVUkwgcHJvY2Vzc2luZyBldmVudFxuICAgKi9cbiAgYXN5bmMgbG9nVXJsUHJvY2Vzc2VkKGpvYklkOiBzdHJpbmcsIHVybDogc3RyaW5nLCBzdWNjZXNzOiBib29sZWFuLCBlcnJvck1lc3NhZ2U/OiBzdHJpbmcsIHJlc3BvbnNlVGltZT86IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMubG9nSm9iRXZlbnQoe1xuICAgICAgam9iX2lkOiBqb2JJZCxcbiAgICAgIGxldmVsOiBzdWNjZXNzID8gJ0lORk8nIDogJ0VSUk9SJyxcbiAgICAgIG1lc3NhZ2U6IHN1Y2Nlc3MgPyBgU3VjY2Vzc2Z1bGx5IGluZGV4ZWQgVVJMOiAke3VybH1gIDogYEZhaWxlZCB0byBpbmRleCBVUkw6ICR7dXJsfWAsXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICBldmVudF90eXBlOiAndXJsX3Byb2Nlc3NlZCcsXG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICBzdWNjZXNzOiBzdWNjZXNzLFxuICAgICAgICBlcnJvcl9tZXNzYWdlOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgIHJlc3BvbnNlX3RpbWVfbXM6IHJlc3BvbnNlVGltZSxcbiAgICAgICAgcHJvY2Vzc2VkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2cgcXVvdGEgdXNhZ2UgZXZlbnRcbiAgICovXG4gIGFzeW5jIGxvZ1F1b3RhVXNhZ2Uoam9iSWQ6IHN0cmluZywgc2VydmljZUFjY291bnRJZDogc3RyaW5nLCByZW1haW5pbmdRdW90YTogbnVtYmVyLCBhcGlSZXNwb25zZT86IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMubG9nSm9iRXZlbnQoe1xuICAgICAgam9iX2lkOiBqb2JJZCxcbiAgICAgIGxldmVsOiAnREVCVUcnLFxuICAgICAgbWVzc2FnZTogYFF1b3RhIHVzYWdlIHVwZGF0ZWQgLSAke3JlbWFpbmluZ1F1b3RhfSByZXF1ZXN0cyByZW1haW5pbmdgLFxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgZXZlbnRfdHlwZTogJ3F1b3RhX3VzYWdlJyxcbiAgICAgICAgc2VydmljZV9hY2NvdW50X2lkOiBzZXJ2aWNlQWNjb3VudElkLFxuICAgICAgICByZW1haW5pbmdfcXVvdGE6IHJlbWFpbmluZ1F1b3RhLFxuICAgICAgICBhcGlfcmVzcG9uc2U6IGFwaVJlc3BvbnNlLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZyBzZXJ2aWNlIGFjY291bnQgdXNhZ2VcbiAgICovXG4gIGFzeW5jIGxvZ1NlcnZpY2VBY2NvdW50VXNhZ2Uoam9iSWQ6IHN0cmluZywgc2VydmljZUFjY291bnRFbWFpbDogc3RyaW5nLCBhY3Rpb246IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMubG9nSm9iRXZlbnQoe1xuICAgICAgam9iX2lkOiBqb2JJZCxcbiAgICAgIGxldmVsOiAnREVCVUcnLFxuICAgICAgbWVzc2FnZTogYFNlcnZpY2UgYWNjb3VudCAke2FjdGlvbn06ICR7c2VydmljZUFjY291bnRFbWFpbH1gLFxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgZXZlbnRfdHlwZTogJ3NlcnZpY2VfYWNjb3VudF91c2FnZScsXG4gICAgICAgIHNlcnZpY2VfYWNjb3VudF9lbWFpbDogc2VydmljZUFjY291bnRFbWFpbCxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTG9nIHByb2dyZXNzIHVwZGF0ZVxuICAgKi9cbiAgYXN5bmMgbG9nUHJvZ3Jlc3NVcGRhdGUoam9iSWQ6IHN0cmluZywgcHJvZ3Jlc3M6IG51bWJlciwgcHJvY2Vzc2VkVXJsczogbnVtYmVyLCB0b3RhbFVybHM6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMubG9nSm9iRXZlbnQoe1xuICAgICAgam9iX2lkOiBqb2JJZCxcbiAgICAgIGxldmVsOiAnSU5GTycsXG4gICAgICBtZXNzYWdlOiBgUHJvZ3Jlc3MgdXBkYXRlOiAke3Byb2Nlc3NlZFVybHN9LyR7dG90YWxVcmxzfSBVUkxzIHByb2Nlc3NlZCAoJHtwcm9ncmVzcy50b0ZpeGVkKDEpfSUpYCxcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIGV2ZW50X3R5cGU6ICdwcm9ncmVzc191cGRhdGUnLFxuICAgICAgICBwcm9ncmVzc19wZXJjZW50YWdlOiBwcm9ncmVzcyxcbiAgICAgICAgcHJvY2Vzc2VkX3VybHM6IHByb2Nlc3NlZFVybHMsXG4gICAgICAgIHRvdGFsX3VybHM6IHRvdGFsVXJscyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2cgR29vZ2xlIEFQSSBpbnRlcmFjdGlvblxuICAgKi9cbiAgYXN5bmMgbG9nR29vZ2xlQXBpQ2FsbChqb2JJZDogc3RyaW5nLCB1cmw6IHN0cmluZywgc3RhdHVzQ29kZTogbnVtYmVyLCByZXNwb25zZURhdGE/OiBhbnksIGVycm9yTWVzc2FnZT86IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMubG9nSm9iRXZlbnQoe1xuICAgICAgam9iX2lkOiBqb2JJZCxcbiAgICAgIGxldmVsOiBzdGF0dXNDb2RlID49IDQwMCA/ICdFUlJPUicgOiAnREVCVUcnLFxuICAgICAgbWVzc2FnZTogYEdvb2dsZSBBUEkgY2FsbCBmb3IgJHt1cmx9OiAke3N0YXR1c0NvZGV9YCxcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIGV2ZW50X3R5cGU6ICdnb29nbGVfYXBpX2NhbGwnLFxuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgc3RhdHVzX2NvZGU6IHN0YXR1c0NvZGUsXG4gICAgICAgIHJlc3BvbnNlX2RhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgZXJyb3JfbWVzc2FnZTogZXJyb3JNZXNzYWdlLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZyB3YXJuaW5nIGV2ZW50c1xuICAgKi9cbiAgYXN5bmMgbG9nV2FybmluZyhqb2JJZDogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcsIG1ldGFkYXRhPzogUmVjb3JkPHN0cmluZywgYW55Pik6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMubG9nSm9iRXZlbnQoe1xuICAgICAgam9iX2lkOiBqb2JJZCxcbiAgICAgIGxldmVsOiAnV0FSTicsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgZXZlbnRfdHlwZTogJ3dhcm5pbmcnLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgLi4ubWV0YWRhdGFcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufSJdLCJuYW1lcyI6WyJzdXBhYmFzZUFkbWluIiwiSm9iTG9nZ2luZ1NlcnZpY2UiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwibG9nSm9iRXZlbnQiLCJlbnRyeSIsImVycm9yIiwiZnJvbSIsImluc2VydCIsImpvYl9pZCIsImxldmVsIiwidG9Mb3dlckNhc2UiLCJtZXNzYWdlIiwibWV0YWRhdGEiLCJjcmVhdGVkX2F0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiY29uc29sZSIsImxvZ0pvYlN0YXJ0ZWQiLCJqb2JJZCIsImpvYk5hbWUiLCJ0b3RhbFVybHMiLCJqb2JfbmFtZSIsImV2ZW50X3R5cGUiLCJzdGFydGVkX2F0IiwidG90YWxfdXJscyIsImxvZ0pvYkNvbXBsZXRlZCIsInN0YXRzIiwiY29tcGxldGVkX2F0IiwibG9nSm9iRmFpbGVkIiwiZXJyb3JNZXNzYWdlIiwiZXJyb3JfbWVzc2FnZSIsImZhaWxlZF9hdCIsImxvZ1VybFByb2Nlc3NlZCIsInVybCIsInN1Y2Nlc3MiLCJyZXNwb25zZVRpbWUiLCJyZXNwb25zZV90aW1lX21zIiwicHJvY2Vzc2VkX2F0IiwibG9nUXVvdGFVc2FnZSIsInNlcnZpY2VBY2NvdW50SWQiLCJyZW1haW5pbmdRdW90YSIsImFwaVJlc3BvbnNlIiwic2VydmljZV9hY2NvdW50X2lkIiwicmVtYWluaW5nX3F1b3RhIiwiYXBpX3Jlc3BvbnNlIiwidGltZXN0YW1wIiwibG9nU2VydmljZUFjY291bnRVc2FnZSIsInNlcnZpY2VBY2NvdW50RW1haWwiLCJhY3Rpb24iLCJzZXJ2aWNlX2FjY291bnRfZW1haWwiLCJsb2dQcm9ncmVzc1VwZGF0ZSIsInByb2dyZXNzIiwicHJvY2Vzc2VkVXJscyIsInRvRml4ZWQiLCJwcm9ncmVzc19wZXJjZW50YWdlIiwicHJvY2Vzc2VkX3VybHMiLCJsb2dHb29nbGVBcGlDYWxsIiwic3RhdHVzQ29kZSIsInJlc3BvbnNlRGF0YSIsInN0YXR1c19jb2RlIiwicmVzcG9uc2VfZGF0YSIsImxvZ1dhcm5pbmciXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/job-logging-service.ts\n");

/***/ }),

/***/ "(rsc)/./lib/job-monitor.ts":
/*!****************************!*\
  !*** ./lib/job-monitor.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JobMonitor: () => (/* binding */ JobMonitor),\n/* harmony export */   jobMonitor: () => (/* binding */ jobMonitor)\n/* harmony export */ });\n/* harmony import */ var node_cron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node-cron */ \"node-cron\");\n/* harmony import */ var node_cron__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_cron__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./supabase */ \"(rsc)/./lib/supabase.ts\");\n/* harmony import */ var _google_indexing_processor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./google-indexing-processor */ \"(rsc)/./lib/google-indexing-processor.ts\");\n\n\n\n/**\n * Job Monitor Service\n * \n * This service runs as a background worker that:\n * 1. Monitors for pending jobs every minute\n * 2. Automatically triggers processing for pending jobs\n * 3. Handles scheduled jobs based on their next_run_at time\n * 4. Ensures only one instance processes jobs to prevent conflicts\n */ class JobMonitor {\n    constructor(){\n        this.isRunning = false;\n        this.cronJob = null;\n        this.processor = _google_indexing_processor__WEBPACK_IMPORTED_MODULE_2__.GoogleIndexingProcessor.getInstance();\n    }\n    static getInstance() {\n        if (!JobMonitor.instance) {\n            JobMonitor.instance = new JobMonitor();\n        }\n        return JobMonitor.instance;\n    }\n    /**\n   * Start the job monitor\n   * Runs every minute to check for pending jobs\n   */ start() {\n        if (this.isRunning) {\n            console.log('Job monitor is already running');\n            return;\n        }\n        console.log('Starting job monitor...');\n        this.isRunning = true;\n        // Run every minute to check for pending jobs\n        this.cronJob = node_cron__WEBPACK_IMPORTED_MODULE_0__.schedule('* * * * *', async ()=>{\n            await this.checkAndProcessJobs();\n        }, {\n            timezone: 'UTC'\n        });\n        console.log('Job monitor started - checking for jobs every minute');\n    }\n    /**\n   * Stop the job monitor\n   */ stop() {\n        if (!this.isRunning) {\n            console.log('Job monitor is not running');\n            return;\n        }\n        console.log('Stopping job monitor...');\n        this.isRunning = false;\n        if (this.cronJob) {\n            this.cronJob.destroy();\n            this.cronJob = null;\n        }\n        console.log('Job monitor stopped');\n    }\n    /**\n   * Check for pending jobs and process them\n   */ async checkAndProcessJobs() {\n        try {\n            // Find pending jobs that are ready to run\n            const { data: pendingJobs, error } = await _supabase__WEBPACK_IMPORTED_MODULE_1__.supabaseAdmin.from('indb_indexing_jobs').select('id, name, user_id, next_run_at, schedule_type').eq('status', 'pending').is('locked_at', null).or('next_run_at.is.null,next_run_at.lte.' + new Date().toISOString()).limit(5); // Process max 5 jobs per minute to prevent overload\n            if (error) {\n                console.error('Error fetching pending jobs:', error);\n                return;\n            }\n            if (!pendingJobs || pendingJobs.length === 0) {\n                // No pending jobs found - this is normal\n                return;\n            }\n            console.log(`Found ${pendingJobs.length} pending jobs to process`);\n            // Process each job\n            for (const job of pendingJobs){\n                try {\n                    console.log(`Processing job ${job.id} (${job.name})`);\n                    const result = await this.processor.processIndexingJob(job.id);\n                    if (result.success) {\n                        console.log(`✅ Job ${job.id} completed successfully`);\n                        // Update next run time for recurring jobs\n                        if (job.schedule_type && job.schedule_type !== 'one-time') {\n                            await this.scheduleNextRun(job.id, job.schedule_type);\n                        }\n                    } else {\n                        console.log(`❌ Job ${job.id} failed: ${result.error}`);\n                    }\n                } catch (error) {\n                    console.error(`Error processing job ${job.id}:`, error);\n                }\n            }\n        } catch (error) {\n            console.error('Error in job monitor:', error);\n        }\n    }\n    /**\n   * Schedule the next run for recurring jobs\n   */ async scheduleNextRun(jobId, scheduleType) {\n        try {\n            const now = new Date();\n            let nextRun;\n            switch(scheduleType){\n                case 'hourly':\n                    nextRun = new Date(now.getTime() + 60 * 60 * 1000); // +1 hour\n                    break;\n                case 'daily':\n                    nextRun = new Date(now.getTime() + 24 * 60 * 60 * 1000); // +1 day\n                    break;\n                case 'weekly':\n                    nextRun = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000); // +1 week\n                    break;\n                case 'monthly':\n                    nextRun = new Date(now);\n                    nextRun.setMonth(nextRun.getMonth() + 1); // +1 month\n                    break;\n                default:\n                    return; // one-time jobs don't get rescheduled\n            }\n            await _supabase__WEBPACK_IMPORTED_MODULE_1__.supabaseAdmin.from('indb_indexing_jobs').update({\n                status: 'pending',\n                next_run_at: nextRun.toISOString(),\n                updated_at: new Date().toISOString()\n            }).eq('id', jobId);\n            console.log(`📅 Job ${jobId} scheduled for next run at ${nextRun.toISOString()}`);\n        } catch (error) {\n            console.error(`Error scheduling next run for job ${jobId}:`, error);\n        }\n    }\n    /**\n   * Get monitor status\n   */ getStatus() {\n        return {\n            isRunning: this.isRunning,\n            nextCheck: this.cronJob ? 'Every minute' : undefined\n        };\n    }\n    /**\n   * Manually trigger job processing (for testing)\n   */ async triggerNow() {\n        console.log('Manually triggering job processing...');\n        await this.checkAndProcessJobs();\n    }\n}\n// Export singleton instance\nconst jobMonitor = JobMonitor.getInstance();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUFBRTBCLE1BQU0sMkJBQTJCLEVBQUVHLFFBQVFkLFdBQVcsSUFBSTtRQUNsRixFQUFFLE9BQU9QLE9BQU87WUFDZFQsUUFBUVMsS0FBSyxDQUFDLENBQUMsa0NBQWtDLEVBQUVrQixNQUFNLENBQUMsQ0FBQyxFQUFFbEI7UUFDL0Q7SUFDRjtJQUVBOztHQUVDLEdBQ0Q2QixZQUF3RDtRQUN0RCxPQUFPO1lBQ0w1QyxXQUFXLElBQUksQ0FBQ0EsU0FBUztZQUN6QjZDLFdBQVcsSUFBSSxDQUFDNUMsT0FBTyxHQUFHLGlCQUFpQjZDO1FBQzdDO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELE1BQU1DLGFBQTRCO1FBQ2hDekMsUUFBUUMsR0FBRyxDQUFDO1FBQ1osTUFBTSxJQUFJLENBQUNFLG1CQUFtQjtJQUNoQztBQUNGO0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU11QyxhQUFhakQsV0FBV0ksV0FBVyxHQUFHIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL2xpYi9qb2ItbW9uaXRvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjcm9uIGZyb20gJ25vZGUtY3Jvbic7XG5pbXBvcnQgeyBzdXBhYmFzZUFkbWluIH0gZnJvbSAnLi9zdXBhYmFzZSc7XG5pbXBvcnQgeyBHb29nbGVJbmRleGluZ1Byb2Nlc3NvciB9IGZyb20gJy4vZ29vZ2xlLWluZGV4aW5nLXByb2Nlc3Nvcic7XG5cbi8qKlxuICogSm9iIE1vbml0b3IgU2VydmljZVxuICogXG4gKiBUaGlzIHNlcnZpY2UgcnVucyBhcyBhIGJhY2tncm91bmQgd29ya2VyIHRoYXQ6XG4gKiAxLiBNb25pdG9ycyBmb3IgcGVuZGluZyBqb2JzIGV2ZXJ5IG1pbnV0ZVxuICogMi4gQXV0b21hdGljYWxseSB0cmlnZ2VycyBwcm9jZXNzaW5nIGZvciBwZW5kaW5nIGpvYnNcbiAqIDMuIEhhbmRsZXMgc2NoZWR1bGVkIGpvYnMgYmFzZWQgb24gdGhlaXIgbmV4dF9ydW5fYXQgdGltZVxuICogNC4gRW5zdXJlcyBvbmx5IG9uZSBpbnN0YW5jZSBwcm9jZXNzZXMgam9icyB0byBwcmV2ZW50IGNvbmZsaWN0c1xuICovXG5leHBvcnQgY2xhc3MgSm9iTW9uaXRvciB7XG4gIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBKb2JNb25pdG9yO1xuICBwcml2YXRlIGlzUnVubmluZyA9IGZhbHNlO1xuICBwcml2YXRlIHByb2Nlc3NvcjogR29vZ2xlSW5kZXhpbmdQcm9jZXNzb3I7XG4gIHByaXZhdGUgY3JvbkpvYjogY3Jvbi5TY2hlZHVsZWRUYXNrIHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5wcm9jZXNzb3IgPSBHb29nbGVJbmRleGluZ1Byb2Nlc3Nvci5nZXRJbnN0YW5jZSgpO1xuICB9XG5cbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IEpvYk1vbml0b3Ige1xuICAgIGlmICghSm9iTW9uaXRvci5pbnN0YW5jZSkge1xuICAgICAgSm9iTW9uaXRvci5pbnN0YW5jZSA9IG5ldyBKb2JNb25pdG9yKCk7XG4gICAgfVxuICAgIHJldHVybiBKb2JNb25pdG9yLmluc3RhbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHRoZSBqb2IgbW9uaXRvclxuICAgKiBSdW5zIGV2ZXJ5IG1pbnV0ZSB0byBjaGVjayBmb3IgcGVuZGluZyBqb2JzXG4gICAqL1xuICBzdGFydCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdKb2IgbW9uaXRvciBpcyBhbHJlYWR5IHJ1bm5pbmcnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgam9iIG1vbml0b3IuLi4nKTtcbiAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG5cbiAgICAvLyBSdW4gZXZlcnkgbWludXRlIHRvIGNoZWNrIGZvciBwZW5kaW5nIGpvYnNcbiAgICB0aGlzLmNyb25Kb2IgPSBjcm9uLnNjaGVkdWxlKCcqICogKiAqIConLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLmNoZWNrQW5kUHJvY2Vzc0pvYnMoKTtcbiAgICB9LCB7XG4gICAgICB0aW1lem9uZTogJ1VUQydcbiAgICB9KTtcblxuICAgIGNvbnNvbGUubG9nKCdKb2IgbW9uaXRvciBzdGFydGVkIC0gY2hlY2tpbmcgZm9yIGpvYnMgZXZlcnkgbWludXRlJyk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCB0aGUgam9iIG1vbml0b3JcbiAgICovXG4gIHN0b3AoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzUnVubmluZykge1xuICAgICAgY29uc29sZS5sb2coJ0pvYiBtb25pdG9yIGlzIG5vdCBydW5uaW5nJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1N0b3BwaW5nIGpvYiBtb25pdG9yLi4uJyk7XG4gICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLmNyb25Kb2IpIHtcbiAgICAgIHRoaXMuY3JvbkpvYi5kZXN0cm95KCk7XG4gICAgICB0aGlzLmNyb25Kb2IgPSBudWxsO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdKb2IgbW9uaXRvciBzdG9wcGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgZm9yIHBlbmRpbmcgam9icyBhbmQgcHJvY2VzcyB0aGVtXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGNoZWNrQW5kUHJvY2Vzc0pvYnMoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpbmQgcGVuZGluZyBqb2JzIHRoYXQgYXJlIHJlYWR5IHRvIHJ1blxuICAgICAgY29uc3QgeyBkYXRhOiBwZW5kaW5nSm9icywgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlQWRtaW5cbiAgICAgICAgLmZyb20oJ2luZGJfaW5kZXhpbmdfam9icycpXG4gICAgICAgIC5zZWxlY3QoJ2lkLCBuYW1lLCB1c2VyX2lkLCBuZXh0X3J1bl9hdCwgc2NoZWR1bGVfdHlwZScpXG4gICAgICAgIC5lcSgnc3RhdHVzJywgJ3BlbmRpbmcnKVxuICAgICAgICAuaXMoJ2xvY2tlZF9hdCcsIG51bGwpXG4gICAgICAgIC5vcignbmV4dF9ydW5fYXQuaXMubnVsbCxuZXh0X3J1bl9hdC5sdGUuJyArIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSlcbiAgICAgICAgLmxpbWl0KDUpOyAvLyBQcm9jZXNzIG1heCA1IGpvYnMgcGVyIG1pbnV0ZSB0byBwcmV2ZW50IG92ZXJsb2FkXG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwZW5kaW5nIGpvYnM6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghcGVuZGluZ0pvYnMgfHwgcGVuZGluZ0pvYnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIE5vIHBlbmRpbmcgam9icyBmb3VuZCAtIHRoaXMgaXMgbm9ybWFsXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7cGVuZGluZ0pvYnMubGVuZ3RofSBwZW5kaW5nIGpvYnMgdG8gcHJvY2Vzc2ApO1xuXG4gICAgICAvLyBQcm9jZXNzIGVhY2ggam9iXG4gICAgICBmb3IgKGNvbnN0IGpvYiBvZiBwZW5kaW5nSm9icykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBQcm9jZXNzaW5nIGpvYiAke2pvYi5pZH0gKCR7am9iLm5hbWV9KWApO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJvY2Vzc29yLnByb2Nlc3NJbmRleGluZ0pvYihqb2IuaWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBKb2IgJHtqb2IuaWR9IGNvbXBsZXRlZCBzdWNjZXNzZnVsbHlgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVXBkYXRlIG5leHQgcnVuIHRpbWUgZm9yIHJlY3VycmluZyBqb2JzXG4gICAgICAgICAgICBpZiAoam9iLnNjaGVkdWxlX3R5cGUgJiYgam9iLnNjaGVkdWxlX3R5cGUgIT09ICdvbmUtdGltZScpIHtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zY2hlZHVsZU5leHRSdW4oam9iLmlkLCBqb2Iuc2NoZWR1bGVfdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinYwgSm9iICR7am9iLmlkfSBmYWlsZWQ6ICR7cmVzdWx0LmVycm9yfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwcm9jZXNzaW5nIGpvYiAke2pvYi5pZH06YCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGpvYiBtb25pdG9yOicsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2NoZWR1bGUgdGhlIG5leHQgcnVuIGZvciByZWN1cnJpbmcgam9ic1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBzY2hlZHVsZU5leHRSdW4oam9iSWQ6IHN0cmluZywgc2NoZWR1bGVUeXBlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgIGxldCBuZXh0UnVuOiBEYXRlO1xuXG4gICAgICBzd2l0Y2ggKHNjaGVkdWxlVHlwZSkge1xuICAgICAgICBjYXNlICdob3VybHknOlxuICAgICAgICAgIG5leHRSdW4gPSBuZXcgRGF0ZShub3cuZ2V0VGltZSgpICsgNjAgKiA2MCAqIDEwMDApOyAvLyArMSBob3VyXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RhaWx5JzpcbiAgICAgICAgICBuZXh0UnVuID0gbmV3IERhdGUobm93LmdldFRpbWUoKSArIDI0ICogNjAgKiA2MCAqIDEwMDApOyAvLyArMSBkYXlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnd2Vla2x5JzpcbiAgICAgICAgICBuZXh0UnVuID0gbmV3IERhdGUobm93LmdldFRpbWUoKSArIDcgKiAyNCAqIDYwICogNjAgKiAxMDAwKTsgLy8gKzEgd2Vla1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtb250aGx5JzpcbiAgICAgICAgICBuZXh0UnVuID0gbmV3IERhdGUobm93KTtcbiAgICAgICAgICBuZXh0UnVuLnNldE1vbnRoKG5leHRSdW4uZ2V0TW9udGgoKSArIDEpOyAvLyArMSBtb250aFxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybjsgLy8gb25lLXRpbWUgam9icyBkb24ndCBnZXQgcmVzY2hlZHVsZWRcbiAgICAgIH1cblxuICAgICAgYXdhaXQgc3VwYWJhc2VBZG1pblxuICAgICAgICAuZnJvbSgnaW5kYl9pbmRleGluZ19qb2JzJylcbiAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgc3RhdHVzOiAncGVuZGluZycsXG4gICAgICAgICAgbmV4dF9ydW5fYXQ6IG5leHRSdW4udG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfSlcbiAgICAgICAgLmVxKCdpZCcsIGpvYklkKTtcblxuICAgICAgY29uc29sZS5sb2coYPCfk4UgSm9iICR7am9iSWR9IHNjaGVkdWxlZCBmb3IgbmV4dCBydW4gYXQgJHtuZXh0UnVuLnRvSVNPU3RyaW5nKCl9YCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHNjaGVkdWxpbmcgbmV4dCBydW4gZm9yIGpvYiAke2pvYklkfTpgLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBtb25pdG9yIHN0YXR1c1xuICAgKi9cbiAgZ2V0U3RhdHVzKCk6IHsgaXNSdW5uaW5nOiBib29sZWFuOyBuZXh0Q2hlY2s/OiBzdHJpbmcgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzUnVubmluZzogdGhpcy5pc1J1bm5pbmcsXG4gICAgICBuZXh0Q2hlY2s6IHRoaXMuY3JvbkpvYiA/ICdFdmVyeSBtaW51dGUnIDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYW51YWxseSB0cmlnZ2VyIGpvYiBwcm9jZXNzaW5nIChmb3IgdGVzdGluZylcbiAgICovXG4gIGFzeW5jIHRyaWdnZXJOb3coKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc29sZS5sb2coJ01hbnVhbGx5IHRyaWdnZXJpbmcgam9iIHByb2Nlc3NpbmcuLi4nKTtcbiAgICBhd2FpdCB0aGlzLmNoZWNrQW5kUHJvY2Vzc0pvYnMoKTtcbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3Qgam9iTW9uaXRvciA9IEpvYk1vbml0b3IuZ2V0SW5zdGFuY2UoKTsiXSwibmFtZXMiOlsiY3JvbiIsInN1cGFiYXNlQWRtaW4iLCJHb29nbGVJbmRleGluZ1Byb2Nlc3NvciIsIkpvYk1vbml0b3IiLCJpc1J1bm5pbmciLCJjcm9uSm9iIiwicHJvY2Vzc29yIiwiZ2V0SW5zdGFuY2UiLCJpbnN0YW5jZSIsInN0YXJ0IiwiY29uc29sZSIsImxvZyIsInNjaGVkdWxlIiwiY2hlY2tBbmRQcm9jZXNzSm9icyIsInRpbWV6b25lIiwic3RvcCIsImRlc3Ryb3kiLCJkYXRhIiwicGVuZGluZ0pvYnMiLCJlcnJvciIsImZyb20iLCJzZWxlY3QiLCJlcSIsImlzIiwib3IiLCJEYXRlIiwidG9JU09TdHJpbmciLCJsaW1pdCIsImxlbmd0aCIsImpvYiIsImlkIiwibmFtZSIsInJlc3VsdCIsInByb2Nlc3NJbmRleGluZ0pvYiIsInN1Y2Nlc3MiLCJzY2hlZHVsZV90eXBlIiwic2NoZWR1bGVOZXh0UnVuIiwiam9iSWQiLCJzY2hlZHVsZVR5cGUiLCJub3ciLCJuZXh0UnVuIiwiZ2V0VGltZSIsInNldE1vbnRoIiwiZ2V0TW9udGgiLCJ1cGRhdGUiLCJzdGF0dXMiLCJuZXh0X3J1bl9hdCIsInVwZGF0ZWRfYXQiLCJnZXRTdGF0dXMiLCJuZXh0Q2hlY2siLCJ1bmRlZmluZWQiLCJ0cmlnZ2VyTm93Iiwiam9iTW9uaXRvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/job-monitor.ts\n");

/***/ }),

/***/ "(rsc)/./lib/supabase.ts":
/*!*************************!*\
  !*** ./lib/supabase.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   supabase: () => (/* binding */ supabase),\n/* harmony export */   supabaseAdmin: () => (/* binding */ supabaseAdmin)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n\nconst supabaseUrl = \"https://base.indexnow.studio\";\nconst supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYW5vbiIsImlzcyI6InN1cGFiYXNlIiwiaWF0IjoxNzUzMDMwODAwLCJleHAiOjE5MTA3OTcyMDB9.druA2hNMG5tlToENwA6diLetpMm9GdJgaSRwi75iTW0\";\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n    auth: {\n        autoRefreshToken: true,\n        persistSession: true,\n        detectSessionInUrl: true\n    }\n});\n// Server-side client with service role key (for admin operations)\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\nconst supabaseAdmin = supabaseServiceKey ? (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseServiceKey, {\n    auth: {\n        autoRefreshToken: false,\n        persistSession: false\n    }\n}) : (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey) // Fallback to anon key\n;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (supabase);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvc3VwYWJhc2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFvRDtBQUVwRCxNQUFNQyxjQUFjQyw4QkFBb0M7QUFDeEQsTUFBTUcsa0JBQWtCSCwyS0FBeUM7QUFFMUQsTUFBTUssV0FBV1AsbUVBQVlBLENBQUNDLGFBQWFJLGlCQUFpQjtJQUNqRUcsTUFBTTtRQUNKQyxrQkFBa0I7UUFDbEJDLGdCQUFnQjtRQUNoQkMsb0JBQW9CO0lBQ3RCO0FBQ0YsR0FBRTtBQUVGLGtFQUFrRTtBQUNsRSxNQUFNQyxxQkFBcUJWLFFBQVFDLEdBQUcsQ0FBQ1UseUJBQXlCO0FBQ3pELE1BQU1DLGdCQUFnQkYscUJBQ3pCWixtRUFBWUEsQ0FBQ0MsYUFBYVcsb0JBQW9CO0lBQzVDSixNQUFNO1FBQ0pDLGtCQUFrQjtRQUNsQkMsZ0JBQWdCO0lBQ2xCO0FBQ0YsS0FDQVYsbUVBQVlBLENBQUNDLGFBQWFJLGlCQUFpQix1QkFBdUI7Q0FBeEI7QUFFOUMsaUVBQWVFLFFBQVFBLEVBQUEiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2UvbGliL3N1cGFiYXNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcydcblxuY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwhXG5jb25zdCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSFcblxuZXhwb3J0IGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXksIHtcbiAgYXV0aDoge1xuICAgIGF1dG9SZWZyZXNoVG9rZW46IHRydWUsXG4gICAgcGVyc2lzdFNlc3Npb246IHRydWUsXG4gICAgZGV0ZWN0U2Vzc2lvbkluVXJsOiB0cnVlXG4gIH1cbn0pXG5cbi8vIFNlcnZlci1zaWRlIGNsaWVudCB3aXRoIHNlcnZpY2Ugcm9sZSBrZXkgKGZvciBhZG1pbiBvcGVyYXRpb25zKVxuY29uc3Qgc3VwYWJhc2VTZXJ2aWNlS2V5ID0gcHJvY2Vzcy5lbnYuU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWVxuZXhwb3J0IGNvbnN0IHN1cGFiYXNlQWRtaW4gPSBzdXBhYmFzZVNlcnZpY2VLZXlcbiAgPyBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlU2VydmljZUtleSwge1xuICAgICAgYXV0aDoge1xuICAgICAgICBhdXRvUmVmcmVzaFRva2VuOiBmYWxzZSxcbiAgICAgICAgcGVyc2lzdFNlc3Npb246IGZhbHNlXG4gICAgICB9XG4gICAgfSlcbiAgOiBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSkgLy8gRmFsbGJhY2sgdG8gYW5vbiBrZXlcblxuZXhwb3J0IGRlZmF1bHQgc3VwYWJhc2UiXSwibmFtZXMiOlsiY3JlYXRlQ2xpZW50Iiwic3VwYWJhc2VVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwic3VwYWJhc2VBbm9uS2V5IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJzdXBhYmFzZSIsImF1dGgiLCJhdXRvUmVmcmVzaFRva2VuIiwicGVyc2lzdFNlc3Npb24iLCJkZXRlY3RTZXNzaW9uSW5VcmwiLCJzdXBhYmFzZVNlcnZpY2VLZXkiLCJTVVBBQkFTRV9TRVJWSUNFX1JPTEVfS0VZIiwic3VwYWJhc2VBZG1pbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/supabase.ts\n");

/***/ }),

/***/ "(rsc)/./lib/websocket-service.ts":
/*!**********************************!*\
  !*** ./lib/websocket-service.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebSocketService: () => (/* binding */ WebSocketService)\n/* harmony export */ });\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ws */ \"(rsc)/./node_modules/ws/wrapper.mjs\");\n\nclass WebSocketService {\n    static getInstance() {\n        if (!WebSocketService.instance) {\n            WebSocketService.instance = new WebSocketService();\n        }\n        return WebSocketService.instance;\n    }\n    initialize(server) {\n        this.wss = new ws__WEBPACK_IMPORTED_MODULE_0__.WebSocketServer({\n            server,\n            path: '/ws',\n            verifyClient: (info)=>{\n                // Basic verification - you might want to add JWT verification here\n                return true;\n            }\n        });\n        this.wss.on('connection', (ws, request)=>{\n            const url = new URL(request.url, 'http://localhost');\n            const userId = url.searchParams.get('userId');\n            const jobId = url.searchParams.get('jobId');\n            if (!userId) {\n                ws.close(1008, 'Missing userId');\n                return;\n            }\n            const clientId = this.generateClientId();\n            const client = {\n                ws,\n                userId,\n                jobId: jobId || undefined\n            };\n            this.clients.set(clientId, client);\n            console.log(`WebSocket client connected: ${clientId} (user: ${userId}, job: ${jobId})`);\n            // Send initial connection confirmation\n            this.sendToClient(clientId, {\n                type: 'connection',\n                message: 'Connected to IndexNow Pro WebSocket'\n            });\n            ws.on('message', (data)=>{\n                try {\n                    const message = JSON.parse(data.toString());\n                    this.handleClientMessage(clientId, message);\n                } catch (error) {\n                    console.error('Error parsing WebSocket message:', error);\n                }\n            });\n            ws.on('close', ()=>{\n                console.log(`WebSocket client disconnected: ${clientId}`);\n                this.clients.delete(clientId);\n            });\n            ws.on('error', (error)=>{\n                console.error('WebSocket error:', error);\n                this.clients.delete(clientId);\n            });\n        });\n        console.log('WebSocket server initialized on path /ws');\n    }\n    generateClientId() {\n        return `client-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    }\n    handleClientMessage(clientId, message) {\n        const client = this.clients.get(clientId);\n        if (!client) return;\n        switch(message.type){\n            case 'subscribe_job':\n                client.jobId = message.jobId;\n                this.sendToClient(clientId, {\n                    type: 'subscribed',\n                    jobId: message.jobId\n                });\n                break;\n            case 'unsubscribe_job':\n                client.jobId = undefined;\n                this.sendToClient(clientId, {\n                    type: 'unsubscribed'\n                });\n                break;\n            case 'ping':\n                this.sendToClient(clientId, {\n                    type: 'pong'\n                });\n                break;\n        }\n    }\n    broadcastJobUpdate(userId, jobId, update) {\n        const message = {\n            type: 'job_update',\n            jobId,\n            ...update\n        };\n        // Send to all clients of this user who are subscribed to this job\n        this.clients.forEach((client, clientId)=>{\n            if (client.userId === userId && (client.jobId === jobId || !client.jobId) && client.ws.readyState === ws__WEBPACK_IMPORTED_MODULE_0__.WebSocket.OPEN) {\n                this.sendToClient(clientId, message);\n            }\n        });\n    }\n    broadcastToUser(userId, message) {\n        this.clients.forEach((client, clientId)=>{\n            if (client.userId === userId && client.ws.readyState === ws__WEBPACK_IMPORTED_MODULE_0__.WebSocket.OPEN) {\n                this.sendToClient(clientId, message);\n            }\n        });\n    }\n    sendToClient(clientId, message) {\n        const client = this.clients.get(clientId);\n        if (client && client.ws.readyState === ws__WEBPACK_IMPORTED_MODULE_0__.WebSocket.OPEN) {\n            try {\n                client.ws.send(JSON.stringify(message));\n            } catch (error) {\n                console.error('Error sending WebSocket message:', error);\n                this.clients.delete(clientId);\n            }\n        }\n    }\n    getConnectedClients() {\n        return this.clients.size;\n    }\n    getClientsByUser(userId) {\n        return Array.from(this.clients.values()).filter((client)=>client.userId === userId).length;\n    }\n    constructor(){\n        this.wss = null;\n        this.clients = new Map();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxJQUFJLENBQUNqQixLQUFLa0IsU0FBUyxDQUFDcEI7WUFDaEMsRUFBRSxPQUFPTSxPQUFPO2dCQUNkVixRQUFRVSxLQUFLLENBQUMsb0NBQW9DQTtnQkFDbEQsSUFBSSxDQUFDWixPQUFPLENBQUNhLE1BQU0sQ0FBQ2pCO1lBQ3RCO1FBQ0Y7SUFDRjtJQUVBK0Isc0JBQThCO1FBQzVCLE9BQU8sSUFBSSxDQUFDM0IsT0FBTyxDQUFDNEIsSUFBSTtJQUMxQjtJQUVBQyxpQkFBaUJ0QyxNQUFjLEVBQVU7UUFDdkMsT0FBT3VDLE1BQU1DLElBQUksQ0FBQyxJQUFJLENBQUMvQixPQUFPLENBQUNnQyxNQUFNLElBQ2xDQyxNQUFNLENBQUNuQyxDQUFBQSxTQUFVQSxPQUFPUCxNQUFNLEtBQUtBLFFBQVEyQyxNQUFNO0lBQ3REOzthQTdJUXBELE1BQThCO2FBQzlCa0IsVUFBVSxJQUFJbUM7O0FBNkl4QiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9saWIvd2Vic29ja2V0LXNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2VydmVyIH0gZnJvbSAnaHR0cCc7XG5pbXBvcnQgeyBXZWJTb2NrZXRTZXJ2ZXIsIFdlYlNvY2tldCB9IGZyb20gJ3dzJztcblxuaW50ZXJmYWNlIEpvYlVwZGF0ZSB7XG4gIGpvYklkOiBzdHJpbmc7XG4gIHN0YXR1czogJ3BlbmRpbmcnIHwgJ3J1bm5pbmcnIHwgJ2NvbXBsZXRlZCcgfCAnZmFpbGVkJyB8ICdwYXVzZWQnO1xuICBwcm9ncmVzczoge1xuICAgIHRvdGFsX3VybHM6IG51bWJlcjtcbiAgICBwcm9jZXNzZWRfdXJsczogbnVtYmVyO1xuICAgIHN1Y2Nlc3NmdWxfdXJsczogbnVtYmVyO1xuICAgIGZhaWxlZF91cmxzOiBudW1iZXI7XG4gICAgcHJvZ3Jlc3NfcGVyY2VudGFnZTogbnVtYmVyO1xuICB9O1xuICBjdXJyZW50X3VybD86IHN0cmluZztcbiAgZXJyb3JfbWVzc2FnZT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIENsaWVudENvbm5lY3Rpb24ge1xuICB3czogV2ViU29ja2V0O1xuICB1c2VySWQ6IHN0cmluZztcbiAgam9iSWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBXZWJTb2NrZXRTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFdlYlNvY2tldFNlcnZpY2U7XG4gIHByaXZhdGUgd3NzOiBXZWJTb2NrZXRTZXJ2ZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBjbGllbnRzID0gbmV3IE1hcDxzdHJpbmcsIENsaWVudENvbm5lY3Rpb24+KCk7XG5cbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IFdlYlNvY2tldFNlcnZpY2Uge1xuICAgIGlmICghV2ViU29ja2V0U2VydmljZS5pbnN0YW5jZSkge1xuICAgICAgV2ViU29ja2V0U2VydmljZS5pbnN0YW5jZSA9IG5ldyBXZWJTb2NrZXRTZXJ2aWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBXZWJTb2NrZXRTZXJ2aWNlLmluc3RhbmNlO1xuICB9XG5cbiAgaW5pdGlhbGl6ZShzZXJ2ZXI6IFNlcnZlcik6IHZvaWQge1xuICAgIHRoaXMud3NzID0gbmV3IFdlYlNvY2tldFNlcnZlcih7IFxuICAgICAgc2VydmVyLCBcbiAgICAgIHBhdGg6ICcvd3MnLFxuICAgICAgdmVyaWZ5Q2xpZW50OiAoaW5mbzogYW55KSA9PiB7XG4gICAgICAgIC8vIEJhc2ljIHZlcmlmaWNhdGlvbiAtIHlvdSBtaWdodCB3YW50IHRvIGFkZCBKV1QgdmVyaWZpY2F0aW9uIGhlcmVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLndzcy5vbignY29ubmVjdGlvbicsICh3czogV2ViU29ja2V0LCByZXF1ZXN0KSA9PiB7XG4gICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsISwgJ2h0dHA6Ly9sb2NhbGhvc3QnKTtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KCd1c2VySWQnKTtcbiAgICAgIGNvbnN0IGpvYklkID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoJ2pvYklkJyk7XG5cbiAgICAgIGlmICghdXNlcklkKSB7XG4gICAgICAgIHdzLmNsb3NlKDEwMDgsICdNaXNzaW5nIHVzZXJJZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNsaWVudElkID0gdGhpcy5nZW5lcmF0ZUNsaWVudElkKCk7XG4gICAgICBjb25zdCBjbGllbnQ6IENsaWVudENvbm5lY3Rpb24gPSB7IHdzLCB1c2VySWQsIGpvYklkOiBqb2JJZCB8fCB1bmRlZmluZWQgfTtcbiAgICAgIHRoaXMuY2xpZW50cy5zZXQoY2xpZW50SWQsIGNsaWVudCk7XG5cbiAgICAgIGNvbnNvbGUubG9nKGBXZWJTb2NrZXQgY2xpZW50IGNvbm5lY3RlZDogJHtjbGllbnRJZH0gKHVzZXI6ICR7dXNlcklkfSwgam9iOiAke2pvYklkfSlgKTtcblxuICAgICAgLy8gU2VuZCBpbml0aWFsIGNvbm5lY3Rpb24gY29uZmlybWF0aW9uXG4gICAgICB0aGlzLnNlbmRUb0NsaWVudChjbGllbnRJZCwge1xuICAgICAgICB0eXBlOiAnY29ubmVjdGlvbicsXG4gICAgICAgIG1lc3NhZ2U6ICdDb25uZWN0ZWQgdG8gSW5kZXhOb3cgUHJvIFdlYlNvY2tldCdcbiAgICAgIH0pO1xuXG4gICAgICB3cy5vbignbWVzc2FnZScsIChkYXRhKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04ucGFyc2UoZGF0YS50b1N0cmluZygpKTtcbiAgICAgICAgICB0aGlzLmhhbmRsZUNsaWVudE1lc3NhZ2UoY2xpZW50SWQsIG1lc3NhZ2UpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBhcnNpbmcgV2ViU29ja2V0IG1lc3NhZ2U6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgd3Mub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhgV2ViU29ja2V0IGNsaWVudCBkaXNjb25uZWN0ZWQ6ICR7Y2xpZW50SWR9YCk7XG4gICAgICAgIHRoaXMuY2xpZW50cy5kZWxldGUoY2xpZW50SWQpO1xuICAgICAgfSk7XG5cbiAgICAgIHdzLm9uKCdlcnJvcicsIChlcnJvcikgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdXZWJTb2NrZXQgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICB0aGlzLmNsaWVudHMuZGVsZXRlKGNsaWVudElkKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgY29uc29sZS5sb2coJ1dlYlNvY2tldCBzZXJ2ZXIgaW5pdGlhbGl6ZWQgb24gcGF0aCAvd3MnKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVDbGllbnRJZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgY2xpZW50LSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YDtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlQ2xpZW50TWVzc2FnZShjbGllbnRJZDogc3RyaW5nLCBtZXNzYWdlOiBhbnkpOiB2b2lkIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudHMuZ2V0KGNsaWVudElkKTtcbiAgICBpZiAoIWNsaWVudCkgcmV0dXJuO1xuXG4gICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3N1YnNjcmliZV9qb2InOlxuICAgICAgICBjbGllbnQuam9iSWQgPSBtZXNzYWdlLmpvYklkO1xuICAgICAgICB0aGlzLnNlbmRUb0NsaWVudChjbGllbnRJZCwge1xuICAgICAgICAgIHR5cGU6ICdzdWJzY3JpYmVkJyxcbiAgICAgICAgICBqb2JJZDogbWVzc2FnZS5qb2JJZFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBcbiAgICAgIGNhc2UgJ3Vuc3Vic2NyaWJlX2pvYic6XG4gICAgICAgIGNsaWVudC5qb2JJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zZW5kVG9DbGllbnQoY2xpZW50SWQsIHtcbiAgICAgICAgICB0eXBlOiAndW5zdWJzY3JpYmVkJ1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAgIFxuICAgICAgY2FzZSAncGluZyc6XG4gICAgICAgIHRoaXMuc2VuZFRvQ2xpZW50KGNsaWVudElkLCB7XG4gICAgICAgICAgdHlwZTogJ3BvbmcnXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBicm9hZGNhc3RKb2JVcGRhdGUodXNlcklkOiBzdHJpbmcsIGpvYklkOiBzdHJpbmcsIHVwZGF0ZTogT21pdDxKb2JVcGRhdGUsICdqb2JJZCc+KTogdm9pZCB7XG4gICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgIHR5cGU6ICdqb2JfdXBkYXRlJyxcbiAgICAgIGpvYklkLFxuICAgICAgLi4udXBkYXRlXG4gICAgfTtcblxuICAgIC8vIFNlbmQgdG8gYWxsIGNsaWVudHMgb2YgdGhpcyB1c2VyIHdobyBhcmUgc3Vic2NyaWJlZCB0byB0aGlzIGpvYlxuICAgIHRoaXMuY2xpZW50cy5mb3JFYWNoKChjbGllbnQsIGNsaWVudElkKSA9PiB7XG4gICAgICBpZiAoY2xpZW50LnVzZXJJZCA9PT0gdXNlcklkICYmIFxuICAgICAgICAgIChjbGllbnQuam9iSWQgPT09IGpvYklkIHx8ICFjbGllbnQuam9iSWQpICYmIFxuICAgICAgICAgIGNsaWVudC53cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgICB0aGlzLnNlbmRUb0NsaWVudChjbGllbnRJZCwgbWVzc2FnZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBicm9hZGNhc3RUb1VzZXIodXNlcklkOiBzdHJpbmcsIG1lc3NhZ2U6IGFueSk6IHZvaWQge1xuICAgIHRoaXMuY2xpZW50cy5mb3JFYWNoKChjbGllbnQsIGNsaWVudElkKSA9PiB7XG4gICAgICBpZiAoY2xpZW50LnVzZXJJZCA9PT0gdXNlcklkICYmIGNsaWVudC53cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgICB0aGlzLnNlbmRUb0NsaWVudChjbGllbnRJZCwgbWVzc2FnZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHNlbmRUb0NsaWVudChjbGllbnRJZDogc3RyaW5nLCBtZXNzYWdlOiBhbnkpOiB2b2lkIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudHMuZ2V0KGNsaWVudElkKTtcbiAgICBpZiAoY2xpZW50ICYmIGNsaWVudC53cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2xpZW50LndzLnNlbmQoSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2VuZGluZyBXZWJTb2NrZXQgbWVzc2FnZTonLCBlcnJvcik7XG4gICAgICAgIHRoaXMuY2xpZW50cy5kZWxldGUoY2xpZW50SWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldENvbm5lY3RlZENsaWVudHMoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnRzLnNpemU7XG4gIH1cblxuICBnZXRDbGllbnRzQnlVc2VyKHVzZXJJZDogc3RyaW5nKTogbnVtYmVyIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNsaWVudHMudmFsdWVzKCkpXG4gICAgICAuZmlsdGVyKGNsaWVudCA9PiBjbGllbnQudXNlcklkID09PSB1c2VySWQpLmxlbmd0aDtcbiAgfVxufSJdLCJuYW1lcyI6WyJXZWJTb2NrZXRTZXJ2ZXIiLCJXZWJTb2NrZXQiLCJXZWJTb2NrZXRTZXJ2aWNlIiwiZ2V0SW5zdGFuY2UiLCJpbnN0YW5jZSIsImluaXRpYWxpemUiLCJzZXJ2ZXIiLCJ3c3MiLCJwYXRoIiwidmVyaWZ5Q2xpZW50IiwiaW5mbyIsIm9uIiwid3MiLCJyZXF1ZXN0IiwidXJsIiwiVVJMIiwidXNlcklkIiwic2VhcmNoUGFyYW1zIiwiZ2V0Iiwiam9iSWQiLCJjbG9zZSIsImNsaWVudElkIiwiZ2VuZXJhdGVDbGllbnRJZCIsImNsaWVudCIsInVuZGVmaW5lZCIsImNsaWVudHMiLCJzZXQiLCJjb25zb2xlIiwibG9nIiwic2VuZFRvQ2xpZW50IiwidHlwZSIsIm1lc3NhZ2UiLCJkYXRhIiwiSlNPTiIsInBhcnNlIiwidG9TdHJpbmciLCJoYW5kbGVDbGllbnRNZXNzYWdlIiwiZXJyb3IiLCJkZWxldGUiLCJEYXRlIiwibm93IiwiTWF0aCIsInJhbmRvbSIsInN1YnN0ciIsImJyb2FkY2FzdEpvYlVwZGF0ZSIsInVwZGF0ZSIsImZvckVhY2giLCJyZWFkeVN0YXRlIiwiT1BFTiIsImJyb2FkY2FzdFRvVXNlciIsInNlbmQiLCJzdHJpbmdpZnkiLCJnZXRDb25uZWN0ZWRDbGllbnRzIiwic2l6ZSIsImdldENsaWVudHNCeVVzZXIiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJmaWx0ZXIiLCJsZW5ndGgiLCJNYXAiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/websocket-service.ts\n");

/***/ }),

/***/ "(rsc)/./lib/worker-startup.ts":
/*!*******************************!*\
  !*** ./lib/worker-startup.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBackgroundServicesStatus: () => (/* binding */ getBackgroundServicesStatus),\n/* harmony export */   startBackgroundServices: () => (/* binding */ startBackgroundServices),\n/* harmony export */   stopBackgroundServices: () => (/* binding */ stopBackgroundServices)\n/* harmony export */ });\n/* harmony import */ var _background_worker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./background-worker */ \"(rsc)/./lib/background-worker.ts\");\n\n/**\n * Worker Startup Module\n * \n * Initializes background services when the application starts.\n * This should be imported and called once during app initialization.\n */ let isStarted = false;\nfunction startBackgroundServices() {\n    if (isStarted) {\n        console.log('Background services already started');\n        return;\n    }\n    console.log('🚀 Initializing IndexNow Pro background services...');\n    try {\n        // Start the background worker\n        _background_worker__WEBPACK_IMPORTED_MODULE_0__.backgroundWorker.start();\n        isStarted = true;\n        console.log('✅ Background services started successfully');\n    } catch (error) {\n        console.error('❌ Failed to start background services:', error);\n    }\n}\nfunction stopBackgroundServices() {\n    if (!isStarted) {\n        console.log('Background services are not running');\n        return;\n    }\n    console.log('🛑 Stopping IndexNow Pro background services...');\n    try {\n        _background_worker__WEBPACK_IMPORTED_MODULE_0__.backgroundWorker.stop();\n        isStarted = false;\n        console.log('✅ Background services stopped successfully');\n    } catch (error) {\n        console.error('❌ Failed to stop background services:', error);\n    }\n}\nfunction getBackgroundServicesStatus() {\n    return {\n        isStarted,\n        worker: _background_worker__WEBPACK_IMPORTED_MODULE_0__.backgroundWorker.getStatus()\n    };\n}\n// Auto-start in production or development\nif (true) {\n    // Use process.nextTick to ensure modules are loaded and avoid multiple instances\n    process.nextTick(()=>{\n        if (!global.backgroundServicesStarted) {\n            global.backgroundServicesStarted = true;\n            startBackgroundServices();\n        }\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvd29ya2VyLXN0YXJ0dXAudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF1RDtBQUV2RDs7Ozs7Q0FLQyxHQUVELElBQUlDLFlBQVk7QUFFVCxTQUFTQztJQUNkLElBQUlELFdBQVc7UUFDYkUsUUFBUUMsR0FBRyxDQUFDO1FBQ1o7SUFDRjtJQUVBRCxRQUFRQyxHQUFHLENBQUM7SUFFWixJQUFJO1FBQ0YsOEJBQThCO1FBQzlCSixnRUFBZ0JBLENBQUNLLEtBQUs7UUFDdEJKLFlBQVk7UUFFWkUsUUFBUUMsR0FBRyxDQUFDO0lBQ2QsRUFBRSxPQUFPRSxPQUFPO1FBQ2RILFFBQVFHLEtBQUssQ0FBQywwQ0FBMENBO0lBQzFEO0FBQ0Y7QUFFTyxTQUFTQztJQUNkLElBQUksQ0FBQ04sV0FBVztRQUNkRSxRQUFRQyxHQUFHLENBQUM7UUFDWjtJQUNGO0lBRUFELFFBQVFDLEdBQUcsQ0FBQztJQUVaLElBQUk7UUFDRkosZ0VBQWdCQSxDQUFDUSxJQUFJO1FBQ3JCUCxZQUFZO1FBRVpFLFFBQVFDLEdBQUcsQ0FBQztJQUNkLEVBQUUsT0FBT0UsT0FBTztRQUNkSCxRQUFRRyxLQUFLLENBQUMseUNBQXlDQTtJQUN6RDtBQUNGO0FBRU8sU0FBU0c7SUFDZCxPQUFPO1FBQ0xSO1FBQ0FTLFFBQVFWLGdFQUFnQkEsQ0FBQ1csU0FBUztJQUNwQztBQUNGO0FBRUEsMENBQTBDO0FBQzFDLElBQUksSUFBNkIsRUFBRTtJQUNqQyxpRkFBaUY7SUFDakZDLFFBQVFDLFFBQVEsQ0FBQztRQUNmLElBQUksQ0FBQyxPQUFnQkUseUJBQXlCLEVBQUU7WUFDN0NELE9BQWVDLHlCQUF5QixHQUFHO1lBQzVDYjtRQUNGO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9saWIvd29ya2VyLXN0YXJ0dXAudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYmFja2dyb3VuZFdvcmtlciB9IGZyb20gJy4vYmFja2dyb3VuZC13b3JrZXInO1xuXG4vKipcbiAqIFdvcmtlciBTdGFydHVwIE1vZHVsZVxuICogXG4gKiBJbml0aWFsaXplcyBiYWNrZ3JvdW5kIHNlcnZpY2VzIHdoZW4gdGhlIGFwcGxpY2F0aW9uIHN0YXJ0cy5cbiAqIFRoaXMgc2hvdWxkIGJlIGltcG9ydGVkIGFuZCBjYWxsZWQgb25jZSBkdXJpbmcgYXBwIGluaXRpYWxpemF0aW9uLlxuICovXG5cbmxldCBpc1N0YXJ0ZWQgPSBmYWxzZTtcblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0QmFja2dyb3VuZFNlcnZpY2VzKCk6IHZvaWQge1xuICBpZiAoaXNTdGFydGVkKSB7XG4gICAgY29uc29sZS5sb2coJ0JhY2tncm91bmQgc2VydmljZXMgYWxyZWFkeSBzdGFydGVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc29sZS5sb2coJ/CfmoAgSW5pdGlhbGl6aW5nIEluZGV4Tm93IFBybyBiYWNrZ3JvdW5kIHNlcnZpY2VzLi4uJyk7XG4gIFxuICB0cnkge1xuICAgIC8vIFN0YXJ0IHRoZSBiYWNrZ3JvdW5kIHdvcmtlclxuICAgIGJhY2tncm91bmRXb3JrZXIuc3RhcnQoKTtcbiAgICBpc1N0YXJ0ZWQgPSB0cnVlO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCfinIUgQmFja2dyb3VuZCBzZXJ2aWNlcyBzdGFydGVkIHN1Y2Nlc3NmdWxseScpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gc3RhcnQgYmFja2dyb3VuZCBzZXJ2aWNlczonLCBlcnJvcik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0b3BCYWNrZ3JvdW5kU2VydmljZXMoKTogdm9pZCB7XG4gIGlmICghaXNTdGFydGVkKSB7XG4gICAgY29uc29sZS5sb2coJ0JhY2tncm91bmQgc2VydmljZXMgYXJlIG5vdCBydW5uaW5nJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc29sZS5sb2coJ/Cfm5EgU3RvcHBpbmcgSW5kZXhOb3cgUHJvIGJhY2tncm91bmQgc2VydmljZXMuLi4nKTtcbiAgXG4gIHRyeSB7XG4gICAgYmFja2dyb3VuZFdvcmtlci5zdG9wKCk7XG4gICAgaXNTdGFydGVkID0gZmFsc2U7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ+KchSBCYWNrZ3JvdW5kIHNlcnZpY2VzIHN0b3BwZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBzdG9wIGJhY2tncm91bmQgc2VydmljZXM6JywgZXJyb3IpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRCYWNrZ3JvdW5kU2VydmljZXNTdGF0dXMoKTogYW55IHtcbiAgcmV0dXJuIHtcbiAgICBpc1N0YXJ0ZWQsXG4gICAgd29ya2VyOiBiYWNrZ3JvdW5kV29ya2VyLmdldFN0YXR1cygpXG4gIH07XG59XG5cbi8vIEF1dG8tc3RhcnQgaW4gcHJvZHVjdGlvbiBvciBkZXZlbG9wbWVudFxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7IC8vIFNlcnZlci1zaWRlIG9ubHlcbiAgLy8gVXNlIHByb2Nlc3MubmV4dFRpY2sgdG8gZW5zdXJlIG1vZHVsZXMgYXJlIGxvYWRlZCBhbmQgYXZvaWQgbXVsdGlwbGUgaW5zdGFuY2VzXG4gIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgIGlmICghKGdsb2JhbCBhcyBhbnkpLmJhY2tncm91bmRTZXJ2aWNlc1N0YXJ0ZWQpIHtcbiAgICAgIChnbG9iYWwgYXMgYW55KS5iYWNrZ3JvdW5kU2VydmljZXNTdGFydGVkID0gdHJ1ZTtcbiAgICAgIHN0YXJ0QmFja2dyb3VuZFNlcnZpY2VzKCk7XG4gICAgfVxuICB9KTtcbn0iXSwibmFtZXMiOlsiYmFja2dyb3VuZFdvcmtlciIsImlzU3RhcnRlZCIsInN0YXJ0QmFja2dyb3VuZFNlcnZpY2VzIiwiY29uc29sZSIsImxvZyIsInN0YXJ0IiwiZXJyb3IiLCJzdG9wQmFja2dyb3VuZFNlcnZpY2VzIiwic3RvcCIsImdldEJhY2tncm91bmRTZXJ2aWNlc1N0YXR1cyIsIndvcmtlciIsImdldFN0YXR1cyIsInByb2Nlc3MiLCJuZXh0VGljayIsImdsb2JhbCIsImJhY2tncm91bmRTZXJ2aWNlc1N0YXJ0ZWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/worker-startup.ts\n");

/***/ })

};
;